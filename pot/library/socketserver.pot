# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2017, Python Software Foundation (translated by Python ドキュメント日本語翻訳プロジェクト)
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 2.7\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../library/socketserver.rst:2
msgid ":mod:`SocketServer` --- A framework for network servers"
msgstr ""

#: ../../library/socketserver.rst:9
msgid "The :mod:`SocketServer` module has been renamed to :mod:`socketserver` in Python 3.  The :term:`2to3` tool will automatically adapt imports when converting your sources to Python 3."
msgstr ""

#: ../../library/socketserver.rst:13
msgid "**Source code:** :source:`Lib/SocketServer.py`"
msgstr ""

#: ../../library/socketserver.rst:17
msgid "The :mod:`SocketServer` module simplifies the task of writing network servers."
msgstr ""

#: ../../library/socketserver.rst:19
msgid "There are four basic server classes: :class:`TCPServer` uses the Internet TCP protocol, which provides for continuous streams of data between the client and server.  :class:`UDPServer` uses datagrams, which are discrete packets of information that may arrive out of order or be lost while in transit.  The more infrequently used :class:`UnixStreamServer` and :class:`UnixDatagramServer` classes are similar, but use Unix domain sockets; they're not available on non-Unix platforms.  For more details on network programming, consult a book such as W. Richard Steven's UNIX Network Programming or Ralph Davis's Win32 Network Programming."
msgstr ""

#: ../../library/socketserver.rst:30
msgid "These four classes process requests :dfn:`synchronously`; each request must be completed before the next request can be started.  This isn't suitable if each request takes a long time to complete, because it requires a lot of computation, or because it returns a lot of data which the client is slow to process.  The solution is to create a separate process or thread to handle each request; the :class:`ForkingMixIn` and :class:`ThreadingMixIn` mix-in classes can be used to support asynchronous behaviour."
msgstr ""

#: ../../library/socketserver.rst:38
msgid "Creating a server requires several steps.  First, you must create a request handler class by subclassing the :class:`BaseRequestHandler` class and overriding its :meth:`handle` method; this method will process incoming requests.  Second, you must instantiate one of the server classes, passing it the server's address and the request handler class.  Then call the :meth:`handle_request` or :meth:`serve_forever` method of the server object to process one or many requests.  Finally, call :meth:`~BaseServer.server_close` to close the socket."
msgstr ""

#: ../../library/socketserver.rst:47
msgid "When inheriting from :class:`ThreadingMixIn` for threaded connection behavior, you should explicitly declare how you want your threads to behave on an abrupt shutdown. The :class:`ThreadingMixIn` class defines an attribute *daemon_threads*, which indicates whether or not the server should wait for thread termination. You should set the flag explicitly if you would like threads to behave autonomously; the default is :const:`False`, meaning that Python will not exit until all threads created by :class:`ThreadingMixIn` have exited."
msgstr ""

#: ../../library/socketserver.rst:55
msgid "Server classes have the same external methods and attributes, no matter what network protocol they use."
msgstr ""

#: ../../library/socketserver.rst:60
msgid "Server Creation Notes"
msgstr ""

#: ../../library/socketserver.rst:62
msgid "There are five classes in an inheritance diagram, four of which represent synchronous servers of four types::"
msgstr ""

#: ../../library/socketserver.rst:79
msgid "Note that :class:`UnixDatagramServer` derives from :class:`UDPServer`, not from :class:`UnixStreamServer` --- the only difference between an IP and a Unix stream server is the address family, which is simply repeated in both Unix server classes."
msgstr ""

#: ../../library/socketserver.rst:84
msgid "Forking and threading versions of each type of server can be created using the :class:`ForkingMixIn` and :class:`ThreadingMixIn` mix-in classes.  For instance, a threading UDP server class is created as follows::"
msgstr ""

#: ../../library/socketserver.rst:90
msgid "The mix-in class must come first, since it overrides a method defined in :class:`UDPServer`.  Setting the various attributes also change the behavior of the underlying server mechanism."
msgstr ""

#: ../../library/socketserver.rst:94
msgid "To implement a service, you must derive a class from :class:`BaseRequestHandler` and redefine its :meth:`handle` method.  You can then run various versions of the service by combining one of the server classes with your request handler class.  The request handler class must be different for datagram or stream services.  This can be hidden by using the handler subclasses :class:`StreamRequestHandler` or :class:`DatagramRequestHandler`."
msgstr ""

#: ../../library/socketserver.rst:101
msgid "Of course, you still have to use your head!  For instance, it makes no sense to use a forking server if the service contains state in memory that can be modified by different requests, since the modifications in the child process would never reach the initial state kept in the parent process and passed to each child.  In this case, you can use a threading server, but you will probably have to use locks to protect the integrity of the shared data."
msgstr ""

#: ../../library/socketserver.rst:108
msgid "On the other hand, if you are building an HTTP server where all data is stored externally (for instance, in the file system), a synchronous class will essentially render the service \"deaf\" while one request is being handled -- which may be for a very long time if a client is slow to receive all the data it has requested.  Here a threading or forking server is appropriate."
msgstr ""

#: ../../library/socketserver.rst:114
msgid "In some cases, it may be appropriate to process part of a request synchronously, but to finish processing in a forked child depending on the request data.  This can be implemented by using a synchronous server and doing an explicit fork in the request handler class :meth:`handle` method."
msgstr ""

#: ../../library/socketserver.rst:119
msgid "Another approach to handling multiple simultaneous requests in an environment that supports neither threads nor :func:`~os.fork` (or where these are too expensive or inappropriate for the service) is to maintain an explicit table of partially finished requests and to use :func:`~select.select` to decide which request to work on next (or whether to handle a new incoming request).  This is particularly important for stream services where each client can potentially be connected for a long time (if threads or subprocesses cannot be used). See :mod:`asyncore` for another way to manage this."
msgstr ""

#: ../../library/socketserver.rst:133
msgid "Server Objects"
msgstr ""

#: ../../library/socketserver.rst:137
msgid "This is the superclass of all Server objects in the module.  It defines the interface, given below, but does not implement most of the methods, which is done in subclasses."
msgstr ""

#: ../../library/socketserver.rst:144
msgid "Return an integer file descriptor for the socket on which the server is listening.  This function is most commonly passed to :func:`select.select`, to allow monitoring multiple servers in the same process."
msgstr ""

#: ../../library/socketserver.rst:151
msgid "Process a single request.  This function calls the following methods in order: :meth:`get_request`, :meth:`verify_request`, and :meth:`process_request`.  If the user-provided :meth:`handle` method of the handler class raises an exception, the server's :meth:`handle_error` method will be called.  If no request is received within :attr:`self.timeout` seconds, :meth:`handle_timeout` will be called and :meth:`handle_request` will return."
msgstr ""

#: ../../library/socketserver.rst:162
msgid "Handle requests until an explicit :meth:`shutdown` request. Poll for shutdown every *poll_interval* seconds. Ignores :attr:`self.timeout`. If you need to do periodic tasks, do them in another thread."
msgstr ""

#: ../../library/socketserver.rst:169
msgid "Tell the :meth:`serve_forever` loop to stop and wait until it does."
msgstr ""

#: ../../library/socketserver.rst:176
msgid "Clean up the server. May be overridden."
msgstr ""

#: ../../library/socketserver.rst:183
msgid "The family of protocols to which the server's socket belongs. Common examples are :const:`socket.AF_INET` and :const:`socket.AF_UNIX`."
msgstr ""

#: ../../library/socketserver.rst:189
msgid "The user-provided request handler class; an instance of this class is created for each request."
msgstr ""

#: ../../library/socketserver.rst:195
msgid "The address on which the server is listening.  The format of addresses varies depending on the protocol family; see the documentation for the socket module for details.  For Internet protocols, this is a tuple containing a string giving the address, and an integer port number: ``('127.0.0.1', 80)``, for example."
msgstr ""

#: ../../library/socketserver.rst:203
msgid "The socket object on which the server will listen for incoming requests."
msgstr ""

#: ../../library/socketserver.rst:206
msgid "The server classes support the following class variables:"
msgstr ""

#: ../../library/socketserver.rst:212
msgid "Whether the server will allow the reuse of an address. This defaults to :const:`False`, and can be set in subclasses to change the policy."
msgstr ""

#: ../../library/socketserver.rst:218
msgid "The size of the request queue.  If it takes a long time to process a single request, any requests that arrive while the server is busy are placed into a queue, up to :attr:`request_queue_size` requests.  Once the queue is full, further requests from clients will get a \"Connection denied\" error.  The default value is usually 5, but this can be overridden by subclasses."
msgstr ""

#: ../../library/socketserver.rst:227
msgid "The type of socket used by the server; :const:`socket.SOCK_STREAM` and :const:`socket.SOCK_DGRAM` are two common values."
msgstr ""

#: ../../library/socketserver.rst:233
msgid "Timeout duration, measured in seconds, or :const:`None` if no timeout is desired.  If :meth:`handle_request` receives no incoming requests within the timeout period, the :meth:`handle_timeout` method is called."
msgstr ""

#: ../../library/socketserver.rst:238
msgid "There are various server methods that can be overridden by subclasses of base server classes like :class:`TCPServer`; these methods aren't useful to external users of the server object."
msgstr ""

#: ../../library/socketserver.rst:247
msgid "Actually processes the request by instantiating :attr:`RequestHandlerClass` and calling its :meth:`handle` method."
msgstr ""

#: ../../library/socketserver.rst:253
msgid "Must accept a request from the socket, and return a 2-tuple containing the *new* socket object to be used to communicate with the client, and the client's address."
msgstr ""

#: ../../library/socketserver.rst:260
msgid "This function is called if the :attr:`RequestHandlerClass`'s :meth:`handle` method raises an exception.  The default action is to print the traceback to standard output and continue handling further requests."
msgstr ""

#: ../../library/socketserver.rst:267
msgid "This function is called when the :attr:`timeout` attribute has been set to a value other than :const:`None` and the timeout period has passed with no requests being received.  The default action for forking servers is to collect the status of any child processes that have exited, while in threading servers this method does nothing."
msgstr ""

#: ../../library/socketserver.rst:276
msgid "Calls :meth:`finish_request` to create an instance of the :attr:`RequestHandlerClass`.  If desired, this function can create a new process or thread to handle the request; the :class:`ForkingMixIn` and :class:`ThreadingMixIn` classes do this."
msgstr ""

#: ../../library/socketserver.rst:288
msgid "Called by the server's constructor to activate the server.  The default behavior just :meth:`listen`\\ s to the server's socket. May be overridden."
msgstr ""

#: ../../library/socketserver.rst:294
msgid "Called by the server's constructor to bind the socket to the desired address. May be overridden."
msgstr ""

#: ../../library/socketserver.rst:300
msgid "Must return a Boolean value; if the value is :const:`True`, the request will be processed, and if it's :const:`False`, the request will be denied. This function can be overridden to implement access controls for a server. The default implementation always returns :const:`True`."
msgstr ""

#: ../../library/socketserver.rst:307
msgid "RequestHandler Objects"
msgstr ""

#: ../../library/socketserver.rst:309
msgid "The request handler class must define a new :meth:`handle` method, and can override any of the following methods.  A new instance is created for each request."
msgstr ""

#: ../../library/socketserver.rst:316
msgid "Called after the :meth:`handle` method to perform any clean-up actions required.  The default implementation does nothing.  If :meth:`setup` raises an exception, this function will not be called."
msgstr ""

#: ../../library/socketserver.rst:323
msgid "This function must do all the work required to service a request.  The default implementation does nothing.  Several instance attributes are available to it; the request is available as :attr:`self.request`; the client address as :attr:`self.client_address`; and the server instance as :attr:`self.server`, in case it needs access to per-server information."
msgstr ""

#: ../../library/socketserver.rst:329
msgid "The type of :attr:`self.request` is different for datagram or stream services.  For stream services, :attr:`self.request` is a socket object; for datagram services, :attr:`self.request` is a pair of string and socket. However, this can be hidden by using the request handler subclasses :class:`StreamRequestHandler` or :class:`DatagramRequestHandler`, which override the :meth:`setup` and :meth:`finish` methods, and provide :attr:`self.rfile` and :attr:`self.wfile` attributes.  :attr:`self.rfile` and :attr:`self.wfile` can be read or written, respectively, to get the request data or return data to the client."
msgstr ""

#: ../../library/socketserver.rst:342
msgid "Called before the :meth:`handle` method to perform any initialization actions required.  The default implementation does nothing."
msgstr ""

#: ../../library/socketserver.rst:347
msgid "Examples"
msgstr ""

#: ../../library/socketserver.rst:350
msgid ":class:`SocketServer.TCPServer` Example"
msgstr ""

#: ../../library/socketserver.rst:352
#: ../../library/socketserver.rst:452
msgid "This is the server side::"
msgstr ""

#: ../../library/socketserver.rst:383
msgid "An alternative request handler class that makes use of streams (file-like objects that simplify communication by providing the standard file interface)::"
msgstr ""

#: ../../library/socketserver.rst:398
msgid "The difference is that the ``readline()`` call in the second handler will call ``recv()`` multiple times until it encounters a newline character, while the single ``recv()`` call in the first handler will just return what has been sent from the client in one ``sendall()`` call."
msgstr ""

#: ../../library/socketserver.rst:404
#: ../../library/socketserver.rst:476
msgid "This is the client side::"
msgstr ""

#: ../../library/socketserver.rst:429
msgid "The output of the example should look something like this:"
msgstr ""

#: ../../library/socketserver.rst:431
msgid "Server::"
msgstr ""

#: ../../library/socketserver.rst:439
msgid "Client::"
msgstr ""

#: ../../library/socketserver.rst:450
msgid ":class:`SocketServer.UDPServer` Example"
msgstr ""

#: ../../library/socketserver.rst:495
msgid "The output of the example should look exactly like for the TCP server example."
msgstr ""

#: ../../library/socketserver.rst:499
msgid "Asynchronous Mixins"
msgstr ""

#: ../../library/socketserver.rst:501
msgid "To build asynchronous handlers, use the :class:`ThreadingMixIn` and :class:`ForkingMixIn` classes."
msgstr ""

#: ../../library/socketserver.rst:504
msgid "An example for the :class:`ThreadingMixIn` class::"
msgstr ""

#: ../../library/socketserver.rst:554
msgid "The output of the example should look something like this::"
msgstr ""

#: ../../library/socketserver.rst:563
msgid "The :class:`ForkingMixIn` class is used in the same way, except that the server will spawn a new process for each request."
msgstr ""

