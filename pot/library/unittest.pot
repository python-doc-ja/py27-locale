# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2017, Python Software Foundation (translated by Python ドキュメント日本語翻訳プロジェクト)
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 2.7\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../library/unittest.rst:2
msgid ":mod:`unittest` --- Unit testing framework"
msgstr ""

#: ../../library/unittest.rst:13
msgid "(If you are already familiar with the basic concepts of testing, you might want to skip to :ref:`the list of assert methods <assert-methods>`.)"
msgstr ""

#: ../../library/unittest.rst:16
msgid "The Python unit testing framework, sometimes referred to as \"PyUnit,\" is a Python language version of JUnit, by Kent Beck and Erich Gamma. JUnit is, in turn, a Java version of Kent's Smalltalk testing framework.  Each is the de facto standard unit testing framework for its respective language."
msgstr ""

#: ../../library/unittest.rst:21
msgid ":mod:`unittest` supports test automation, sharing of setup and shutdown code for tests, aggregation of tests into collections, and independence of the tests from the reporting framework.  The :mod:`unittest` module provides classes that make it easy to support these qualities for a set of tests."
msgstr ""

#: ../../library/unittest.rst:26
msgid "To achieve this, :mod:`unittest` supports some important concepts:"
msgstr ""

#: ../../library/unittest.rst:32
msgid "test fixture"
msgstr ""

#: ../../library/unittest.rst:29
msgid "A :dfn:`test fixture` represents the preparation needed to perform one or more tests, and any associate cleanup actions.  This may involve, for example, creating temporary or proxy databases, directories, or starting a server process."
msgstr ""

#: ../../library/unittest.rst:37
msgid "test case"
msgstr ""

#: ../../library/unittest.rst:35
msgid "A :dfn:`test case` is the smallest unit of testing.  It checks for a specific response to a particular set of inputs.  :mod:`unittest` provides a base class, :class:`TestCase`, which may be used to create new test cases."
msgstr ""

#: ../../library/unittest.rst:41
msgid "test suite"
msgstr ""

#: ../../library/unittest.rst:40
msgid "A :dfn:`test suite` is a collection of test cases, test suites, or both.  It is used to aggregate tests that should be executed together."
msgstr ""

#: ../../library/unittest.rst:47
msgid "test runner"
msgstr ""

#: ../../library/unittest.rst:44
msgid "A :dfn:`test runner` is a component which orchestrates the execution of tests and provides the outcome to the user.  The runner may use a graphical interface, a textual interface, or return a special value to indicate the results of executing the tests."
msgstr ""

#: ../../library/unittest.rst:49
msgid "The test case and test fixture concepts are supported through the :class:`TestCase` and :class:`FunctionTestCase` classes; the former should be used when creating new tests, and the latter can be used when integrating existing test code with a :mod:`unittest`\\ -driven framework. When building test fixtures using :class:`TestCase`, the :meth:`~TestCase.setUp` and :meth:`~TestCase.tearDown` methods can be overridden to provide initialization and cleanup for the fixture.  With :class:`FunctionTestCase`, existing functions can be passed to the constructor for these purposes.  When the test is run, the fixture initialization is run first; if it succeeds, the cleanup method is run after the test has been executed, regardless of the outcome of the test.  Each instance of the :class:`TestCase` will only be used to run a single test method, so a new fixture is created for each test."
msgstr ""

#: ../../library/unittest.rst:62
msgid "Test suites are implemented by the :class:`TestSuite` class.  This class allows individual tests and test suites to be aggregated; when the suite is executed, all tests added directly to the suite and in \"child\" test suites are run."
msgstr ""

#: ../../library/unittest.rst:66
msgid "A test runner is an object that provides a single method, :meth:`~TestRunner.run`, which accepts a :class:`TestCase` or :class:`TestSuite` object as a parameter, and returns a result object.  The class :class:`TestResult` is provided for use as the result object. :mod:`unittest` provides the :class:`TextTestRunner` as an example test runner which reports test results on the standard error stream by default.  Alternate runners can be implemented for other environments (such as graphical environments) without any need to derive from a specific class."
msgstr ""

#: ../../library/unittest.rst:79
msgid "Module :mod:`doctest`"
msgstr ""

#: ../../library/unittest.rst:79
msgid "Another test-support module with a very different flavor."
msgstr ""

#: ../../library/unittest.rst:84
msgid "`unittest2: A backport of new unittest features for Python 2.4-2.6 <https://pypi.python.org/pypi/unittest2>`_"
msgstr ""

#: ../../library/unittest.rst:82
msgid "Many new features were added to unittest in Python 2.7, including test discovery. unittest2 allows you to use these features with earlier versions of Python."
msgstr ""

#: ../../library/unittest.rst:88
msgid "`Simple Smalltalk Testing: With Patterns <https://web.archive.org/web/20150315073817/http://www.xprogramming.com/testfram.htm>`_"
msgstr ""

#: ../../library/unittest.rst:87
msgid "Kent Beck's original paper on testing frameworks using the pattern shared by :mod:`unittest`."
msgstr ""

#: ../../library/unittest.rst:92
msgid "`Nose <https://nose.readthedocs.org/en/latest/>`_ and `py.test <http://pytest.org>`_"
msgstr ""

#: ../../library/unittest.rst:91
msgid "Third-party unittest frameworks with a lighter-weight syntax for writing tests.  For example, ``assert func(10) == 42``."
msgstr ""

#: ../../library/unittest.rst:96
msgid "`The Python Testing Tools Taxonomy <https://wiki.python.org/moin/PythonTestingToolsTaxonomy>`_"
msgstr ""

#: ../../library/unittest.rst:95
msgid "An extensive list of Python testing tools including functional testing frameworks and mock object libraries."
msgstr ""

#: ../../library/unittest.rst:99
msgid "`Testing in Python Mailing List <http://lists.idyll.org/listinfo/testing-in-python>`_"
msgstr ""

#: ../../library/unittest.rst:99
msgid "A special-interest-group for discussion of testing, and testing tools, in Python."
msgstr ""

#: ../../library/unittest.rst:106
msgid "Basic example"
msgstr ""

#: ../../library/unittest.rst:108
msgid "The :mod:`unittest` module provides a rich set of tools for constructing and running tests.  This section demonstrates that a small subset of the tools suffice to meet the needs of most users."
msgstr ""

#: ../../library/unittest.rst:112
msgid "Here is a short script to test three string methods::"
msgstr ""

#: ../../library/unittest.rst:136
msgid "A testcase is created by subclassing :class:`unittest.TestCase`.  The three individual tests are defined with methods whose names start with the letters ``test``.  This naming convention informs the test runner about which methods represent tests."
msgstr ""

#: ../../library/unittest.rst:141
msgid "The crux of each test is a call to :meth:`~TestCase.assertEqual` to check for an expected result; :meth:`~TestCase.assertTrue` or :meth:`~TestCase.assertFalse` to verify a condition; or :meth:`~TestCase.assertRaises` to verify that a specific exception gets raised.  These methods are used instead of the :keyword:`assert` statement so the test runner can accumulate all test results and produce a report."
msgstr ""

#: ../../library/unittest.rst:148
msgid "The :meth:`~TestCase.setUp` and :meth:`~TestCase.tearDown` methods allow you to define instructions that will be executed before and after each test method. They are covered in more details in the section :ref:`organizing-tests`."
msgstr ""

#: ../../library/unittest.rst:152
msgid "The final block shows a simple way to run the tests. :func:`unittest.main` provides a command-line interface to the test script.  When run from the command line, the above script produces an output that looks like this::"
msgstr ""

#: ../../library/unittest.rst:162
msgid "Instead of :func:`unittest.main`, there are other ways to run the tests with a finer level of control, less terse output, and no requirement to be run from the command line.  For example, the last two lines may be replaced with::"
msgstr ""

#: ../../library/unittest.rst:169
msgid "Running the revised script from the interpreter or another script produces the following output::"
msgstr ""

#: ../../library/unittest.rst:181
msgid "The above examples show the most commonly used :mod:`unittest` features which are sufficient to meet many everyday testing needs.  The remainder of the documentation explores the full feature set from first principles."
msgstr ""

#: ../../library/unittest.rst:189
msgid "Command-Line Interface"
msgstr ""

#: ../../library/unittest.rst:191
msgid "The unittest module can be used from the command line to run tests from modules, classes or even individual test methods::"
msgstr ""

#: ../../library/unittest.rst:198
msgid "You can pass in a list with any combination of module names, and fully qualified class or method names."
msgstr ""

#: ../../library/unittest.rst:201
msgid "You can run tests with more detail (higher verbosity) by passing in the -v flag::"
msgstr ""

#: ../../library/unittest.rst:205
msgid "For a list of all the command-line options::"
msgstr ""

#: ../../library/unittest.rst:209
msgid "In earlier versions it was only possible to run individual test methods and not modules or classes."
msgstr ""

#: ../../library/unittest.rst:215
msgid "Command-line options"
msgstr ""

#: ../../library/unittest.rst:217
msgid ":program:`unittest` supports these command-line options:"
msgstr ""

#: ../../library/unittest.rst:223
msgid "The standard output and standard error streams are buffered during the test run. Output during a passing test is discarded. Output is echoed normally on test fail or error and is added to the failure messages."
msgstr ""

#: ../../library/unittest.rst:229
msgid ":kbd:`Control-C` during the test run waits for the current test to end and then reports all the results so far. A second :kbd:`Control-C` raises the normal :exc:`KeyboardInterrupt` exception."
msgstr ""

#: ../../library/unittest.rst:233
msgid "See `Signal Handling`_ for the functions that provide this functionality."
msgstr ""

#: ../../library/unittest.rst:237
msgid "Stop the test run on the first error or failure."
msgstr ""

#: ../../library/unittest.rst:239
msgid "The command-line options ``-b``, ``-c`` and ``-f`` were added."
msgstr ""

#: ../../library/unittest.rst:242
msgid "The command line can also be used for test discovery, for running all of the tests in a project or just a subset."
msgstr ""

#: ../../library/unittest.rst:249
msgid "Test Discovery"
msgstr ""

#: ../../library/unittest.rst:253
msgid "Unittest supports simple test discovery. In order to be compatible with test discovery, all of the test files must be :ref:`modules <tut-modules>` or :ref:`packages <tut-packages>` importable from the top-level directory of the project (this means that their filenames must be valid :ref:`identifiers <identifiers>`)."
msgstr ""

#: ../../library/unittest.rst:259
msgid "Test discovery is implemented in :meth:`TestLoader.discover`, but can also be used from the command line. The basic command-line usage is::"
msgstr ""

#: ../../library/unittest.rst:265
msgid "The ``discover`` sub-command has the following options:"
msgstr ""

#: ../../library/unittest.rst:271
msgid "Verbose output"
msgstr ""

#: ../../library/unittest.rst:275
msgid "Directory to start discovery (``.`` default)"
msgstr ""

#: ../../library/unittest.rst:279
msgid "Pattern to match test files (``test*.py`` default)"
msgstr ""

#: ../../library/unittest.rst:283
msgid "Top level directory of project (defaults to start directory)"
msgstr ""

#: ../../library/unittest.rst:285
msgid "The :option:`-s`, :option:`-p`, and :option:`-t` options can be passed in as positional arguments in that order. The following two command lines are equivalent::"
msgstr ""

#: ../../library/unittest.rst:292
msgid "As well as being a path it is possible to pass a package name, for example ``myproject.subpackage.test``, as the start directory. The package name you supply will then be imported and its location on the filesystem will be used as the start directory."
msgstr ""

#: ../../library/unittest.rst:299
msgid "Test discovery loads tests by importing them. Once test discovery has found all the test files from the start directory you specify it turns the paths into package names to import. For example :file:`foo/bar/baz.py` will be imported as ``foo.bar.baz``."
msgstr ""

#: ../../library/unittest.rst:304
msgid "If you have a package installed globally and attempt test discovery on a different copy of the package then the import *could* happen from the wrong place. If this happens test discovery will warn you and exit."
msgstr ""

#: ../../library/unittest.rst:308
msgid "If you supply the start directory as a package name rather than a path to a directory then discover assumes that whichever location it imports from is the location you intended, so you will not get the warning."
msgstr ""

#: ../../library/unittest.rst:313
msgid "Test modules and packages can customize test loading and discovery by through the `load_tests protocol`_."
msgstr ""

#: ../../library/unittest.rst:320
msgid "Organizing test code"
msgstr ""

#: ../../library/unittest.rst:322
msgid "The basic building blocks of unit testing are :dfn:`test cases` --- single scenarios that must be set up and checked for correctness.  In :mod:`unittest`, test cases are represented by instances of :mod:`unittest`'s :class:`TestCase` class. To make your own test cases you must write subclasses of :class:`TestCase`, or use :class:`FunctionTestCase`."
msgstr ""

#: ../../library/unittest.rst:328
msgid "An instance of a :class:`TestCase`\\ -derived class is an object that can completely run a single test method, together with optional set-up and tidy-up code."
msgstr ""

#: ../../library/unittest.rst:332
msgid "The testing code of a :class:`TestCase` instance should be entirely self contained, such that it can be run either in isolation or in arbitrary combination with any number of other test cases."
msgstr ""

#: ../../library/unittest.rst:336
msgid "The simplest :class:`TestCase` subclass will simply override the :meth:`~TestCase.runTest` method in order to perform specific testing code::"
msgstr ""

#: ../../library/unittest.rst:346
msgid "Note that in order to test something, we use one of the :meth:`assert\\*` methods provided by the :class:`TestCase` base class.  If the test fails, an exception will be raised, and :mod:`unittest` will identify the test case as a :dfn:`failure`.  Any other exceptions will be treated as :dfn:`errors`. This helps you identify where the problem is: :dfn:`failures` are caused by incorrect results - a 5 where you expected a 6. :dfn:`Errors` are caused by incorrect code - e.g., a :exc:`TypeError` caused by an incorrect function call."
msgstr ""

#: ../../library/unittest.rst:354
msgid "The way to run a test case will be described later.  For now, note that to construct an instance of such a test case, we call its constructor without arguments::"
msgstr ""

#: ../../library/unittest.rst:360
msgid "Now, such test cases can be numerous, and their set-up can be repetitive.  In the above case, constructing a :class:`Widget` in each of 100 Widget test case subclasses would mean unsightly duplication."
msgstr ""

#: ../../library/unittest.rst:364
msgid "Luckily, we can factor out such set-up code by implementing a method called :meth:`~TestCase.setUp`, which the testing framework will automatically call for us when we run the test::"
msgstr ""

#: ../../library/unittest.rst:385
msgid "If the :meth:`~TestCase.setUp` method raises an exception while the test is running, the framework will consider the test to have suffered an error, and the :meth:`~TestCase.runTest` method will not be executed."
msgstr ""

#: ../../library/unittest.rst:389
msgid "Similarly, we can provide a :meth:`~TestCase.tearDown` method that tidies up after the :meth:`~TestCase.runTest` method has been run::"
msgstr ""

#: ../../library/unittest.rst:402
msgid "If :meth:`~TestCase.setUp` succeeded, the :meth:`~TestCase.tearDown` method will be run whether :meth:`~TestCase.runTest` succeeded or not."
msgstr ""

#: ../../library/unittest.rst:405
msgid "Such a working environment for the testing code is called a :dfn:`fixture`."
msgstr ""

#: ../../library/unittest.rst:407
msgid "Often, many small test cases will use the same fixture.  In this case, we would end up subclassing :class:`SimpleWidgetTestCase` into many small one-method classes such as :class:`DefaultWidgetSizeTestCase`.  This is time-consuming and discouraging, so in the same vein as JUnit, :mod:`unittest` provides a simpler mechanism::"
msgstr ""

#: ../../library/unittest.rst:432
msgid "Here we have not provided a :meth:`~TestCase.runTest` method, but have instead provided two different test methods.  Class instances will now each run one of the :meth:`test_\\*` methods, with ``self.widget`` created and destroyed separately for each instance.  When creating an instance we must specify the test method it is to run.  We do this by passing the method name in the constructor::"
msgstr ""

#: ../../library/unittest.rst:442
msgid "Test case instances are grouped together according to the features they test. :mod:`unittest` provides a mechanism for this: the :dfn:`test suite`, represented by :mod:`unittest`'s :class:`TestSuite` class::"
msgstr ""

#: ../../library/unittest.rst:450
msgid "For the ease of running tests, as we will see later, it is a good idea to provide in each test module a callable object that returns a pre-built test suite::"
msgstr ""

#: ../../library/unittest.rst:460
msgid "or even::"
msgstr ""

#: ../../library/unittest.rst:467
msgid "Since it is a common pattern to create a :class:`TestCase` subclass with many similarly named test functions, :mod:`unittest` provides a :class:`TestLoader` class that can be used to automate the process of creating a test suite and populating it with individual tests. For example, ::"
msgstr ""

#: ../../library/unittest.rst:474
msgid "will create a test suite that will run ``WidgetTestCase.test_default_size()`` and ``WidgetTestCase.test_resize``. :class:`TestLoader` uses the ``'test'`` method name prefix to identify test methods automatically."
msgstr ""

#: ../../library/unittest.rst:478
msgid "Note that the order in which the various test cases will be run is determined by sorting the test function names with respect to the built-in ordering for strings."
msgstr ""

#: ../../library/unittest.rst:482
msgid "Often it is desirable to group suites of test cases together, so as to run tests for the whole system at once.  This is easy, since :class:`TestSuite` instances can be added to a :class:`TestSuite` just as :class:`TestCase` instances can be added to a :class:`TestSuite`::"
msgstr ""

#: ../../library/unittest.rst:491
msgid "You can place the definitions of test cases and test suites in the same modules as the code they are to test (such as :file:`widget.py`), but there are several advantages to placing the test code in a separate module, such as :file:`test_widget.py`:"
msgstr ""

#: ../../library/unittest.rst:496
msgid "The test module can be run standalone from the command line."
msgstr ""

#: ../../library/unittest.rst:498
msgid "The test code can more easily be separated from shipped code."
msgstr ""

#: ../../library/unittest.rst:500
msgid "There is less temptation to change test code to fit the code it tests without a good reason."
msgstr ""

#: ../../library/unittest.rst:503
msgid "Test code should be modified much less frequently than the code it tests."
msgstr ""

#: ../../library/unittest.rst:505
msgid "Tested code can be refactored more easily."
msgstr ""

#: ../../library/unittest.rst:507
msgid "Tests for modules written in C must be in separate modules anyway, so why not be consistent?"
msgstr ""

#: ../../library/unittest.rst:510
msgid "If the testing strategy changes, there is no need to change the source code."
msgstr ""

#: ../../library/unittest.rst:516
msgid "Re-using old test code"
msgstr ""

#: ../../library/unittest.rst:518
msgid "Some users will find that they have existing test code that they would like to run from :mod:`unittest`, without converting every old test function to a :class:`TestCase` subclass."
msgstr ""

#: ../../library/unittest.rst:522
msgid "For this reason, :mod:`unittest` provides a :class:`FunctionTestCase` class. This subclass of :class:`TestCase` can be used to wrap an existing test function.  Set-up and tear-down functions can also be provided."
msgstr ""

#: ../../library/unittest.rst:526
msgid "Given the following test function::"
msgstr ""

#: ../../library/unittest.rst:533
msgid "one can create an equivalent test case instance as follows::"
msgstr ""

#: ../../library/unittest.rst:537
msgid "If there are additional set-up and tear-down methods that should be called as part of the test case's operation, they can also be provided like so::"
msgstr ""

#: ../../library/unittest.rst:544
msgid "To make migrating existing test suites easier, :mod:`unittest` supports tests raising :exc:`AssertionError` to indicate test failure. However, it is recommended that you use the explicit :meth:`TestCase.fail\\*` and :meth:`TestCase.assert\\*` methods instead, as future versions of :mod:`unittest` may treat :exc:`AssertionError` differently."
msgstr ""

#: ../../library/unittest.rst:552
msgid "Even though :class:`FunctionTestCase` can be used to quickly convert an existing test base over to a :mod:`unittest`\\ -based system, this approach is not recommended.  Taking the time to set up proper :class:`TestCase` subclasses will make future test refactorings infinitely easier."
msgstr ""

#: ../../library/unittest.rst:557
msgid "In some cases, the existing tests may have been written using the :mod:`doctest` module.  If so, :mod:`doctest` provides a :class:`DocTestSuite` class that can automatically build :class:`unittest.TestSuite` instances from the existing :mod:`doctest`\\ -based tests."
msgstr ""

#: ../../library/unittest.rst:566
msgid "Skipping tests and expected failures"
msgstr ""

#: ../../library/unittest.rst:570
msgid "Unittest supports skipping individual test methods and even whole classes of tests.  In addition, it supports marking a test as an \"expected failure,\" a test that is broken and will fail, but shouldn't be counted as a failure on a :class:`TestResult`."
msgstr ""

#: ../../library/unittest.rst:575
msgid "Skipping a test is simply a matter of using the :func:`skip` :term:`decorator` or one of its conditional variants."
msgstr ""

#: ../../library/unittest.rst:578
msgid "Basic skipping looks like this::"
msgstr ""

#: ../../library/unittest.rst:597
msgid "This is the output of running the example above in verbose mode::"
msgstr ""

#: ../../library/unittest.rst:608
msgid "Classes can be skipped just like methods::"
msgstr ""

#: ../../library/unittest.rst:615
msgid ":meth:`TestCase.setUp` can also skip the test.  This is useful when a resource that needs to be set up is not available."
msgstr ""

#: ../../library/unittest.rst:618
msgid "Expected failures use the :func:`expectedFailure` decorator. ::"
msgstr ""

#: ../../library/unittest.rst:625
msgid "It's easy to roll your own skipping decorators by making a decorator that calls :func:`skip` on the test when it wants it to be skipped.  This decorator skips the test unless the passed object has a certain attribute::"
msgstr ""

#: ../../library/unittest.rst:634
msgid "The following decorators implement test skipping and expected failures:"
msgstr ""

#: ../../library/unittest.rst:638
msgid "Unconditionally skip the decorated test.  *reason* should describe why the test is being skipped."
msgstr ""

#: ../../library/unittest.rst:643
msgid "Skip the decorated test if *condition* is true."
msgstr ""

#: ../../library/unittest.rst:647
msgid "Skip the decorated test unless *condition* is true."
msgstr ""

#: ../../library/unittest.rst:651
msgid "Mark the test as an expected failure.  If the test fails when run, the test is not counted as a failure."
msgstr ""

#: ../../library/unittest.rst:656
msgid "This exception is raised to skip a test."
msgstr ""

#: ../../library/unittest.rst:658
msgid "Usually you can use :meth:`TestCase.skipTest` or one of the skipping decorators instead of raising this directly."
msgstr ""

#: ../../library/unittest.rst:661
msgid "Skipped tests will not have :meth:`setUp` or :meth:`tearDown` run around them. Skipped classes will not have :meth:`setUpClass` or :meth:`tearDownClass` run."
msgstr ""

#: ../../library/unittest.rst:668
msgid "Classes and functions"
msgstr ""

#: ../../library/unittest.rst:670
msgid "This section describes in depth the API of :mod:`unittest`."
msgstr ""

#: ../../library/unittest.rst:676
msgid "Test cases"
msgstr ""

#: ../../library/unittest.rst:680
msgid "Instances of the :class:`TestCase` class represent the smallest testable units in the :mod:`unittest` universe.  This class is intended to be used as a base class, with specific tests being implemented by concrete subclasses.  This class implements the interface needed by the test runner to allow it to drive the test, and methods that the test code can use to check for and report various kinds of failure."
msgstr ""

#: ../../library/unittest.rst:687
msgid "Each instance of :class:`TestCase` will run a single test method: the method named *methodName*.  If you remember, we had an earlier example that went something like this::"
msgstr ""

#: ../../library/unittest.rst:697
msgid "Here, we create two instances of :class:`WidgetTestCase`, each of which runs a single test."
msgstr ""

#: ../../library/unittest.rst:700
msgid "*methodName* defaults to :meth:`runTest`."
msgstr ""

#: ../../library/unittest.rst:702
msgid ":class:`TestCase` instances provide three groups of methods: one group used to run the test, another used by the test implementation to check conditions and report failures, and some inquiry methods allowing information about the test itself to be gathered."
msgstr ""

#: ../../library/unittest.rst:707
msgid "Methods in the first group (running the test) are:"
msgstr ""

#: ../../library/unittest.rst:712
msgid "Method called to prepare the test fixture.  This is called immediately before calling the test method; other than :exc:`AssertionError` or :exc:`SkipTest`, any exception raised by this method will be considered an error rather than a test failure. The default implementation does nothing."
msgstr ""

#: ../../library/unittest.rst:720
msgid "Method called immediately after the test method has been called and the result recorded.  This is called even if the test method raised an exception, so the implementation in subclasses may need to be particularly careful about checking internal state.  Any exception, other than :exc:`AssertionError` or :exc:`SkipTest`, raised by this method will be considered an error rather than a test failure.  This method will only be called if the :meth:`setUp` succeeds, regardless of the outcome of the test method. The default implementation does nothing."
msgstr ""

#: ../../library/unittest.rst:731
msgid "A class method called before tests in an individual class run. ``setUpClass`` is called with the class as the only argument and must be decorated as a :func:`classmethod`::"
msgstr ""

#: ../../library/unittest.rst:739
#: ../../library/unittest.rst:754
msgid "See `Class and Module Fixtures`_ for more details."
msgstr ""

#: ../../library/unittest.rst:746
msgid "A class method called after tests in an individual class have run. ``tearDownClass`` is called with the class as the only argument and must be decorated as a :meth:`classmethod`::"
msgstr ""

#: ../../library/unittest.rst:761
msgid "Run the test, collecting the result into the test result object passed as *result*.  If *result* is omitted or ``None``, a temporary result object is created (by calling the :meth:`defaultTestResult` method) and used. The result object is not returned to :meth:`run`'s caller."
msgstr ""

#: ../../library/unittest.rst:766
msgid "The same effect may be had by simply calling the :class:`TestCase` instance."
msgstr ""

#: ../../library/unittest.rst:772
msgid "Calling this during a test method or :meth:`setUp` skips the current test.  See :ref:`unittest-skipping` for more information."
msgstr ""

#: ../../library/unittest.rst:780
msgid "Run the test without collecting the result.  This allows exceptions raised by the test to be propagated to the caller, and can be used to support running tests under a debugger."
msgstr ""

#: ../../library/unittest.rst:786
msgid "The :class:`TestCase` class provides a number of methods to check for and report failures, such as:"
msgstr ""

#: ../../library/unittest.rst:790
#: ../../library/unittest.rst:905
#: ../../library/unittest.rst:967
#: ../../library/unittest.rst:1110
msgid "Method"
msgstr ""

#: ../../library/unittest.rst:790
#: ../../library/unittest.rst:905
#: ../../library/unittest.rst:967
msgid "Checks that"
msgstr ""

#: ../../library/unittest.rst:790
#: ../../library/unittest.rst:905
#: ../../library/unittest.rst:967
#: ../../library/unittest.rst:1110
msgid "New in"
msgstr ""

#: ../../library/unittest.rst:792
msgid ":meth:`assertEqual(a, b) <TestCase.assertEqual>`"
msgstr ""

#: ../../library/unittest.rst:792
msgid "``a == b``"
msgstr ""

#: ../../library/unittest.rst:795
msgid ":meth:`assertNotEqual(a, b) <TestCase.assertNotEqual>`"
msgstr ""

#: ../../library/unittest.rst:795
msgid "``a != b``"
msgstr ""

#: ../../library/unittest.rst:798
msgid ":meth:`assertTrue(x) <TestCase.assertTrue>`"
msgstr ""

#: ../../library/unittest.rst:798
msgid "``bool(x) is True``"
msgstr ""

#: ../../library/unittest.rst:801
msgid ":meth:`assertFalse(x) <TestCase.assertFalse>`"
msgstr ""

#: ../../library/unittest.rst:801
msgid "``bool(x) is False``"
msgstr ""

#: ../../library/unittest.rst:804
msgid ":meth:`assertIs(a, b) <TestCase.assertIs>`"
msgstr ""

#: ../../library/unittest.rst:804
msgid "``a is b``"
msgstr ""

#: ../../library/unittest.rst:804
#: ../../library/unittest.rst:807
#: ../../library/unittest.rst:810
#: ../../library/unittest.rst:813
#: ../../library/unittest.rst:816
#: ../../library/unittest.rst:819
#: ../../library/unittest.rst:822
#: ../../library/unittest.rst:825
#: ../../library/unittest.rst:910
#: ../../library/unittest.rst:975
#: ../../library/unittest.rst:978
#: ../../library/unittest.rst:981
#: ../../library/unittest.rst:984
#: ../../library/unittest.rst:987
#: ../../library/unittest.rst:990
#: ../../library/unittest.rst:993
#: ../../library/unittest.rst:996
#: ../../library/unittest.rst:1112
#: ../../library/unittest.rst:1115
#: ../../library/unittest.rst:1118
#: ../../library/unittest.rst:1121
#: ../../library/unittest.rst:1124
#: ../../library/unittest.rst:1127
msgid "2.7"
msgstr ""

#: ../../library/unittest.rst:807
msgid ":meth:`assertIsNot(a, b) <TestCase.assertIsNot>`"
msgstr ""

#: ../../library/unittest.rst:807
msgid "``a is not b``"
msgstr ""

#: ../../library/unittest.rst:810
msgid ":meth:`assertIsNone(x) <TestCase.assertIsNone>`"
msgstr ""

#: ../../library/unittest.rst:810
msgid "``x is None``"
msgstr ""

#: ../../library/unittest.rst:813
msgid ":meth:`assertIsNotNone(x) <TestCase.assertIsNotNone>`"
msgstr ""

#: ../../library/unittest.rst:813
msgid "``x is not None``"
msgstr ""

#: ../../library/unittest.rst:816
msgid ":meth:`assertIn(a, b) <TestCase.assertIn>`"
msgstr ""

#: ../../library/unittest.rst:816
msgid "``a in b``"
msgstr ""

#: ../../library/unittest.rst:819
msgid ":meth:`assertNotIn(a, b) <TestCase.assertNotIn>`"
msgstr ""

#: ../../library/unittest.rst:819
msgid "``a not in b``"
msgstr ""

#: ../../library/unittest.rst:822
msgid ":meth:`assertIsInstance(a, b) <TestCase.assertIsInstance>`"
msgstr ""

#: ../../library/unittest.rst:822
msgid "``isinstance(a, b)``"
msgstr ""

#: ../../library/unittest.rst:825
msgid ":meth:`assertNotIsInstance(a, b) <TestCase.assertNotIsInstance>`"
msgstr ""

#: ../../library/unittest.rst:825
msgid "``not isinstance(a, b)``"
msgstr ""

#: ../../library/unittest.rst:829
msgid "All the assert methods (except :meth:`assertRaises`, :meth:`assertRaisesRegexp`) accept a *msg* argument that, if specified, is used as the error message on failure (see also :data:`longMessage`)."
msgstr ""

#: ../../library/unittest.rst:836
msgid "Test that *first* and *second* are equal.  If the values do not compare equal, the test will fail."
msgstr ""

#: ../../library/unittest.rst:839
msgid "In addition, if *first* and *second* are the exact same type and one of list, tuple, dict, set, frozenset or unicode or any type that a subclass registers with :meth:`addTypeEqualityFunc` the type-specific equality function will be called in order to generate a more useful default error message (see also the :ref:`list of type-specific methods <type-specific-methods>`)."
msgstr ""

#: ../../library/unittest.rst:846
msgid "Added the automatic calling of type-specific equality function."
msgstr ""

#: ../../library/unittest.rst:852
msgid "Test that *first* and *second* are not equal.  If the values do compare equal, the test will fail."
msgstr ""

#: ../../library/unittest.rst:858
msgid "Test that *expr* is true (or false)."
msgstr ""

#: ../../library/unittest.rst:860
msgid "Note that this is equivalent to ``bool(expr) is True`` and not to ``expr is True`` (use ``assertIs(expr, True)`` for the latter).  This method should also be avoided when more specific methods are available (e.g. ``assertEqual(a, b)`` instead of ``assertTrue(a == b)``), because they provide a better error message in case of failure."
msgstr ""

#: ../../library/unittest.rst:870
msgid "Test that *first* and *second* evaluate (or don't evaluate) to the same object."
msgstr ""

#: ../../library/unittest.rst:878
msgid "Test that *expr* is (or is not) None."
msgstr ""

#: ../../library/unittest.rst:886
msgid "Test that *first* is (or is not) in *second*."
msgstr ""

#: ../../library/unittest.rst:894
msgid "Test that *obj* is (or is not) an instance of *cls* (which can be a class or a tuple of classes, as supported by :func:`isinstance`). To check for the exact type, use :func:`assertIs(type(obj), cls) <assertIs>`."
msgstr ""

#: ../../library/unittest.rst:901
msgid "It is also possible to check that exceptions and warnings are raised using the following methods:"
msgstr ""

#: ../../library/unittest.rst:907
msgid ":meth:`assertRaises(exc, fun, *args, **kwds) <TestCase.assertRaises>`"
msgstr ""

#: ../../library/unittest.rst:907
msgid "``fun(*args, **kwds)`` raises *exc*"
msgstr ""

#: ../../library/unittest.rst:910
msgid ":meth:`assertRaisesRegexp(exc, r, fun, *args, **kwds) <TestCase.assertRaisesRegexp>`"
msgstr ""

#: ../../library/unittest.rst:910
msgid "``fun(*args, **kwds)`` raises *exc* and the message matches regex *r*"
msgstr ""

#: ../../library/unittest.rst:917
msgid "Test that an exception is raised when *callable* is called with any positional or keyword arguments that are also passed to :meth:`assertRaises`.  The test passes if *exception* is raised, is an error if another exception is raised, or fails if no exception is raised. To catch any of a group of exceptions, a tuple containing the exception classes may be passed as *exception*."
msgstr ""

#: ../../library/unittest.rst:924
msgid "If only the *exception* argument is given, returns a context manager so that the code under test can be written inline rather than as a function::"
msgstr ""

#: ../../library/unittest.rst:930
msgid "The context manager will store the caught exception object in its :attr:`exception` attribute.  This can be useful if the intention is to perform additional checks on the exception raised::"
msgstr ""

#: ../../library/unittest.rst:940
msgid "Added the ability to use :meth:`assertRaises` as a context manager."
msgstr ""

#: ../../library/unittest.rst:947
msgid "Like :meth:`assertRaises` but also tests that *regexp* matches on the string representation of the raised exception.  *regexp* may be a regular expression object or a string containing a regular expression suitable for use by :func:`re.search`.  Examples::"
msgstr ""

#: ../../library/unittest.rst:955
msgid "or::"
msgstr ""

#: ../../library/unittest.rst:964
msgid "There are also other methods used to perform more specific checks, such as:"
msgstr ""

#: ../../library/unittest.rst:969
msgid ":meth:`assertAlmostEqual(a, b) <TestCase.assertAlmostEqual>`"
msgstr ""

#: ../../library/unittest.rst:969
msgid "``round(a-b, 7) == 0``"
msgstr ""

#: ../../library/unittest.rst:972
msgid ":meth:`assertNotAlmostEqual(a, b) <TestCase.assertNotAlmostEqual>`"
msgstr ""

#: ../../library/unittest.rst:972
msgid "``round(a-b, 7) != 0``"
msgstr ""

#: ../../library/unittest.rst:975
msgid ":meth:`assertGreater(a, b) <TestCase.assertGreater>`"
msgstr ""

#: ../../library/unittest.rst:975
msgid "``a > b``"
msgstr ""

#: ../../library/unittest.rst:978
msgid ":meth:`assertGreaterEqual(a, b) <TestCase.assertGreaterEqual>`"
msgstr ""

#: ../../library/unittest.rst:978
msgid "``a >= b``"
msgstr ""

#: ../../library/unittest.rst:981
msgid ":meth:`assertLess(a, b) <TestCase.assertLess>`"
msgstr ""

#: ../../library/unittest.rst:981
msgid "``a < b``"
msgstr ""

#: ../../library/unittest.rst:984
msgid ":meth:`assertLessEqual(a, b) <TestCase.assertLessEqual>`"
msgstr ""

#: ../../library/unittest.rst:984
msgid "``a <= b``"
msgstr ""

#: ../../library/unittest.rst:987
msgid ":meth:`assertRegexpMatches(s, r) <TestCase.assertRegexpMatches>`"
msgstr ""

#: ../../library/unittest.rst:987
msgid "``r.search(s)``"
msgstr ""

#: ../../library/unittest.rst:990
msgid ":meth:`assertNotRegexpMatches(s, r) <TestCase.assertNotRegexpMatches>`"
msgstr ""

#: ../../library/unittest.rst:990
msgid "``not r.search(s)``"
msgstr ""

#: ../../library/unittest.rst:993
msgid ":meth:`assertItemsEqual(a, b) <TestCase.assertItemsEqual>`"
msgstr ""

#: ../../library/unittest.rst:993
msgid "sorted(a) == sorted(b) and works with unhashable objs"
msgstr ""

#: ../../library/unittest.rst:996
msgid ":meth:`assertDictContainsSubset(a, b) <TestCase.assertDictContainsSubset>`"
msgstr ""

#: ../../library/unittest.rst:996
msgid "all the key/value pairs in *a* exist in *b*"
msgstr ""

#: ../../library/unittest.rst:1004
msgid "Test that *first* and *second* are approximately (or not approximately) equal by computing the difference, rounding to the given number of decimal *places* (default 7), and comparing to zero.  Note that these methods round the values to the given number of *decimal places* (i.e. like the :func:`round` function) and not *significant digits*."
msgstr ""

#: ../../library/unittest.rst:1010
msgid "If *delta* is supplied instead of *places* then the difference between *first* and *second* must be less or equal to (or greater than) *delta*."
msgstr ""

#: ../../library/unittest.rst:1013
msgid "Supplying both *delta* and *places* raises a ``TypeError``."
msgstr ""

#: ../../library/unittest.rst:1015
msgid ":meth:`assertAlmostEqual` automatically considers almost equal objects that compare equal.  :meth:`assertNotAlmostEqual` automatically fails if the objects compare equal.  Added the *delta* keyword argument."
msgstr ""

#: ../../library/unittest.rst:1027
msgid "Test that *first* is respectively >, >=, < or <= than *second* depending on the method name.  If not, the test will fail::"
msgstr ""

#: ../../library/unittest.rst:1038
msgid "Test that a *regexp* search matches *text*.  In case of failure, the error message will include the pattern and the *text* (or the pattern and the part of *text* that unexpectedly matched).  *regexp* may be a regular expression object or a string containing a regular expression suitable for use by :func:`re.search`."
msgstr ""

#: ../../library/unittest.rst:1049
msgid "Verifies that a *regexp* search does not match *text*.  Fails with an error message including the pattern and the part of *text* that matches.  *regexp* may be a regular expression object or a string containing a regular expression suitable for use by :func:`re.search`."
msgstr ""

#: ../../library/unittest.rst:1059
msgid "Test that sequence *expected* contains the same elements as *actual*, regardless of their order. When they don't, an error message listing the differences between the sequences will be generated."
msgstr ""

#: ../../library/unittest.rst:1063
msgid "Duplicate elements are *not* ignored when comparing *actual* and *expected*. It verifies if each element has the same count in both sequences. It is the equivalent of ``assertEqual(sorted(expected), sorted(actual))`` but it works with sequences of unhashable objects as well."
msgstr ""

#: ../../library/unittest.rst:1069
msgid "In Python 3, this method is named ``assertCountEqual``."
msgstr ""

#: ../../library/unittest.rst:1076
msgid "Tests whether the key/value pairs in dictionary *actual* are a superset of those in *expected*.  If not, an error message listing the missing keys and mismatched values is generated."
msgstr ""

#: ../../library/unittest.rst:1087
msgid "The :meth:`assertEqual` method dispatches the equality check for objects of the same type to different type-specific methods.  These methods are already implemented for most of the built-in types, but it's also possible to register new methods using :meth:`addTypeEqualityFunc`:"
msgstr ""

#: ../../library/unittest.rst:1094
msgid "Registers a type-specific method called by :meth:`assertEqual` to check if two objects of exactly the same *typeobj* (not subclasses) compare equal.  *function* must take two positional arguments and a third msg=None keyword argument just as :meth:`assertEqual` does.  It must raise :data:`self.failureException(msg) <failureException>` when inequality between the first two parameters is detected -- possibly providing useful information and explaining the inequalities in details in the error message."
msgstr ""

#: ../../library/unittest.rst:1105
msgid "The list of type-specific methods automatically used by :meth:`~TestCase.assertEqual` are summarized in the following table.  Note that it's usually not necessary to invoke these methods directly."
msgstr ""

#: ../../library/unittest.rst:1110
msgid "Used to compare"
msgstr ""

#: ../../library/unittest.rst:1112
msgid ":meth:`assertMultiLineEqual(a, b) <TestCase.assertMultiLineEqual>`"
msgstr ""

#: ../../library/unittest.rst:1112
msgid "strings"
msgstr ""

#: ../../library/unittest.rst:1115
msgid ":meth:`assertSequenceEqual(a, b) <TestCase.assertSequenceEqual>`"
msgstr ""

#: ../../library/unittest.rst:1115
msgid "sequences"
msgstr ""

#: ../../library/unittest.rst:1118
msgid ":meth:`assertListEqual(a, b) <TestCase.assertListEqual>`"
msgstr ""

#: ../../library/unittest.rst:1118
msgid "lists"
msgstr ""

#: ../../library/unittest.rst:1121
msgid ":meth:`assertTupleEqual(a, b) <TestCase.assertTupleEqual>`"
msgstr ""

#: ../../library/unittest.rst:1121
msgid "tuples"
msgstr ""

#: ../../library/unittest.rst:1124
msgid ":meth:`assertSetEqual(a, b) <TestCase.assertSetEqual>`"
msgstr ""

#: ../../library/unittest.rst:1124
msgid "sets or frozensets"
msgstr ""

#: ../../library/unittest.rst:1127
msgid ":meth:`assertDictEqual(a, b) <TestCase.assertDictEqual>`"
msgstr ""

#: ../../library/unittest.rst:1127
msgid "dicts"
msgstr ""

#: ../../library/unittest.rst:1135
msgid "Test that the multiline string *first* is equal to the string *second*. When not equal a diff of the two strings highlighting the differences will be included in the error message. This method is used by default when comparing strings with :meth:`assertEqual`."
msgstr ""

#: ../../library/unittest.rst:1145
msgid "Tests that two sequences are equal.  If a *seq_type* is supplied, both *seq1* and *seq2* must be instances of *seq_type* or a failure will be raised.  If the sequences are different an error message is constructed that shows the difference between the two."
msgstr ""

#: ../../library/unittest.rst:1150
msgid "This method is not called directly by :meth:`assertEqual`, but it's used to implement :meth:`assertListEqual` and :meth:`assertTupleEqual`."
msgstr ""

#: ../../library/unittest.rst:1160
msgid "Tests that two lists or tuples are equal.  If not, an error message is constructed that shows only the differences between the two.  An error is also raised if either of the parameters are of the wrong type. These methods are used by default when comparing lists or tuples with :meth:`assertEqual`."
msgstr ""

#: ../../library/unittest.rst:1171
msgid "Tests that two sets are equal.  If not, an error message is constructed that lists the differences between the sets.  This method is used by default when comparing sets or frozensets with :meth:`assertEqual`."
msgstr ""

#: ../../library/unittest.rst:1175
msgid "Fails if either of *set1* or *set2* does not have a :meth:`set.difference` method."
msgstr ""

#: ../../library/unittest.rst:1183
msgid "Test that two dictionaries are equal.  If not, an error message is constructed that shows the differences in the dictionaries. This method will be used by default to compare dictionaries in calls to :meth:`assertEqual`."
msgstr ""

#: ../../library/unittest.rst:1194
msgid "Finally the :class:`TestCase` provides the following methods and attributes:"
msgstr ""

#: ../../library/unittest.rst:1199
msgid "Signals a test failure unconditionally, with *msg* or ``None`` for the error message."
msgstr ""

#: ../../library/unittest.rst:1205
msgid "This class attribute gives the exception raised by the test method.  If a test framework needs to use a specialized exception, possibly to carry additional information, it must subclass this exception in order to \"play fair\" with the framework.  The initial value of this attribute is :exc:`AssertionError`."
msgstr ""

#: ../../library/unittest.rst:1214
msgid "If set to ``True`` then any explicit failure message you pass in to the :ref:`assert methods <assert-methods>` will be appended to the end of the normal failure message.  The normal messages contain useful information about the objects involved, for example the message from assertEqual shows you the repr of the two unequal objects. Setting this attribute to ``True`` allows you to have a custom error message in addition to the normal one."
msgstr ""

#: ../../library/unittest.rst:1222
msgid "This attribute defaults to ``False``, meaning that a custom message passed to an assert method will silence the normal message."
msgstr ""

#: ../../library/unittest.rst:1225
msgid "The class setting can be overridden in individual tests by assigning an instance attribute to ``True`` or ``False`` before calling the assert methods."
msgstr ""

#: ../../library/unittest.rst:1233
msgid "This attribute controls the maximum length of diffs output by assert methods that report diffs on failure. It defaults to 80*8 characters. Assert methods affected by this attribute are :meth:`assertSequenceEqual` (including all the sequence comparison methods that delegate to it), :meth:`assertDictEqual` and :meth:`assertMultiLineEqual`."
msgstr ""

#: ../../library/unittest.rst:1240
msgid "Setting ``maxDiff`` to None means that there is no maximum length of diffs."
msgstr ""

#: ../../library/unittest.rst:1246
msgid "Testing frameworks can use the following methods to collect information on the test:"
msgstr ""

#: ../../library/unittest.rst:1252
msgid "Return the number of tests represented by this test object.  For :class:`TestCase` instances, this will always be ``1``."
msgstr ""

#: ../../library/unittest.rst:1258
msgid "Return an instance of the test result class that should be used for this test case class (if no other result instance is provided to the :meth:`run` method)."
msgstr ""

#: ../../library/unittest.rst:1262
msgid "For :class:`TestCase` instances, this will always be an instance of :class:`TestResult`; subclasses of :class:`TestCase` should override this as necessary."
msgstr ""

#: ../../library/unittest.rst:1269
msgid "Return a string identifying the specific test case.  This is usually the full name of the test method, including the module and class name."
msgstr ""

#: ../../library/unittest.rst:1275
msgid "Returns a description of the test, or ``None`` if no description has been provided.  The default implementation of this method returns the first line of the test method's docstring, if available, or :const:`None`."
msgstr ""

#: ../../library/unittest.rst:1284
msgid "Add a function to be called after :meth:`tearDown` to cleanup resources used during the test. Functions will be called in reverse order to the order they are added (LIFO). They are called with any arguments and keyword arguments passed into :meth:`addCleanup` when they are added."
msgstr ""

#: ../../library/unittest.rst:1290
msgid "If :meth:`setUp` fails, meaning that :meth:`tearDown` is not called, then any cleanup functions added will still be called."
msgstr ""

#: ../../library/unittest.rst:1298
msgid "This method is called unconditionally after :meth:`tearDown`, or after :meth:`setUp` if :meth:`setUp` raises an exception."
msgstr ""

#: ../../library/unittest.rst:1301
msgid "It is responsible for calling all the cleanup functions added by :meth:`addCleanup`. If you need cleanup functions to be called *prior* to :meth:`tearDown` then you can call :meth:`doCleanups` yourself."
msgstr ""

#: ../../library/unittest.rst:1306
msgid ":meth:`doCleanups` pops methods off the stack of cleanup functions one at a time, so it can be called at any time."
msgstr ""

#: ../../library/unittest.rst:1314
msgid "This class implements the portion of the :class:`TestCase` interface which allows the test runner to drive the test, but does not provide the methods which test code can use to check and report errors.  This is used to create test cases using legacy test code, allowing it to be integrated into a :mod:`unittest`-based test framework."
msgstr ""

#: ../../library/unittest.rst:1322
msgid "Deprecated aliases"
msgstr ""

#: ../../library/unittest.rst:1324
msgid "For historical reasons, some of the :class:`TestCase` methods had one or more aliases that are now deprecated.  The following table lists the correct names along with their deprecated aliases:"
msgstr ""

#: ../../library/unittest.rst:1329
msgid "Method Name"
msgstr ""

#: ../../library/unittest.rst:1329
msgid "Deprecated alias(es)"
msgstr ""

#: ../../library/unittest.rst:1331
msgid ":meth:`.assertEqual`"
msgstr ""

#: ../../library/unittest.rst:1331
msgid "failUnlessEqual, assertEquals"
msgstr ""

#: ../../library/unittest.rst:1332
msgid ":meth:`.assertNotEqual`"
msgstr ""

#: ../../library/unittest.rst:1332
msgid "failIfEqual"
msgstr ""

#: ../../library/unittest.rst:1333
msgid ":meth:`.assertTrue`"
msgstr ""

#: ../../library/unittest.rst:1333
msgid "failUnless, assert\\_"
msgstr ""

#: ../../library/unittest.rst:1334
msgid ":meth:`.assertFalse`"
msgstr ""

#: ../../library/unittest.rst:1334
msgid "failIf"
msgstr ""

#: ../../library/unittest.rst:1335
msgid ":meth:`.assertRaises`"
msgstr ""

#: ../../library/unittest.rst:1335
msgid "failUnlessRaises"
msgstr ""

#: ../../library/unittest.rst:1336
msgid ":meth:`.assertAlmostEqual`"
msgstr ""

#: ../../library/unittest.rst:1336
msgid "failUnlessAlmostEqual"
msgstr ""

#: ../../library/unittest.rst:1337
msgid ":meth:`.assertNotAlmostEqual`"
msgstr ""

#: ../../library/unittest.rst:1337
msgid "failIfAlmostEqual"
msgstr ""

#: ../../library/unittest.rst:1340
msgid "the aliases listed in the second column"
msgstr ""

#: ../../library/unittest.rst:1348
msgid "Grouping tests"
msgstr ""

#: ../../library/unittest.rst:1352
msgid "This class represents an aggregation of individual tests cases and test suites. The class presents the interface needed by the test runner to allow it to be run as any other test case.  Running a :class:`TestSuite` instance is the same as iterating over the suite, running each test individually."
msgstr ""

#: ../../library/unittest.rst:1357
msgid "If *tests* is given, it must be an iterable of individual test cases or other test suites that will be used to build the suite initially. Additional methods are provided to add test cases and suites to the collection later on."
msgstr ""

#: ../../library/unittest.rst:1361
msgid ":class:`TestSuite` objects behave much like :class:`TestCase` objects, except they do not actually implement a test.  Instead, they are used to aggregate tests into groups of tests that should be run together. Some additional methods are available to add tests to :class:`TestSuite` instances:"
msgstr ""

#: ../../library/unittest.rst:1369
msgid "Add a :class:`TestCase` or :class:`TestSuite` to the suite."
msgstr ""

#: ../../library/unittest.rst:1374
msgid "Add all the tests from an iterable of :class:`TestCase` and :class:`TestSuite` instances to this test suite."
msgstr ""

#: ../../library/unittest.rst:1377
msgid "This is equivalent to iterating over *tests*, calling :meth:`addTest` for each element."
msgstr ""

#: ../../library/unittest.rst:1380
msgid ":class:`TestSuite` shares the following methods with :class:`TestCase`:"
msgstr ""

#: ../../library/unittest.rst:1385
msgid "Run the tests associated with this suite, collecting the result into the test result object passed as *result*.  Note that unlike :meth:`TestCase.run`, :meth:`TestSuite.run` requires the result object to be passed in."
msgstr ""

#: ../../library/unittest.rst:1393
msgid "Run the tests associated with this suite without collecting the result. This allows exceptions raised by the test to be propagated to the caller and can be used to support running tests under a debugger."
msgstr ""

#: ../../library/unittest.rst:1400
msgid "Return the number of tests represented by this test object, including all individual tests and sub-suites."
msgstr ""

#: ../../library/unittest.rst:1406
msgid "Tests grouped by a :class:`TestSuite` are always accessed by iteration. Subclasses can lazily provide tests by overriding :meth:`__iter__`. Note that this method maybe called several times on a single suite (for example when counting tests or comparing for equality) so the tests returned must be the same for repeated iterations."
msgstr ""

#: ../../library/unittest.rst:1412
msgid "In earlier versions the :class:`TestSuite` accessed tests directly rather than through iteration, so overriding :meth:`__iter__` wasn't sufficient for providing tests."
msgstr ""

#: ../../library/unittest.rst:1417
msgid "In the typical usage of a :class:`TestSuite` object, the :meth:`run` method is invoked by a :class:`TestRunner` rather than by the end-user test harness."
msgstr ""

#: ../../library/unittest.rst:1422
msgid "Loading and running tests"
msgstr ""

#: ../../library/unittest.rst:1426
msgid "The :class:`TestLoader` class is used to create test suites from classes and modules.  Normally, there is no need to create an instance of this class; the :mod:`unittest` module provides an instance that can be shared as :data:`unittest.defaultTestLoader`.  Using a subclass or instance, however, allows customization of some configurable properties."
msgstr ""

#: ../../library/unittest.rst:1432
msgid ":class:`TestLoader` objects have the following methods:"
msgstr ""

#: ../../library/unittest.rst:1437
msgid "Return a suite of all tests cases contained in the :class:`TestCase`\\ -derived :class:`testCaseClass`."
msgstr ""

#: ../../library/unittest.rst:1443
msgid "Return a suite of all tests cases contained in the given module. This method searches *module* for classes derived from :class:`TestCase` and creates an instance of the class for each test method defined for the class."
msgstr ""

#: ../../library/unittest.rst:1450
msgid "While using a hierarchy of :class:`TestCase`\\ -derived classes can be convenient in sharing fixtures and helper functions, defining test methods on base classes that are not intended to be instantiated directly does not play well with this method.  Doing so, however, can be useful when the fixtures are different and defined in subclasses."
msgstr ""

#: ../../library/unittest.rst:1456
msgid "If a module provides a ``load_tests`` function it will be called to load the tests. This allows modules to customize test loading. This is the `load_tests protocol`_."
msgstr ""

#: ../../library/unittest.rst:1460
msgid "Support for ``load_tests`` added."
msgstr ""

#: ../../library/unittest.rst:1466
msgid "Return a suite of all tests cases given a string specifier."
msgstr ""

#: ../../library/unittest.rst:1468
msgid "The specifier *name* is a \"dotted name\" that may resolve either to a module, a test case class, a test method within a test case class, a :class:`TestSuite` instance, or a callable object which returns a :class:`TestCase` or :class:`TestSuite` instance.  These checks are applied in the order listed here; that is, a method on a possible test case class will be picked up as \"a test method within a test case class\", rather than \"a callable object\"."
msgstr ""

#: ../../library/unittest.rst:1476
msgid "For example, if you have a module :mod:`SampleTests` containing a :class:`TestCase`\\ -derived class :class:`SampleTestCase` with three test methods (:meth:`test_one`, :meth:`test_two`, and :meth:`test_three`), the specifier ``'SampleTests.SampleTestCase'`` would cause this method to return a suite which will run all three test methods. Using the specifier ``'SampleTests.SampleTestCase.test_two'`` would cause it to return a test suite which will run only the :meth:`test_two` test method. The specifier can refer to modules and packages which have not been imported; they will be imported as a side-effect."
msgstr ""

#: ../../library/unittest.rst:1486
msgid "The method optionally resolves *name* relative to the given *module*."
msgstr ""

#: ../../library/unittest.rst:1491
msgid "Similar to :meth:`loadTestsFromName`, but takes a sequence of names rather than a single name.  The return value is a test suite which supports all the tests defined for each name."
msgstr ""

#: ../../library/unittest.rst:1498
msgid "Return a sorted sequence of method names found within *testCaseClass*; this should be a subclass of :class:`TestCase`."
msgstr ""

#: ../../library/unittest.rst:1504
msgid "Find all the test modules by recursing into subdirectories from the specified start directory, and return a TestSuite object containing them. Only test files that match *pattern* will be loaded. (Using shell style pattern matching.) Only module names that are importable (i.e. are valid Python identifiers) will be loaded."
msgstr ""

#: ../../library/unittest.rst:1510
msgid "All test modules must be importable from the top level of the project. If the start directory is not the top level directory then the top level directory must be specified separately."
msgstr ""

#: ../../library/unittest.rst:1514
msgid "If importing a module fails, for example due to a syntax error, then this will be recorded as a single error and discovery will continue."
msgstr ""

#: ../../library/unittest.rst:1517
msgid "If a test package name (directory with :file:`__init__.py`) matches the pattern then the package will be checked for a ``load_tests`` function. If this exists then it will be called with *loader*, *tests*, *pattern*."
msgstr ""

#: ../../library/unittest.rst:1522
msgid "If load_tests exists then discovery does *not* recurse into the package, ``load_tests`` is responsible for loading all tests in the package."
msgstr ""

#: ../../library/unittest.rst:1525
msgid "The pattern is deliberately not stored as a loader attribute so that packages can continue discovery themselves. *top_level_dir* is stored so ``load_tests`` does not need to pass this argument in to ``loader.discover()``."
msgstr ""

#: ../../library/unittest.rst:1530
msgid "*start_dir* can be a dotted module name as well as a directory."
msgstr ""

#: ../../library/unittest.rst:1534
msgid "The following attributes of a :class:`TestLoader` can be configured either by subclassing or assignment on an instance:"
msgstr ""

#: ../../library/unittest.rst:1540
msgid "String giving the prefix of method names which will be interpreted as test methods.  The default value is ``'test'``."
msgstr ""

#: ../../library/unittest.rst:1543
msgid "This affects :meth:`getTestCaseNames` and all the :meth:`loadTestsFrom\\*` methods."
msgstr ""

#: ../../library/unittest.rst:1549
msgid "Function to be used to compare method names when sorting them in :meth:`getTestCaseNames` and all the :meth:`loadTestsFrom\\*` methods. The default value is the built-in :func:`cmp` function; the attribute can also be set to :const:`None` to disable the sort."
msgstr ""

#: ../../library/unittest.rst:1557
msgid "Callable object that constructs a test suite from a list of tests. No methods on the resulting object are needed.  The default value is the :class:`TestSuite` class."
msgstr ""

#: ../../library/unittest.rst:1561
msgid "This affects all the :meth:`loadTestsFrom\\*` methods."
msgstr ""

#: ../../library/unittest.rst:1566
msgid "This class is used to compile information about which tests have succeeded and which have failed."
msgstr ""

#: ../../library/unittest.rst:1569
msgid "A :class:`TestResult` object stores the results of a set of tests.  The :class:`TestCase` and :class:`TestSuite` classes ensure that results are properly recorded; test authors do not need to worry about recording the outcome of tests."
msgstr ""

#: ../../library/unittest.rst:1574
msgid "Testing frameworks built on top of :mod:`unittest` may want access to the :class:`TestResult` object generated by running a set of tests for reporting purposes; a :class:`TestResult` instance is returned by the :meth:`TestRunner.run` method for this purpose."
msgstr ""

#: ../../library/unittest.rst:1579
msgid ":class:`TestResult` instances have the following attributes that will be of interest when inspecting the results of running a set of tests:"
msgstr ""

#: ../../library/unittest.rst:1585
msgid "A list containing 2-tuples of :class:`TestCase` instances and strings holding formatted tracebacks. Each tuple represents a test which raised an unexpected exception."
msgstr ""

#: ../../library/unittest.rst:1589
#: ../../library/unittest.rst:1599
msgid "Contains formatted tracebacks instead of :func:`sys.exc_info` results."
msgstr ""

#: ../../library/unittest.rst:1595
msgid "A list containing 2-tuples of :class:`TestCase` instances and strings holding formatted tracebacks. Each tuple represents a test where a failure was explicitly signalled using the :meth:`TestCase.assert\\*` methods."
msgstr ""

#: ../../library/unittest.rst:1604
msgid "A list containing 2-tuples of :class:`TestCase` instances and strings holding the reason for skipping the test."
msgstr ""

#: ../../library/unittest.rst:1611
msgid "A list containing 2-tuples of :class:`TestCase` instances and strings holding formatted tracebacks.  Each tuple represents an expected failure of the test case."
msgstr ""

#: ../../library/unittest.rst:1617
msgid "A list containing :class:`TestCase` instances that were marked as expected failures, but succeeded."
msgstr ""

#: ../../library/unittest.rst:1622
msgid "Set to ``True`` when the execution of tests should stop by :meth:`stop`."
msgstr ""

#: ../../library/unittest.rst:1627
msgid "The total number of tests run so far."
msgstr ""

#: ../../library/unittest.rst:1632
msgid "If set to true, ``sys.stdout`` and ``sys.stderr`` will be buffered in between :meth:`startTest` and :meth:`stopTest` being called. Collected output will only be echoed onto the real ``sys.stdout`` and ``sys.stderr`` if the test fails or errors. Any output is also attached to the failure / error message."
msgstr ""

#: ../../library/unittest.rst:1642
msgid "If set to true :meth:`stop` will be called on the first failure or error, halting the test run."
msgstr ""

#: ../../library/unittest.rst:1650
msgid "Return ``True`` if all tests run so far have passed, otherwise returns ``False``."
msgstr ""

#: ../../library/unittest.rst:1656
msgid "This method can be called to signal that the set of tests being run should be aborted by setting the :attr:`shouldStop` attribute to ``True``. :class:`TestRunner` objects should respect this flag and return without running any additional tests."
msgstr ""

#: ../../library/unittest.rst:1661
msgid "For example, this feature is used by the :class:`TextTestRunner` class to stop the test framework when the user signals an interrupt from the keyboard.  Interactive tools which provide :class:`TestRunner` implementations can use this in a similar manner."
msgstr ""

#: ../../library/unittest.rst:1666
msgid "The following methods of the :class:`TestResult` class are used to maintain the internal data structures, and may be extended in subclasses to support additional reporting requirements.  This is particularly useful in building tools which support interactive reporting while tests are being run."
msgstr ""

#: ../../library/unittest.rst:1674
msgid "Called when the test case *test* is about to be run."
msgstr ""

#: ../../library/unittest.rst:1678
msgid "Called after the test case *test* has been executed, regardless of the outcome."
msgstr ""

#: ../../library/unittest.rst:1683
msgid "Called once before any tests are executed."
msgstr ""

#: ../../library/unittest.rst:1690
msgid "Called once after all tests are executed."
msgstr ""

#: ../../library/unittest.rst:1697
msgid "Called when the test case *test* raises an unexpected exception. *err* is a tuple of the form returned by :func:`sys.exc_info`: ``(type, value, traceback)``."
msgstr ""

#: ../../library/unittest.rst:1701
msgid "The default implementation appends a tuple ``(test, formatted_err)`` to the instance's :attr:`errors` attribute, where *formatted_err* is a formatted traceback derived from *err*."
msgstr ""

#: ../../library/unittest.rst:1708
msgid "Called when the test case *test* signals a failure. *err* is a tuple of the form returned by :func:`sys.exc_info`: ``(type, value, traceback)``."
msgstr ""

#: ../../library/unittest.rst:1711
msgid "The default implementation appends a tuple ``(test, formatted_err)`` to the instance's :attr:`failures` attribute, where *formatted_err* is a formatted traceback derived from *err*."
msgstr ""

#: ../../library/unittest.rst:1718
msgid "Called when the test case *test* succeeds."
msgstr ""

#: ../../library/unittest.rst:1720
msgid "The default implementation does nothing."
msgstr ""

#: ../../library/unittest.rst:1725
msgid "Called when the test case *test* is skipped.  *reason* is the reason the test gave for skipping."
msgstr ""

#: ../../library/unittest.rst:1728
msgid "The default implementation appends a tuple ``(test, reason)`` to the instance's :attr:`skipped` attribute."
msgstr ""

#: ../../library/unittest.rst:1734
msgid "Called when the test case *test* fails, but was marked with the :func:`expectedFailure` decorator."
msgstr ""

#: ../../library/unittest.rst:1737
msgid "The default implementation appends a tuple ``(test, formatted_err)`` to the instance's :attr:`expectedFailures` attribute, where *formatted_err* is a formatted traceback derived from *err*."
msgstr ""

#: ../../library/unittest.rst:1744
msgid "Called when the test case *test* was marked with the :func:`expectedFailure` decorator, but succeeded."
msgstr ""

#: ../../library/unittest.rst:1747
msgid "The default implementation appends the test to the instance's :attr:`unexpectedSuccesses` attribute."
msgstr ""

#: ../../library/unittest.rst:1752
msgid "A concrete implementation of :class:`TestResult` used by the :class:`TextTestRunner`."
msgstr ""

#: ../../library/unittest.rst:1755
msgid "This class was previously named ``_TextTestResult``. The old name still exists as an alias but is deprecated."
msgstr ""

#: ../../library/unittest.rst:1761
msgid "Instance of the :class:`TestLoader` class intended to be shared.  If no customization of the :class:`TestLoader` is needed, this instance can be used instead of repeatedly creating new instances."
msgstr ""

#: ../../library/unittest.rst:1768
msgid "A basic test runner implementation which prints results on standard error.  It has a few configurable parameters, but is essentially very simple.  Graphical applications which run test suites should provide alternate implementations."
msgstr ""

#: ../../library/unittest.rst:1774
msgid "This method returns the instance of ``TestResult`` used by :meth:`run`. It is not intended to be called directly, but can be overridden in subclasses to provide a custom ``TestResult``."
msgstr ""

#: ../../library/unittest.rst:1778
msgid "``_makeResult()`` instantiates the class or callable passed in the ``TextTestRunner`` constructor as the ``resultclass`` argument. It defaults to :class:`TextTestResult` if no ``resultclass`` is provided. The result class is instantiated with the following arguments::"
msgstr ""

#: ../../library/unittest.rst:1788
msgid "A command-line program that loads a set of tests from *module* and runs them; this is primarily for making test modules conveniently executable. The simplest use for this function is to include the following line at the end of a test script::"
msgstr ""

#: ../../library/unittest.rst:1796
msgid "You can run tests with more detailed information by passing in the verbosity argument::"
msgstr ""

#: ../../library/unittest.rst:1802
msgid "The *defaultTest* argument is the name of the test to run if no test names are specified via *argv*.  If not specified or ``None`` and no test names are provided via *argv*, all tests found in *module* are run."
msgstr ""

#: ../../library/unittest.rst:1806
msgid "The *argv* argument can be a list of options passed to the program, with the first element being the program name.  If not specified or ``None``, the values of :data:`sys.argv` are used."
msgstr ""

#: ../../library/unittest.rst:1810
msgid "The *testRunner* argument can either be a test runner class or an already created instance of it. By default ``main`` calls :func:`sys.exit` with an exit code indicating success or failure of the tests run."
msgstr ""

#: ../../library/unittest.rst:1814
msgid "The *testLoader* argument has to be a :class:`TestLoader` instance, and defaults to :data:`defaultTestLoader`."
msgstr ""

#: ../../library/unittest.rst:1817
msgid "``main`` supports being used from the interactive interpreter by passing in the argument ``exit=False``. This displays the result on standard output without calling :func:`sys.exit`::"
msgstr ""

#: ../../library/unittest.rst:1824
msgid "The *failfast*, *catchbreak* and *buffer* parameters have the same effect as the same-name `command-line options`_."
msgstr ""

#: ../../library/unittest.rst:1827
msgid "Calling ``main`` actually returns an instance of the ``TestProgram`` class. This stores the result of the tests run as the ``result`` attribute."
msgstr ""

#: ../../library/unittest.rst:1830
msgid "The *exit*, *verbosity*, *failfast*, *catchbreak* and *buffer* parameters were added."
msgstr ""

#: ../../library/unittest.rst:1836
msgid "load_tests Protocol"
msgstr ""

#: ../../library/unittest.rst:1840
msgid "Modules or packages can customize how tests are loaded from them during normal test runs or test discovery by implementing a function called ``load_tests``."
msgstr ""

#: ../../library/unittest.rst:1843
msgid "If a test module defines ``load_tests`` it will be called by :meth:`TestLoader.loadTestsFromModule` with the following arguments::"
msgstr ""

#: ../../library/unittest.rst:1848
msgid "It should return a :class:`TestSuite`."
msgstr ""

#: ../../library/unittest.rst:1850
msgid "*loader* is the instance of :class:`TestLoader` doing the loading. *standard_tests* are the tests that would be loaded by default from the module. It is common for test modules to only want to add or remove tests from the standard set of tests. The third argument is used when loading packages as part of test discovery."
msgstr ""

#: ../../library/unittest.rst:1856
msgid "A typical ``load_tests`` function that loads tests from a specific set of :class:`TestCase` classes may look like::"
msgstr ""

#: ../../library/unittest.rst:1868
msgid "If discovery is started, either from the command line or by calling :meth:`TestLoader.discover`, with a pattern that matches a package name then the package :file:`__init__.py` will be checked for ``load_tests``."
msgstr ""

#: ../../library/unittest.rst:1874
msgid "The default pattern is ``'test*.py'``. This matches all Python files that start with ``'test'`` but *won't* match any test directories."
msgstr ""

#: ../../library/unittest.rst:1877
msgid "A pattern like ``'test*'`` will match test packages as well as modules."
msgstr ""

#: ../../library/unittest.rst:1880
msgid "If the package :file:`__init__.py` defines ``load_tests`` then it will be called and discovery not continued into the package. ``load_tests`` is called with the following arguments::"
msgstr ""

#: ../../library/unittest.rst:1886
msgid "This should return a :class:`TestSuite` representing all the tests from the package. (``standard_tests`` will only contain tests collected from :file:`__init__.py`.)"
msgstr ""

#: ../../library/unittest.rst:1890
msgid "Because the pattern is passed into ``load_tests`` the package is free to continue (and potentially modify) test discovery. A 'do nothing' ``load_tests`` function for a test package would look like::"
msgstr ""

#: ../../library/unittest.rst:1903
msgid "Class and Module Fixtures"
msgstr ""

#: ../../library/unittest.rst:1905
msgid "Class and module level fixtures are implemented in :class:`TestSuite`. When the test suite encounters a test from a new class then :meth:`tearDownClass` from the previous class (if there is one) is called, followed by :meth:`setUpClass` from the new class."
msgstr ""

#: ../../library/unittest.rst:1910
msgid "Similarly if a test is from a different module from the previous test then ``tearDownModule`` from the previous module is run, followed by ``setUpModule`` from the new module."
msgstr ""

#: ../../library/unittest.rst:1914
msgid "After all the tests have run the final ``tearDownClass`` and ``tearDownModule`` are run."
msgstr ""

#: ../../library/unittest.rst:1917
msgid "Note that shared fixtures do not play well with [potential] features like test parallelization and they break test isolation. They should be used with care."
msgstr ""

#: ../../library/unittest.rst:1920
msgid "The default ordering of tests created by the unittest test loaders is to group all tests from the same modules and classes together. This will lead to ``setUpClass`` / ``setUpModule`` (etc) being called exactly once per class and module. If you randomize the order, so that tests from different modules and classes are adjacent to each other, then these shared fixture functions may be called multiple times in a single test run."
msgstr ""

#: ../../library/unittest.rst:1927
msgid "Shared fixtures are not intended to work with suites with non-standard ordering. A ``BaseTestSuite`` still exists for frameworks that don't want to support shared fixtures."
msgstr ""

#: ../../library/unittest.rst:1931
msgid "If there are any exceptions raised during one of the shared fixture functions the test is reported as an error. Because there is no corresponding test instance an ``_ErrorHolder`` object (that has the same interface as a :class:`TestCase`) is created to represent the error. If you are just using the standard unittest test runner then this detail doesn't matter, but if you are a framework author it may be relevant."
msgstr ""

#: ../../library/unittest.rst:1940
msgid "setUpClass and tearDownClass"
msgstr ""

#: ../../library/unittest.rst:1942
msgid "These must be implemented as class methods::"
msgstr ""

#: ../../library/unittest.rst:1955
msgid "If you want the ``setUpClass`` and ``tearDownClass`` on base classes called then you must call up to them yourself. The implementations in :class:`TestCase` are empty."
msgstr ""

#: ../../library/unittest.rst:1959
msgid "If an exception is raised during a ``setUpClass`` then the tests in the class are not run and the ``tearDownClass`` is not run. Skipped classes will not have ``setUpClass`` or ``tearDownClass`` run. If the exception is a :exc:`SkipTest` exception then the class will be reported as having been skipped instead of as an error."
msgstr ""

#: ../../library/unittest.rst:1967
msgid "setUpModule and tearDownModule"
msgstr ""

#: ../../library/unittest.rst:1969
msgid "These should be implemented as functions::"
msgstr ""

#: ../../library/unittest.rst:1977
msgid "If an exception is raised in a ``setUpModule`` then none of the tests in the module will be run and the ``tearDownModule`` will not be run. If the exception is a :exc:`SkipTest` exception then the module will be reported as having been skipped instead of as an error."
msgstr ""

#: ../../library/unittest.rst:1984
msgid "Signal Handling"
msgstr ""

#: ../../library/unittest.rst:1986
msgid "The :option:`-c/--catch <unittest -c>` command-line option to unittest, along with the ``catchbreak`` parameter to :func:`unittest.main()`, provide more friendly handling of control-C during a test run. With catch break behavior enabled control-C will allow the currently running test to complete, and the test run will then end and report all the results so far. A second control-c will raise a :exc:`KeyboardInterrupt` in the usual way."
msgstr ""

#: ../../library/unittest.rst:1993
msgid "The control-c handling signal handler attempts to remain compatible with code or tests that install their own :const:`signal.SIGINT` handler. If the ``unittest`` handler is called but *isn't* the installed :const:`signal.SIGINT` handler, i.e. it has been replaced by the system under test and delegated to, then it calls the default handler. This will normally be the expected behavior by code that replaces an installed handler and delegates to it. For individual tests that need ``unittest`` control-c handling disabled the :func:`removeHandler` decorator can be used."
msgstr ""

#: ../../library/unittest.rst:2002
msgid "There are a few utility functions for framework authors to enable control-c handling functionality within test frameworks."
msgstr ""

#: ../../library/unittest.rst:2007
msgid "Install the control-c handler. When a :const:`signal.SIGINT` is received (usually in response to the user pressing control-c) all registered results have :meth:`~TestResult.stop` called."
msgstr ""

#: ../../library/unittest.rst:2015
msgid "Register a :class:`TestResult` object for control-c handling. Registering a result stores a weak reference to it, so it doesn't prevent the result from being garbage collected."
msgstr ""

#: ../../library/unittest.rst:2019
msgid "Registering a :class:`TestResult` object has no side-effects if control-c handling is not enabled, so test frameworks can unconditionally register all results they create independently of whether or not handling is enabled."
msgstr ""

#: ../../library/unittest.rst:2027
msgid "Remove a registered result. Once a result has been removed then :meth:`~TestResult.stop` will no longer be called on that result object in response to a control-c."
msgstr ""

#: ../../library/unittest.rst:2035
msgid "When called without arguments this function removes the control-c handler if it has been installed. This function can also be used as a test decorator to temporarily remove the handler whilst the test is being executed::"
msgstr ""

