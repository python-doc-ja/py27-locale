# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2017, Python Software Foundation (translated by Python ドキュメント日本語翻訳プロジェクト)
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 2.7\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../library/decimal.rst:3
msgid ":mod:`decimal` --- Decimal fixed point and floating point arithmetic"
msgstr ""

#: ../../library/decimal.rst:29
msgid "The :mod:`decimal` module provides support for decimal floating point arithmetic.  It offers several advantages over the :class:`float` datatype:"
msgstr ""

#: ../../library/decimal.rst:32
msgid "Decimal \"is based on a floating-point model which was designed with people in mind, and necessarily has a paramount guiding principle -- computers must provide an arithmetic that works in the same way as the arithmetic that people learn at school.\" -- excerpt from the decimal arithmetic specification."
msgstr ""

#: ../../library/decimal.rst:37
msgid "Decimal numbers can be represented exactly.  In contrast, numbers like :const:`1.1` and :const:`2.2` do not have exact representations in binary floating point.  End users typically would not expect ``1.1 + 2.2`` to display as :const:`3.3000000000000003` as it does with binary floating point."
msgstr ""

#: ../../library/decimal.rst:42
msgid "The exactness carries over into arithmetic.  In decimal floating point, ``0.1 + 0.1 + 0.1 - 0.3`` is exactly equal to zero.  In binary floating point, the result is :const:`5.5511151231257827e-017`.  While near to zero, the differences prevent reliable equality testing and differences can accumulate. For this reason, decimal is preferred in accounting applications which have strict equality invariants."
msgstr ""

#: ../../library/decimal.rst:49
msgid "The decimal module incorporates a notion of significant places so that ``1.30 + 1.20`` is :const:`2.50`.  The trailing zero is kept to indicate significance. This is the customary presentation for monetary applications. For multiplication, the \"schoolbook\" approach uses all the figures in the multiplicands.  For instance, ``1.3 * 1.2`` gives :const:`1.56` while ``1.30 * 1.20`` gives :const:`1.5600`."
msgstr ""

#: ../../library/decimal.rst:56
msgid "Unlike hardware based binary floating point, the decimal module has a user alterable precision (defaulting to 28 places) which can be as large as needed for a given problem:"
msgstr ""

#: ../../library/decimal.rst:68
msgid "Both binary and decimal floating point are implemented in terms of published standards.  While the built-in float type exposes only a modest portion of its capabilities, the decimal module exposes all required parts of the standard. When needed, the programmer has full control over rounding and signal handling. This includes an option to enforce exact arithmetic by using exceptions to block any inexact operations."
msgstr ""

#: ../../library/decimal.rst:75
msgid "The decimal module was designed to support \"without prejudice, both exact unrounded decimal arithmetic (sometimes called fixed-point arithmetic) and rounded floating-point arithmetic.\"  -- excerpt from the decimal arithmetic specification."
msgstr ""

#: ../../library/decimal.rst:80
msgid "The module design is centered around three concepts:  the decimal number, the context for arithmetic, and signals."
msgstr ""

#: ../../library/decimal.rst:83
msgid "A decimal number is immutable.  It has a sign, coefficient digits, and an exponent.  To preserve significance, the coefficient digits do not truncate trailing zeros.  Decimals also include special values such as :const:`Infinity`, :const:`-Infinity`, and :const:`NaN`.  The standard also differentiates :const:`-0` from :const:`+0`."
msgstr ""

#: ../../library/decimal.rst:89
msgid "The context for arithmetic is an environment specifying precision, rounding rules, limits on exponents, flags indicating the results of operations, and trap enablers which determine whether signals are treated as exceptions.  Rounding options include :const:`ROUND_CEILING`, :const:`ROUND_DOWN`, :const:`ROUND_FLOOR`, :const:`ROUND_HALF_DOWN`, :const:`ROUND_HALF_EVEN`, :const:`ROUND_HALF_UP`, :const:`ROUND_UP`, and :const:`ROUND_05UP`."
msgstr ""

#: ../../library/decimal.rst:96
msgid "Signals are groups of exceptional conditions arising during the course of computation.  Depending on the needs of the application, signals may be ignored, considered as informational, or treated as exceptions. The signals in the decimal module are: :const:`Clamped`, :const:`InvalidOperation`, :const:`DivisionByZero`, :const:`Inexact`, :const:`Rounded`, :const:`Subnormal`, :const:`Overflow`, and :const:`Underflow`."
msgstr ""

#: ../../library/decimal.rst:103
msgid "For each signal there is a flag and a trap enabler.  When a signal is encountered, its flag is set to one, then, if the trap enabler is set to one, an exception is raised.  Flags are sticky, so the user needs to reset them before monitoring a calculation."
msgstr ""

#: ../../library/decimal.rst:111
msgid "IBM's General Decimal Arithmetic Specification, `The General Decimal Arithmetic Specification <http://speleotrove.com/decimal/>`_."
msgstr ""

#: ../../library/decimal.rst:114
msgid "IEEE standard 854-1987, `Unofficial IEEE 854 Text <http://754r.ucbtest.org/standards/854.pdf>`_."
msgstr ""

#: ../../library/decimal.rst:123
msgid "Quick-start Tutorial"
msgstr ""

#: ../../library/decimal.rst:125
msgid "The usual start to using decimals is importing the module, viewing the current context with :func:`getcontext` and, if necessary, setting new values for precision, rounding, or enabled traps::"
msgstr ""

#: ../../library/decimal.rst:137
msgid "Decimal instances can be constructed from integers, strings, floats, or tuples. Construction from an integer or a float performs an exact conversion of the value of that integer or float.  Decimal numbers include special values such as :const:`NaN` which stands for \"Not a number\", positive and negative :const:`Infinity`, and :const:`-0`."
msgstr ""

#: ../../library/decimal.rst:161
msgid "The significance of a new Decimal is determined solely by the number of digits input.  Context precision and rounding only come into play during arithmetic operations."
msgstr ""

#: ../../library/decimal.rst:178
msgid "Decimals interact well with much of the rest of Python.  Here is a small decimal floating point flying circus:"
msgstr ""

#: ../../library/decimal.rst:210
msgid "And some mathematical functions are also available to Decimal:"
msgstr ""

#: ../../library/decimal.rst:222
msgid "The :meth:`quantize` method rounds a number to a fixed exponent.  This method is useful for monetary applications that often round results to a fixed number of places:"
msgstr ""

#: ../../library/decimal.rst:231
msgid "As shown above, the :func:`getcontext` function accesses the current context and allows the settings to be changed.  This approach meets the needs of most applications."
msgstr ""

#: ../../library/decimal.rst:235
msgid "For more advanced work, it may be useful to create alternate contexts using the Context() constructor.  To make an alternate active, use the :func:`setcontext` function."
msgstr ""

#: ../../library/decimal.rst:239
msgid "In accordance with the standard, the :mod:`decimal` module provides two ready to use standard contexts, :const:`BasicContext` and :const:`ExtendedContext`. The former is especially useful for debugging because many of the traps are enabled:"
msgstr ""

#: ../../library/decimal.rst:268
msgid "Contexts also have signal flags for monitoring exceptional conditions encountered during computations.  The flags remain set until explicitly cleared, so it is best to clear the flags before each set of monitored computations by using the :meth:`clear_flags` method. ::"
msgstr ""

#: ../../library/decimal.rst:281
msgid "The *flags* entry shows that the rational approximation to :const:`Pi` was rounded (digits beyond the context precision were thrown away) and that the result is inexact (some of the discarded digits were non-zero)."
msgstr ""

#: ../../library/decimal.rst:285
msgid "Individual traps are set using the dictionary in the :attr:`traps` field of a context:"
msgstr ""

#: ../../library/decimal.rst:300
msgid "Most programs adjust the current context only once, at the beginning of the program.  And, in many applications, data is converted to :class:`Decimal` with a single cast inside a loop.  With context set and decimals created, the bulk of the program manipulates the data no differently than with other Python numeric types."
msgstr ""

#: ../../library/decimal.rst:312
msgid "Decimal objects"
msgstr ""

#: ../../library/decimal.rst:317
msgid "Construct a new :class:`Decimal` object based from *value*."
msgstr ""

#: ../../library/decimal.rst:319
msgid "*value* can be an integer, string, tuple, :class:`float`, or another :class:`Decimal` object. If no *value* is given, returns ``Decimal('0')``.  If *value* is a string, it should conform to the decimal numeric string syntax after leading and trailing whitespace characters are removed::"
msgstr ""

#: ../../library/decimal.rst:335
msgid "If *value* is a unicode string then other Unicode decimal digits are also permitted where ``digit`` appears above.  These include decimal digits from various other alphabets (for example, Arabic-Indic and Devanāgarī digits) along with the fullwidth digits ``u'\\uff10'`` through ``u'\\uff19'``."
msgstr ""

#: ../../library/decimal.rst:341
msgid "If *value* is a :class:`tuple`, it should have three components, a sign (:const:`0` for positive or :const:`1` for negative), a :class:`tuple` of digits, and an integer exponent. For example, ``Decimal((0, (1, 4, 1, 4), -3))`` returns ``Decimal('1.414')``."
msgstr ""

#: ../../library/decimal.rst:346
msgid "If *value* is a :class:`float`, the binary floating point value is losslessly converted to its exact decimal equivalent.  This conversion can often require 53 or more digits of precision.  For example, ``Decimal(float('1.1'))`` converts to ``Decimal('1.100000000000000088817841970012523233890533447265625')``."
msgstr ""

#: ../../library/decimal.rst:352
msgid "The *context* precision does not affect how many digits are stored. That is determined exclusively by the number of digits in *value*. For example, ``Decimal('3.00000')`` records all five zeros even if the context precision is only three."
msgstr ""

#: ../../library/decimal.rst:357
msgid "The purpose of the *context* argument is determining what to do if *value* is a malformed string.  If the context traps :const:`InvalidOperation`, an exception is raised; otherwise, the constructor returns a new Decimal with the value of :const:`NaN`."
msgstr ""

#: ../../library/decimal.rst:362
msgid "Once constructed, :class:`Decimal` objects are immutable."
msgstr ""

#: ../../library/decimal.rst:364
msgid "leading and trailing whitespace characters are permitted when creating a Decimal instance from a string."
msgstr ""

#: ../../library/decimal.rst:368
msgid "The argument to the constructor is now permitted to be a :class:`float` instance."
msgstr ""

#: ../../library/decimal.rst:371
msgid "Decimal floating point objects share many properties with the other built-in numeric types such as :class:`float` and :class:`int`.  All of the usual math operations and special methods apply.  Likewise, decimal objects can be copied, pickled, printed, used as dictionary keys, used as set elements, compared, sorted, and coerced to another type (such as :class:`float` or :class:`long`)."
msgstr ""

#: ../../library/decimal.rst:378
msgid "There are some small differences between arithmetic on Decimal objects and arithmetic on integers and floats.  When the remainder operator ``%`` is applied to Decimal objects, the sign of the result is the sign of the *dividend* rather than the sign of the divisor::"
msgstr ""

#: ../../library/decimal.rst:388
msgid "The integer division operator ``//`` behaves analogously, returning the integer part of the true quotient (truncating towards zero) rather than its floor, so as to preserve the usual identity ``x == (x // y) * y + x % y``::"
msgstr ""

#: ../../library/decimal.rst:397
msgid "The ``%`` and ``//`` operators implement the ``remainder`` and ``divide-integer`` operations (respectively) as described in the specification."
msgstr ""

#: ../../library/decimal.rst:401
msgid "Decimal objects cannot generally be combined with floats in arithmetic operations: an attempt to add a :class:`Decimal` to a :class:`float`, for example, will raise a :exc:`TypeError`. There's one exception to this rule: it's possible to use Python's comparison operators to compare a :class:`float` instance ``x`` with a :class:`Decimal` instance ``y``.  Without this exception, comparisons between :class:`Decimal` and :class:`float` instances would follow the general rules for comparing objects of different types described in the :ref:`expressions` section of the reference manual, leading to confusing results."
msgstr ""

#: ../../library/decimal.rst:412
msgid "A comparison between a :class:`float` instance ``x`` and a :class:`Decimal` instance ``y`` now returns a result based on the values of ``x`` and ``y``.  In earlier versions ``x < y`` returned the same (arbitrary) result for any :class:`Decimal` instance ``x`` and any :class:`float` instance ``y``."
msgstr ""

#: ../../library/decimal.rst:419
msgid "In addition to the standard numeric properties, decimal floating point objects also have a number of specialized methods:"
msgstr ""

#: ../../library/decimal.rst:425
msgid "Return the adjusted exponent after shifting out the coefficient's rightmost digits until only the lead digit remains: ``Decimal('321e+5').adjusted()`` returns seven.  Used for determining the position of the most significant digit with respect to the decimal point."
msgstr ""

#: ../../library/decimal.rst:433
msgid "Return a :term:`named tuple` representation of the number: ``DecimalTuple(sign, digits, exponent)``."
msgstr ""

#: ../../library/decimal.rst:436
msgid "Use a named tuple."
msgstr ""

#: ../../library/decimal.rst:442
msgid "Return the canonical encoding of the argument.  Currently, the encoding of a :class:`Decimal` instance is always canonical, so this operation returns its argument unchanged."
msgstr ""

#: ../../library/decimal.rst:450
msgid "Compare the values of two Decimal instances.  This operation behaves in the same way as the usual comparison method :meth:`__cmp__`, except that :meth:`compare` returns a Decimal instance rather than an integer, and if either operand is a NaN then the result is a NaN::"
msgstr ""

#: ../../library/decimal.rst:462
msgid "This operation is identical to the :meth:`compare` method, except that all NaNs signal.  That is, if neither operand is a signaling NaN then any quiet NaN operand is treated as though it were a signaling NaN."
msgstr ""

#: ../../library/decimal.rst:470
msgid "Compare two operands using their abstract representation rather than their numerical value.  Similar to the :meth:`compare` method, but the result gives a total ordering on :class:`Decimal` instances.  Two :class:`Decimal` instances with the same numeric value but different representations compare unequal in this ordering:"
msgstr ""

#: ../../library/decimal.rst:479
msgid "Quiet and signaling NaNs are also included in the total ordering.  The result of this function is ``Decimal('0')`` if both operands have the same representation, ``Decimal('-1')`` if the first operand is lower in the total order than the second, and ``Decimal('1')`` if the first operand is higher in the total order than the second operand.  See the specification for details of the total order."
msgstr ""

#: ../../library/decimal.rst:490
msgid "Compare two operands using their abstract representation rather than their value as in :meth:`compare_total`, but ignoring the sign of each operand. ``x.compare_total_mag(y)`` is equivalent to ``x.copy_abs().compare_total(y.copy_abs())``."
msgstr ""

#: ../../library/decimal.rst:499
msgid "Just returns self, this method is only to comply with the Decimal Specification."
msgstr ""

#: ../../library/decimal.rst:506
msgid "Return the absolute value of the argument.  This operation is unaffected by the context and is quiet: no flags are changed and no rounding is performed."
msgstr ""

#: ../../library/decimal.rst:514
msgid "Return the negation of the argument.  This operation is unaffected by the context and is quiet: no flags are changed and no rounding is performed."
msgstr ""

#: ../../library/decimal.rst:521
msgid "Return a copy of the first operand with the sign set to be the same as the sign of the second operand.  For example:"
msgstr ""

#: ../../library/decimal.rst:527
msgid "This operation is unaffected by the context and is quiet: no flags are changed and no rounding is performed."
msgstr ""

#: ../../library/decimal.rst:534
msgid "Return the value of the (natural) exponential function ``e**x`` at the given number.  The result is correctly rounded using the :const:`ROUND_HALF_EVEN` rounding mode."
msgstr ""

#: ../../library/decimal.rst:547
msgid "Classmethod that converts a float to a decimal number, exactly."
msgstr ""

#: ../../library/decimal.rst:549
msgid "Note `Decimal.from_float(0.1)` is not the same as `Decimal('0.1')`. Since 0.1 is not exactly representable in binary floating point, the value is stored as the nearest representable value which is `0x1.999999999999ap-4`.  That equivalent value in decimal is `0.1000000000000000055511151231257827021181583404541015625`."
msgstr ""

#: ../../library/decimal.rst:555
msgid "From Python 2.7 onwards, a :class:`Decimal` instance can also be constructed directly from a :class:`float`."
msgstr ""

#: ../../library/decimal.rst:573
msgid "Fused multiply-add.  Return self*other+third with no rounding of the intermediate product self*other."
msgstr ""

#: ../../library/decimal.rst:583
msgid "Return :const:`True` if the argument is canonical and :const:`False` otherwise.  Currently, a :class:`Decimal` instance is always canonical, so this operation always returns :const:`True`."
msgstr ""

#: ../../library/decimal.rst:591
msgid "Return :const:`True` if the argument is a finite number, and :const:`False` if the argument is an infinity or a NaN."
msgstr ""

#: ../../library/decimal.rst:598
msgid "Return :const:`True` if the argument is either positive or negative infinity and :const:`False` otherwise."
msgstr ""

#: ../../library/decimal.rst:605
msgid "Return :const:`True` if the argument is a (quiet or signaling) NaN and :const:`False` otherwise."
msgstr ""

#: ../../library/decimal.rst:612
msgid "Return :const:`True` if the argument is a *normal* finite non-zero number with an adjusted exponent greater than or equal to *Emin*. Return :const:`False` if the argument is zero, subnormal, infinite or a NaN.  Note, the term *normal* is used here in a different sense with the :meth:`normalize` method which is used to create canonical values."
msgstr ""

#: ../../library/decimal.rst:622
msgid "Return :const:`True` if the argument is a quiet NaN, and :const:`False` otherwise."
msgstr ""

#: ../../library/decimal.rst:629
msgid "Return :const:`True` if the argument has a negative sign and :const:`False` otherwise.  Note that zeros and NaNs can both carry signs."
msgstr ""

#: ../../library/decimal.rst:636
msgid "Return :const:`True` if the argument is a signaling NaN and :const:`False` otherwise."
msgstr ""

#: ../../library/decimal.rst:643
msgid "Return :const:`True` if the argument is subnormal, and :const:`False` otherwise. A number is subnormal is if it is nonzero, finite, and has an adjusted exponent less than *Emin*."
msgstr ""

#: ../../library/decimal.rst:651
msgid "Return :const:`True` if the argument is a (positive or negative) zero and :const:`False` otherwise."
msgstr ""

#: ../../library/decimal.rst:658
msgid "Return the natural (base e) logarithm of the operand.  The result is correctly rounded using the :const:`ROUND_HALF_EVEN` rounding mode."
msgstr ""

#: ../../library/decimal.rst:665
msgid "Return the base ten logarithm of the operand.  The result is correctly rounded using the :const:`ROUND_HALF_EVEN` rounding mode."
msgstr ""

#: ../../library/decimal.rst:672
msgid "For a nonzero number, return the adjusted exponent of its operand as a :class:`Decimal` instance.  If the operand is a zero then ``Decimal('-Infinity')`` is returned and the :const:`DivisionByZero` flag is raised.  If the operand is an infinity then ``Decimal('Infinity')`` is returned."
msgstr ""

#: ../../library/decimal.rst:682
msgid ":meth:`logical_and` is a logical operation which takes two *logical operands* (see :ref:`logical_operands_label`).  The result is the digit-wise ``and`` of the two operands."
msgstr ""

#: ../../library/decimal.rst:690
msgid ":meth:`logical_invert` is a logical operation.  The result is the digit-wise inversion of the operand."
msgstr ""

#: ../../library/decimal.rst:697
msgid ":meth:`logical_or` is a logical operation which takes two *logical operands* (see :ref:`logical_operands_label`).  The result is the digit-wise ``or`` of the two operands."
msgstr ""

#: ../../library/decimal.rst:705
msgid ":meth:`logical_xor` is a logical operation which takes two *logical operands* (see :ref:`logical_operands_label`).  The result is the digit-wise exclusive or of the two operands."
msgstr ""

#: ../../library/decimal.rst:713
msgid "Like ``max(self, other)`` except that the context rounding rule is applied before returning and that :const:`NaN` values are either signaled or ignored (depending on the context and whether they are signaling or quiet)."
msgstr ""

#: ../../library/decimal.rst:720
msgid "Similar to the :meth:`.max` method, but the comparison is done using the absolute values of the operands."
msgstr ""

#: ../../library/decimal.rst:727
msgid "Like ``min(self, other)`` except that the context rounding rule is applied before returning and that :const:`NaN` values are either signaled or ignored (depending on the context and whether they are signaling or quiet)."
msgstr ""

#: ../../library/decimal.rst:734
msgid "Similar to the :meth:`.min` method, but the comparison is done using the absolute values of the operands."
msgstr ""

#: ../../library/decimal.rst:741
msgid "Return the largest number representable in the given context (or in the current thread's context if no context is given) that is smaller than the given operand."
msgstr ""

#: ../../library/decimal.rst:749
msgid "Return the smallest number representable in the given context (or in the current thread's context if no context is given) that is larger than the given operand."
msgstr ""

#: ../../library/decimal.rst:757
msgid "If the two operands are unequal, return the number closest to the first operand in the direction of the second operand.  If both operands are numerically equal, return a copy of the first operand with the sign set to be the same as the sign of the second operand."
msgstr ""

#: ../../library/decimal.rst:766
msgid "Normalize the number by stripping the rightmost trailing zeros and converting any result equal to :const:`Decimal('0')` to :const:`Decimal('0e0')`. Used for producing canonical values for attributes of an equivalence class. For example, ``Decimal('32.100')`` and ``Decimal('0.321000e+2')`` both normalize to the equivalent value ``Decimal('32.1')``."
msgstr ""

#: ../../library/decimal.rst:775
msgid "Return a string describing the *class* of the operand.  The returned value is one of the following ten strings."
msgstr ""

#: ../../library/decimal.rst:778
msgid "``\"-Infinity\"``, indicating that the operand is negative infinity."
msgstr ""

#: ../../library/decimal.rst:779
msgid "``\"-Normal\"``, indicating that the operand is a negative normal number."
msgstr ""

#: ../../library/decimal.rst:780
msgid "``\"-Subnormal\"``, indicating that the operand is negative and subnormal."
msgstr ""

#: ../../library/decimal.rst:781
msgid "``\"-Zero\"``, indicating that the operand is a negative zero."
msgstr ""

#: ../../library/decimal.rst:782
msgid "``\"+Zero\"``, indicating that the operand is a positive zero."
msgstr ""

#: ../../library/decimal.rst:783
msgid "``\"+Subnormal\"``, indicating that the operand is positive and subnormal."
msgstr ""

#: ../../library/decimal.rst:784
msgid "``\"+Normal\"``, indicating that the operand is a positive normal number."
msgstr ""

#: ../../library/decimal.rst:785
msgid "``\"+Infinity\"``, indicating that the operand is positive infinity."
msgstr ""

#: ../../library/decimal.rst:786
msgid "``\"NaN\"``, indicating that the operand is a quiet NaN (Not a Number)."
msgstr ""

#: ../../library/decimal.rst:787
msgid "``\"sNaN\"``, indicating that the operand is a signaling NaN."
msgstr ""

#: ../../library/decimal.rst:793
msgid "Return a value equal to the first operand after rounding and having the exponent of the second operand."
msgstr ""

#: ../../library/decimal.rst:799
msgid "Unlike other operations, if the length of the coefficient after the quantize operation would be greater than precision, then an :const:`InvalidOperation` is signaled. This guarantees that, unless there is an error condition, the quantized exponent is always equal to that of the right-hand operand."
msgstr ""

#: ../../library/decimal.rst:805
msgid "Also unlike other operations, quantize never signals Underflow, even if the result is subnormal and inexact."
msgstr ""

#: ../../library/decimal.rst:808
msgid "If the exponent of the second operand is larger than that of the first then rounding may be necessary.  In this case, the rounding mode is determined by the ``rounding`` argument if given, else by the given ``context`` argument; if neither argument is given the rounding mode of the current thread's context is used."
msgstr ""

#: ../../library/decimal.rst:814
msgid "If *watchexp* is set (default), then an error is returned whenever the resulting exponent is greater than :attr:`Emax` or less than :attr:`Etiny`."
msgstr ""

#: ../../library/decimal.rst:820
msgid "Return ``Decimal(10)``, the radix (base) in which the :class:`Decimal` class does all its arithmetic.  Included for compatibility with the specification."
msgstr ""

#: ../../library/decimal.rst:828
msgid "Return the remainder from dividing *self* by *other*.  This differs from ``self % other`` in that the sign of the remainder is chosen so as to minimize its absolute value.  More precisely, the return value is ``self - n * other`` where ``n`` is the integer nearest to the exact value of ``self / other``, and if two integers are equally near then the even one is chosen."
msgstr ""

#: ../../library/decimal.rst:835
msgid "If the result is zero then its sign will be the sign of *self*."
msgstr ""

#: ../../library/decimal.rst:846
msgid "Return the result of rotating the digits of the first operand by an amount specified by the second operand.  The second operand must be an integer in the range -precision through precision.  The absolute value of the second operand gives the number of places to rotate.  If the second operand is positive then rotation is to the left; otherwise rotation is to the right. The coefficient of the first operand is padded on the left with zeros to length precision if necessary.  The sign and exponent of the first operand are unchanged."
msgstr ""

#: ../../library/decimal.rst:859
msgid "Test whether self and other have the same exponent or whether both are :const:`NaN`."
msgstr ""

#: ../../library/decimal.rst:864
msgid "Return the first operand with exponent adjusted by the second. Equivalently, return the first operand multiplied by ``10**other``.  The second operand must be an integer."
msgstr ""

#: ../../library/decimal.rst:872
msgid "Return the result of shifting the digits of the first operand by an amount specified by the second operand.  The second operand must be an integer in the range -precision through precision.  The absolute value of the second operand gives the number of places to shift.  If the second operand is positive then the shift is to the left; otherwise the shift is to the right.  Digits shifted into the coefficient are zeros.  The sign and exponent of the first operand are unchanged."
msgstr ""

#: ../../library/decimal.rst:884
msgid "Return the square root of the argument to full precision."
msgstr ""

#: ../../library/decimal.rst:889
msgid "Convert to an engineering-type string."
msgstr ""

#: ../../library/decimal.rst:891
msgid "Engineering notation has an exponent which is a multiple of 3, so there are up to 3 digits left of the decimal place.  For example, converts ``Decimal('123E+1')`` to ``Decimal('1.23E+3')``."
msgstr ""

#: ../../library/decimal.rst:897
msgid "Identical to the :meth:`to_integral_value` method.  The ``to_integral`` name has been kept for compatibility with older versions."
msgstr ""

#: ../../library/decimal.rst:902
msgid "Round to the nearest integer, signaling :const:`Inexact` or :const:`Rounded` as appropriate if rounding occurs.  The rounding mode is determined by the ``rounding`` parameter if given, else by the given ``context``.  If neither parameter is given then the rounding mode of the current context is used."
msgstr ""

#: ../../library/decimal.rst:912
msgid "Round to the nearest integer without signaling :const:`Inexact` or :const:`Rounded`.  If given, applies *rounding*; otherwise, uses the rounding method in either the supplied *context* or the current context."
msgstr ""

#: ../../library/decimal.rst:916
msgid "renamed from ``to_integral`` to ``to_integral_value``.  The old name remains valid for compatibility."
msgstr ""

#: ../../library/decimal.rst:923
msgid "Logical operands"
msgstr ""

#: ../../library/decimal.rst:925
msgid "The :meth:`logical_and`, :meth:`logical_invert`, :meth:`logical_or`, and :meth:`logical_xor` methods expect their arguments to be *logical operands*.  A *logical operand* is a :class:`Decimal` instance whose exponent and sign are both zero, and whose digits are all either :const:`0` or :const:`1`."
msgstr ""

#: ../../library/decimal.rst:937
msgid "Context objects"
msgstr ""

#: ../../library/decimal.rst:939
msgid "Contexts are environments for arithmetic operations.  They govern precision, set rules for rounding, determine which signals are treated as exceptions, and limit the range for exponents."
msgstr ""

#: ../../library/decimal.rst:943
msgid "Each thread has its own current context which is accessed or changed using the :func:`getcontext` and :func:`setcontext` functions:"
msgstr ""

#: ../../library/decimal.rst:949
msgid "Return the current context for the active thread."
msgstr ""

#: ../../library/decimal.rst:954
msgid "Set the current context for the active thread to *c*."
msgstr ""

#: ../../library/decimal.rst:956
msgid "Beginning with Python 2.5, you can also use the :keyword:`with` statement and the :func:`localcontext` function to temporarily change the active context."
msgstr ""

#: ../../library/decimal.rst:962
msgid "Return a context manager that will set the current context for the active thread to a copy of *c* on entry to the with-statement and restore the previous context when exiting the with-statement. If no context is specified, a copy of the current context is used."
msgstr ""

#: ../../library/decimal.rst:969
msgid "For example, the following code sets the current decimal precision to 42 places, performs a calculation, and then automatically restores the previous context::"
msgstr ""

#: ../../library/decimal.rst:983
msgid "New contexts can also be created using the :class:`Context` constructor described below. In addition, the module provides three pre-made contexts:"
msgstr ""

#: ../../library/decimal.rst:989
msgid "This is a standard context defined by the General Decimal Arithmetic Specification.  Precision is set to nine.  Rounding is set to :const:`ROUND_HALF_UP`.  All flags are cleared.  All traps are enabled (treated as exceptions) except :const:`Inexact`, :const:`Rounded`, and :const:`Subnormal`."
msgstr ""

#: ../../library/decimal.rst:995
msgid "Because many of the traps are enabled, this context is useful for debugging."
msgstr ""

#: ../../library/decimal.rst:1000
msgid "This is a standard context defined by the General Decimal Arithmetic Specification.  Precision is set to nine.  Rounding is set to :const:`ROUND_HALF_EVEN`.  All flags are cleared.  No traps are enabled (so that exceptions are not raised during computations)."
msgstr ""

#: ../../library/decimal.rst:1005
msgid "Because the traps are disabled, this context is useful for applications that prefer to have result value of :const:`NaN` or :const:`Infinity` instead of raising exceptions.  This allows an application to complete a run in the presence of conditions that would otherwise halt the program."
msgstr ""

#: ../../library/decimal.rst:1013
msgid "This context is used by the :class:`Context` constructor as a prototype for new contexts.  Changing a field (such a precision) has the effect of changing the default for new contexts created by the :class:`Context` constructor."
msgstr ""

#: ../../library/decimal.rst:1017
msgid "This context is most useful in multi-threaded environments.  Changing one of the fields before threads are started has the effect of setting system-wide defaults.  Changing the fields after threads have started is not recommended as it would require thread synchronization to prevent race conditions."
msgstr ""

#: ../../library/decimal.rst:1022
msgid "In single threaded environments, it is preferable to not use this context at all.  Instead, simply create contexts explicitly as described below."
msgstr ""

#: ../../library/decimal.rst:1025
msgid "The default values are precision=28, rounding=ROUND_HALF_EVEN, and enabled traps for Overflow, InvalidOperation, and DivisionByZero."
msgstr ""

#: ../../library/decimal.rst:1028
msgid "In addition to the three supplied contexts, new contexts can be created with the :class:`Context` constructor."
msgstr ""

#: ../../library/decimal.rst:1034
msgid "Creates a new context.  If a field is not specified or is :const:`None`, the default values are copied from the :const:`DefaultContext`.  If the *flags* field is not specified or is :const:`None`, all flags are cleared."
msgstr ""

#: ../../library/decimal.rst:1038
msgid "The *prec* field is a positive integer that sets the precision for arithmetic operations in the context."
msgstr ""

#: ../../library/decimal.rst:1041
msgid "The *rounding* option is one of:"
msgstr ""

#: ../../library/decimal.rst:1043
msgid ":const:`ROUND_CEILING` (towards :const:`Infinity`),"
msgstr ""

#: ../../library/decimal.rst:1044
msgid ":const:`ROUND_DOWN` (towards zero),"
msgstr ""

#: ../../library/decimal.rst:1045
msgid ":const:`ROUND_FLOOR` (towards :const:`-Infinity`),"
msgstr ""

#: ../../library/decimal.rst:1046
msgid ":const:`ROUND_HALF_DOWN` (to nearest with ties going towards zero),"
msgstr ""

#: ../../library/decimal.rst:1047
msgid ":const:`ROUND_HALF_EVEN` (to nearest with ties going to nearest even integer),"
msgstr ""

#: ../../library/decimal.rst:1048
msgid ":const:`ROUND_HALF_UP` (to nearest with ties going away from zero), or"
msgstr ""

#: ../../library/decimal.rst:1049
msgid ":const:`ROUND_UP` (away from zero)."
msgstr ""

#: ../../library/decimal.rst:1050
msgid ":const:`ROUND_05UP` (away from zero if last digit after rounding towards zero would have been 0 or 5; otherwise towards zero)"
msgstr ""

#: ../../library/decimal.rst:1053
msgid "The *traps* and *flags* fields list any signals to be set. Generally, new contexts should only set traps and leave the flags clear."
msgstr ""

#: ../../library/decimal.rst:1056
msgid "The *Emin* and *Emax* fields are integers specifying the outer limits allowable for exponents."
msgstr ""

#: ../../library/decimal.rst:1059
msgid "The *capitals* field is either :const:`0` or :const:`1` (the default). If set to :const:`1`, exponents are printed with a capital :const:`E`; otherwise, a lowercase :const:`e` is used: :const:`Decimal('6.02e+23')`."
msgstr ""

#: ../../library/decimal.rst:1063
msgid "The :const:`ROUND_05UP` rounding mode was added."
msgstr ""

#: ../../library/decimal.rst:1066
msgid "The :class:`Context` class defines several general purpose methods as well as a large number of methods for doing arithmetic directly in a given context. In addition, for each of the :class:`Decimal` methods described above (with the exception of the :meth:`adjusted` and :meth:`as_tuple` methods) there is a corresponding :class:`Context` method.  For example, for a :class:`Context` instance ``C`` and :class:`Decimal` instance ``x``, ``C.exp(x)`` is equivalent to ``x.exp(context=C)``.  Each :class:`Context` method accepts a Python integer (an instance of :class:`int` or :class:`long`) anywhere that a Decimal instance is accepted."
msgstr ""

#: ../../library/decimal.rst:1079
msgid "Resets all of the flags to :const:`0`."
msgstr ""

#: ../../library/decimal.rst:1083
msgid "Return a duplicate of the context."
msgstr ""

#: ../../library/decimal.rst:1087
msgid "Return a copy of the Decimal instance num."
msgstr ""

#: ../../library/decimal.rst:1091
msgid "Creates a new Decimal instance from *num* but using *self* as context. Unlike the :class:`Decimal` constructor, the context precision, rounding method, flags, and traps are applied to the conversion."
msgstr ""

#: ../../library/decimal.rst:1095
msgid "This is useful because constants are often given to a greater precision than is needed by the application.  Another benefit is that rounding immediately eliminates unintended effects from digits beyond the current precision. In the following example, using unrounded inputs means that adding zero to a sum can change the result:"
msgstr ""

#: ../../library/decimal.rst:1109
msgid "This method implements the to-number operation of the IBM specification. If the argument is a string, no leading or trailing whitespace is permitted."
msgstr ""

#: ../../library/decimal.rst:1115
msgid "Creates a new Decimal instance from a float *f* but rounding using *self* as the context.  Unlike the :meth:`Decimal.from_float` class method, the context precision, rounding method, flags, and traps are applied to the conversion."
msgstr ""

#: ../../library/decimal.rst:1135
msgid "Returns a value equal to ``Emin - prec + 1`` which is the minimum exponent value for subnormal results.  When underflow occurs, the exponent is set to :const:`Etiny`."
msgstr ""

#: ../../library/decimal.rst:1142
msgid "Returns a value equal to ``Emax - prec + 1``."
msgstr ""

#: ../../library/decimal.rst:1144
msgid "The usual approach to working with decimals is to create :class:`Decimal` instances and then apply arithmetic operations which take place within the current context for the active thread.  An alternative approach is to use context methods for calculating within a specific context.  The methods are similar to those for the :class:`Decimal` class and are only briefly recounted here."
msgstr ""

#: ../../library/decimal.rst:1154
msgid "Returns the absolute value of *x*."
msgstr ""

#: ../../library/decimal.rst:1159
msgid "Return the sum of *x* and *y*."
msgstr ""

#: ../../library/decimal.rst:1164
msgid "Returns the same Decimal object *x*."
msgstr ""

#: ../../library/decimal.rst:1169
msgid "Compares *x* and *y* numerically."
msgstr ""

#: ../../library/decimal.rst:1174
msgid "Compares the values of the two operands numerically."
msgstr ""

#: ../../library/decimal.rst:1179
msgid "Compares two operands using their abstract representation."
msgstr ""

#: ../../library/decimal.rst:1184
msgid "Compares two operands using their abstract representation, ignoring sign."
msgstr ""

#: ../../library/decimal.rst:1189
msgid "Returns a copy of *x* with the sign set to 0."
msgstr ""

#: ../../library/decimal.rst:1194
msgid "Returns a copy of *x* with the sign inverted."
msgstr ""

#: ../../library/decimal.rst:1199
msgid "Copies the sign from *y* to *x*."
msgstr ""

#: ../../library/decimal.rst:1204
msgid "Return *x* divided by *y*."
msgstr ""

#: ../../library/decimal.rst:1209
msgid "Return *x* divided by *y*, truncated to an integer."
msgstr ""

#: ../../library/decimal.rst:1214
msgid "Divides two numbers and returns the integer part of the result."
msgstr ""

#: ../../library/decimal.rst:1219
msgid "Returns `e ** x`."
msgstr ""

#: ../../library/decimal.rst:1224
msgid "Returns *x* multiplied by *y*, plus *z*."
msgstr ""

#: ../../library/decimal.rst:1229
msgid "Returns ``True`` if *x* is canonical; otherwise returns ``False``."
msgstr ""

#: ../../library/decimal.rst:1234
msgid "Returns ``True`` if *x* is finite; otherwise returns ``False``."
msgstr ""

#: ../../library/decimal.rst:1239
msgid "Returns ``True`` if *x* is infinite; otherwise returns ``False``."
msgstr ""

#: ../../library/decimal.rst:1244
msgid "Returns ``True`` if *x* is a qNaN or sNaN; otherwise returns ``False``."
msgstr ""

#: ../../library/decimal.rst:1249
msgid "Returns ``True`` if *x* is a normal number; otherwise returns ``False``."
msgstr ""

#: ../../library/decimal.rst:1254
msgid "Returns ``True`` if *x* is a quiet NaN; otherwise returns ``False``."
msgstr ""

#: ../../library/decimal.rst:1259
msgid "Returns ``True`` if *x* is negative; otherwise returns ``False``."
msgstr ""

#: ../../library/decimal.rst:1264
msgid "Returns ``True`` if *x* is a signaling NaN; otherwise returns ``False``."
msgstr ""

#: ../../library/decimal.rst:1269
msgid "Returns ``True`` if *x* is subnormal; otherwise returns ``False``."
msgstr ""

#: ../../library/decimal.rst:1274
msgid "Returns ``True`` if *x* is a zero; otherwise returns ``False``."
msgstr ""

#: ../../library/decimal.rst:1279
msgid "Returns the natural (base e) logarithm of *x*."
msgstr ""

#: ../../library/decimal.rst:1284
msgid "Returns the base 10 logarithm of *x*."
msgstr ""

#: ../../library/decimal.rst:1289
msgid "Returns the exponent of the magnitude of the operand's MSD."
msgstr ""

#: ../../library/decimal.rst:1294
msgid "Applies the logical operation *and* between each operand's digits."
msgstr ""

#: ../../library/decimal.rst:1299
msgid "Invert all the digits in *x*."
msgstr ""

#: ../../library/decimal.rst:1304
msgid "Applies the logical operation *or* between each operand's digits."
msgstr ""

#: ../../library/decimal.rst:1309
msgid "Applies the logical operation *xor* between each operand's digits."
msgstr ""

#: ../../library/decimal.rst:1314
msgid "Compares two values numerically and returns the maximum."
msgstr ""

#: ../../library/decimal.rst:1319
#: ../../library/decimal.rst:1329
msgid "Compares the values numerically with their sign ignored."
msgstr ""

#: ../../library/decimal.rst:1324
msgid "Compares two values numerically and returns the minimum."
msgstr ""

#: ../../library/decimal.rst:1334
msgid "Minus corresponds to the unary prefix minus operator in Python."
msgstr ""

#: ../../library/decimal.rst:1339
msgid "Return the product of *x* and *y*."
msgstr ""

#: ../../library/decimal.rst:1344
msgid "Returns the largest representable number smaller than *x*."
msgstr ""

#: ../../library/decimal.rst:1349
msgid "Returns the smallest representable number larger than *x*."
msgstr ""

#: ../../library/decimal.rst:1354
msgid "Returns the number closest to *x*, in direction towards *y*."
msgstr ""

#: ../../library/decimal.rst:1359
msgid "Reduces *x* to its simplest form."
msgstr ""

#: ../../library/decimal.rst:1364
msgid "Returns an indication of the class of *x*."
msgstr ""

#: ../../library/decimal.rst:1369
msgid "Plus corresponds to the unary prefix plus operator in Python.  This operation applies the context precision and rounding, so it is *not* an identity operation."
msgstr ""

#: ../../library/decimal.rst:1376
msgid "Return ``x`` to the power of ``y``, reduced modulo ``modulo`` if given."
msgstr ""

#: ../../library/decimal.rst:1378
msgid "With two arguments, compute ``x**y``.  If ``x`` is negative then ``y`` must be integral.  The result will be inexact unless ``y`` is integral and the result is finite and can be expressed exactly in 'precision' digits. The result should always be correctly rounded, using the rounding mode of the current thread's context."
msgstr ""

#: ../../library/decimal.rst:1384
msgid "With three arguments, compute ``(x**y) % modulo``.  For the three argument form, the following restrictions on the arguments hold:"
msgstr ""

#: ../../library/decimal.rst:1387
msgid "all three arguments must be integral"
msgstr ""

#: ../../library/decimal.rst:1388
msgid "``y`` must be nonnegative"
msgstr ""

#: ../../library/decimal.rst:1389
msgid "at least one of ``x`` or ``y`` must be nonzero"
msgstr ""

#: ../../library/decimal.rst:1390
msgid "``modulo`` must be nonzero and have at most 'precision' digits"
msgstr ""

#: ../../library/decimal.rst:1392
msgid "The value resulting from ``Context.power(x, y, modulo)`` is equal to the value that would be obtained by computing ``(x**y) % modulo`` with unbounded precision, but is computed more efficiently.  The exponent of the result is zero, regardless of the exponents of ``x``, ``y`` and ``modulo``.  The result is always exact."
msgstr ""

#: ../../library/decimal.rst:1399
msgid "``y`` may now be nonintegral in ``x**y``. Stricter requirements for the three-argument version."
msgstr ""

#: ../../library/decimal.rst:1406
msgid "Returns a value equal to *x* (rounded), having the exponent of *y*."
msgstr ""

#: ../../library/decimal.rst:1411
msgid "Just returns 10, as this is Decimal, :)"
msgstr ""

#: ../../library/decimal.rst:1416
msgid "Returns the remainder from integer division."
msgstr ""

#: ../../library/decimal.rst:1418
msgid "The sign of the result, if non-zero, is the same as that of the original dividend."
msgstr ""

#: ../../library/decimal.rst:1423
msgid "Returns ``x - y * n``, where *n* is the integer nearest the exact value of ``x / y`` (if the result is 0 then its sign will be the sign of *x*)."
msgstr ""

#: ../../library/decimal.rst:1429
msgid "Returns a rotated copy of *x*, *y* times."
msgstr ""

#: ../../library/decimal.rst:1434
msgid "Returns ``True`` if the two operands have the same exponent."
msgstr ""

#: ../../library/decimal.rst:1439
msgid "Returns the first operand after adding the second value its exp."
msgstr ""

#: ../../library/decimal.rst:1444
msgid "Returns a shifted copy of *x*, *y* times."
msgstr ""

#: ../../library/decimal.rst:1449
msgid "Square root of a non-negative number to context precision."
msgstr ""

#: ../../library/decimal.rst:1454
msgid "Return the difference between *x* and *y*."
msgstr ""

#: ../../library/decimal.rst:1459
msgid "Converts a number to a string, using scientific notation."
msgstr ""

#: ../../library/decimal.rst:1464
msgid "Rounds to an integer."
msgstr ""

#: ../../library/decimal.rst:1469
msgid "Converts a number to a string using scientific notation."
msgstr ""

#: ../../library/decimal.rst:1477
msgid "Signals"
msgstr ""

#: ../../library/decimal.rst:1479
msgid "Signals represent conditions that arise during computation. Each corresponds to one context flag and one context trap enabler."
msgstr ""

#: ../../library/decimal.rst:1482
msgid "The context flag is set whenever the condition is encountered. After the computation, flags may be checked for informational purposes (for instance, to determine whether a computation was exact). After checking the flags, be sure to clear all flags before starting the next computation."
msgstr ""

#: ../../library/decimal.rst:1487
msgid "If the context's trap enabler is set for the signal, then the condition causes a Python exception to be raised.  For example, if the :class:`DivisionByZero` trap is set, then a :exc:`DivisionByZero` exception is raised upon encountering the condition."
msgstr ""

#: ../../library/decimal.rst:1495
msgid "Altered an exponent to fit representation constraints."
msgstr ""

#: ../../library/decimal.rst:1497
msgid "Typically, clamping occurs when an exponent falls outside the context's :attr:`Emin` and :attr:`Emax` limits.  If possible, the exponent is reduced to fit by adding zeros to the coefficient."
msgstr ""

#: ../../library/decimal.rst:1504
msgid "Base class for other signals and a subclass of :exc:`ArithmeticError`."
msgstr ""

#: ../../library/decimal.rst:1509
msgid "Signals the division of a non-infinite number by zero."
msgstr ""

#: ../../library/decimal.rst:1511
msgid "Can occur with division, modulo division, or when raising a number to a negative power.  If this signal is not trapped, returns :const:`Infinity` or :const:`-Infinity` with the sign determined by the inputs to the calculation."
msgstr ""

#: ../../library/decimal.rst:1518
msgid "Indicates that rounding occurred and the result is not exact."
msgstr ""

#: ../../library/decimal.rst:1520
msgid "Signals when non-zero digits were discarded during rounding. The rounded result is returned.  The signal flag or trap is used to detect when results are inexact."
msgstr ""

#: ../../library/decimal.rst:1527
msgid "An invalid operation was performed."
msgstr ""

#: ../../library/decimal.rst:1529
msgid "Indicates that an operation was requested that does not make sense. If not trapped, returns :const:`NaN`.  Possible causes include::"
msgstr ""

#: ../../library/decimal.rst:1546
msgid "Numerical overflow."
msgstr ""

#: ../../library/decimal.rst:1548
msgid "Indicates the exponent is larger than :attr:`Emax` after rounding has occurred.  If not trapped, the result depends on the rounding mode, either pulling inward to the largest representable finite number or rounding outward to :const:`Infinity`.  In either case, :class:`Inexact` and :class:`Rounded` are also signaled."
msgstr ""

#: ../../library/decimal.rst:1557
msgid "Rounding occurred though possibly no information was lost."
msgstr ""

#: ../../library/decimal.rst:1559
msgid "Signaled whenever rounding discards digits; even if those digits are zero (such as rounding :const:`5.00` to :const:`5.0`).  If not trapped, returns the result unchanged.  This signal is used to detect loss of significant digits."
msgstr ""

#: ../../library/decimal.rst:1567
msgid "Exponent was lower than :attr:`Emin` prior to rounding."
msgstr ""

#: ../../library/decimal.rst:1569
msgid "Occurs when an operation result is subnormal (the exponent is too small). If not trapped, returns the result unchanged."
msgstr ""

#: ../../library/decimal.rst:1575
msgid "Numerical underflow with result rounded to zero."
msgstr ""

#: ../../library/decimal.rst:1577
msgid "Occurs when a subnormal result is pushed to zero by rounding. :class:`Inexact` and :class:`Subnormal` are also signaled."
msgstr ""

#: ../../library/decimal.rst:1580
msgid "The following table summarizes the hierarchy of signals::"
msgstr ""

#: ../../library/decimal.rst:1599
msgid "Floating Point Notes"
msgstr ""

#: ../../library/decimal.rst:1603
msgid "Mitigating round-off error with increased precision"
msgstr ""

#: ../../library/decimal.rst:1605
msgid "The use of decimal floating point eliminates decimal representation error (making it possible to represent :const:`0.1` exactly); however, some operations can still incur round-off error when non-zero digits exceed the fixed precision."
msgstr ""

#: ../../library/decimal.rst:1609
msgid "The effects of round-off error can be amplified by the addition or subtraction of nearly offsetting quantities resulting in loss of significance.  Knuth provides two instructive examples where rounded floating point arithmetic with insufficient precision causes the breakdown of the associative and distributive properties of addition:"
msgstr ""

#: ../../library/decimal.rst:1633
msgid "The :mod:`decimal` module makes it possible to restore the identities by expanding the precision sufficiently to avoid loss of significance:"
msgstr ""

#: ../../library/decimal.rst:1653
msgid "Special values"
msgstr ""

#: ../../library/decimal.rst:1655
msgid "The number system for the :mod:`decimal` module provides special values including :const:`NaN`, :const:`sNaN`, :const:`-Infinity`, :const:`Infinity`, and two zeros, :const:`+0` and :const:`-0`."
msgstr ""

#: ../../library/decimal.rst:1659
msgid "Infinities can be constructed directly with:  ``Decimal('Infinity')``. Also, they can arise from dividing by zero when the :exc:`DivisionByZero` signal is not trapped.  Likewise, when the :exc:`Overflow` signal is not trapped, infinity can result from rounding beyond the limits of the largest representable number."
msgstr ""

#: ../../library/decimal.rst:1664
msgid "The infinities are signed (affine) and can be used in arithmetic operations where they get treated as very large, indeterminate numbers.  For instance, adding a constant to infinity gives another infinite result."
msgstr ""

#: ../../library/decimal.rst:1668
msgid "Some operations are indeterminate and return :const:`NaN`, or if the :exc:`InvalidOperation` signal is trapped, raise an exception.  For example, ``0/0`` returns :const:`NaN` which means \"not a number\".  This variety of :const:`NaN` is quiet and, once created, will flow through other computations always resulting in another :const:`NaN`.  This behavior can be useful for a series of computations that occasionally have missing inputs --- it allows the calculation to proceed while flagging specific results as invalid."
msgstr ""

#: ../../library/decimal.rst:1676
msgid "A variant is :const:`sNaN` which signals rather than remaining quiet after every operation.  This is a useful return value when an invalid result needs to interrupt a calculation for special handling."
msgstr ""

#: ../../library/decimal.rst:1680
msgid "The behavior of Python's comparison operators can be a little surprising where a :const:`NaN` is involved.  A test for equality where one of the operands is a quiet or signaling :const:`NaN` always returns :const:`False` (even when doing ``Decimal('NaN')==Decimal('NaN')``), while a test for inequality always returns :const:`True`.  An attempt to compare two Decimals using any of the ``<``, ``<=``, ``>`` or ``>=`` operators will raise the :exc:`InvalidOperation` signal if either operand is a :const:`NaN`, and return :const:`False` if this signal is not trapped.  Note that the General Decimal Arithmetic specification does not specify the behavior of direct comparisons; these rules for comparisons involving a :const:`NaN` were taken from the IEEE 854 standard (see Table 3 in section 5.7).  To ensure strict standards-compliance, use the :meth:`compare` and :meth:`compare-signal` methods instead."
msgstr ""

#: ../../library/decimal.rst:1693
msgid "The signed zeros can result from calculations that underflow. They keep the sign that would have resulted if the calculation had been carried out to greater precision.  Since their magnitude is zero, both positive and negative zeros are treated as equal and their sign is informational."
msgstr ""

#: ../../library/decimal.rst:1698
msgid "In addition to the two signed zeros which are distinct yet equal, there are various representations of zero with differing precisions yet equivalent in value.  This takes a bit of getting used to.  For an eye accustomed to normalized floating point representations, it is not immediately obvious that the following calculation returns a value equal to zero:"
msgstr ""

#: ../../library/decimal.rst:1713
msgid "Working with threads"
msgstr ""

#: ../../library/decimal.rst:1715
msgid "The :func:`getcontext` function accesses a different :class:`Context` object for each thread.  Having separate thread contexts means that threads may make changes (such as ``getcontext.prec=10``) without interfering with other threads."
msgstr ""

#: ../../library/decimal.rst:1719
msgid "Likewise, the :func:`setcontext` function automatically assigns its target to the current thread."
msgstr ""

#: ../../library/decimal.rst:1722
msgid "If :func:`setcontext` has not been called before :func:`getcontext`, then :func:`getcontext` will automatically create a new context for use in the current thread."
msgstr ""

#: ../../library/decimal.rst:1726
msgid "The new context is copied from a prototype context called *DefaultContext*. To control the defaults so that each thread will use the same values throughout the application, directly modify the *DefaultContext* object. This should be done *before* any threads are started so that there won't be a race condition between threads calling :func:`getcontext`. For example::"
msgstr ""

#: ../../library/decimal.rst:1751
msgid "Recipes"
msgstr ""

#: ../../library/decimal.rst:1753
msgid "Here are a few recipes that serve as utility functions and that demonstrate ways to work with the :class:`Decimal` class::"
msgstr ""

#: ../../library/decimal.rst:1901
msgid "Decimal FAQ"
msgstr ""

#: ../../library/decimal.rst:1903
msgid "Q. It is cumbersome to type ``decimal.Decimal('1234.5')``.  Is there a way to minimize typing when using the interactive interpreter?"
msgstr ""

#: ../../library/decimal.rst:1906
msgid "A. Some users abbreviate the constructor to just a single letter:"
msgstr ""

#: ../../library/decimal.rst:1912
msgid "Q. In a fixed-point application with two decimal places, some inputs have many places and need to be rounded.  Others are not supposed to have excess digits and need to be validated.  What methods should be used?"
msgstr ""

#: ../../library/decimal.rst:1916
msgid "A. The :meth:`quantize` method rounds to a fixed number of decimal places. If the :const:`Inexact` trap is set, it is also useful for validation:"
msgstr ""

#: ../../library/decimal.rst:1934
msgid "Q. Once I have valid two place inputs, how do I maintain that invariant throughout an application?"
msgstr ""

#: ../../library/decimal.rst:1937
msgid "A. Some operations like addition, subtraction, and multiplication by an integer will automatically preserve fixed point.  Others operations, like division and non-integer multiplication, will change the number of decimal places and need to be followed-up with a :meth:`quantize` step:"
msgstr ""

#: ../../library/decimal.rst:1955
msgid "In developing fixed-point applications, it is convenient to define functions to handle the :meth:`quantize` step:"
msgstr ""

#: ../../library/decimal.rst:1968
msgid "Q. There are many ways to express the same value.  The numbers :const:`200`, :const:`200.000`, :const:`2E2`, and :const:`.02E+4` all have the same value at various precisions. Is there a way to transform them to a single recognizable canonical value?"
msgstr ""

#: ../../library/decimal.rst:1973
msgid "A. The :meth:`normalize` method maps all equivalent values to a single representative:"
msgstr ""

#: ../../library/decimal.rst:1980
msgid "Q. Some decimal values always print with exponential notation.  Is there a way to get a non-exponential representation?"
msgstr ""

#: ../../library/decimal.rst:1983
msgid "A. For some values, exponential notation is the only way to express the number of significant places in the coefficient.  For example, expressing :const:`5.0E+3` as :const:`5000` keeps the value constant but cannot show the original's two-place significance."
msgstr ""

#: ../../library/decimal.rst:1988
msgid "If an application does not care about tracking significance, it is easy to remove the exponent and trailing zeros, losing significance, but keeping the value unchanged::"
msgstr ""

#: ../../library/decimal.rst:2001
msgid "Q. Is there a way to convert a regular float to a :class:`Decimal`?"
msgstr ""

#: ../../library/decimal.rst:2003
msgid "A. Yes, any binary floating point number can be exactly expressed as a Decimal though an exact conversion may take more precision than intuition would suggest:"
msgstr ""

#: ../../library/decimal.rst:2012
msgid "Q. Within a complex calculation, how can I make sure that I haven't gotten a spurious result because of insufficient precision or rounding anomalies."
msgstr ""

#: ../../library/decimal.rst:2015
msgid "A. The decimal module makes it easy to test results.  A best practice is to re-run calculations using greater precision and with various rounding modes. Widely differing results indicate insufficient precision, rounding mode issues, ill-conditioned inputs, or a numerically unstable algorithm."
msgstr ""

#: ../../library/decimal.rst:2020
msgid "Q. I noticed that context precision is applied to the results of operations but not to the inputs.  Is there anything to watch out for when mixing values of different precisions?"
msgstr ""

#: ../../library/decimal.rst:2024
msgid "A. Yes.  The principle is that all values are considered to be exact and so is the arithmetic on those values.  Only the results are rounded.  The advantage for inputs is that \"what you type is what you get\".  A disadvantage is that the results can look odd if you forget that the inputs haven't been rounded:"
msgstr ""

#: ../../library/decimal.rst:2037
msgid "The solution is either to increase precision or to force rounding of inputs using the unary plus operation:"
msgstr ""

#: ../../library/decimal.rst:2046
msgid "Alternatively, inputs can be rounded upon creation using the :meth:`Context.create_decimal` method:"
msgstr ""

