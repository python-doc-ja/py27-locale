# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2017, Python Software Foundation (translated by Python ドキュメント日本語翻訳プロジェクト)
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 2.7\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../library/sets.rst:3
msgid ":mod:`sets` --- Unordered collections of unique elements"
msgstr ""

#: ../../library/sets.rst:16
msgid "The built-in :class:`set`/:class:`frozenset` types replace this module."
msgstr ""

#: ../../library/sets.rst:19
msgid "The :mod:`sets` module provides classes for constructing and manipulating unordered collections of unique elements.  Common uses include membership testing, removing duplicates from a sequence, and computing standard math operations on sets such as intersection, union, difference, and symmetric difference."
msgstr ""

#: ../../library/sets.rst:25
msgid "Like other collections, sets support ``x in set``, ``len(set)``, and ``for x in set``.  Being an unordered collection, sets do not record element position or order of insertion.  Accordingly, sets do not support indexing, slicing, or other sequence-like behavior."
msgstr ""

#: ../../library/sets.rst:30
msgid "Most set applications use the :class:`Set` class which provides every set method except for :meth:`__hash__`. For advanced applications requiring a hash method, the :class:`ImmutableSet` class adds a :meth:`__hash__` method but omits methods which alter the contents of the set. Both :class:`Set` and :class:`ImmutableSet` derive from :class:`BaseSet`, an abstract class useful for determining whether something is a set: ``isinstance(obj, BaseSet)``."
msgstr ""

#: ../../library/sets.rst:37
msgid "The set classes are implemented using dictionaries.  Accordingly, the requirements for set elements are the same as those for dictionary keys; namely, that the element defines both :meth:`__eq__` and :meth:`__hash__`. As a result, sets cannot contain mutable elements such as lists or dictionaries. However, they can contain immutable collections such as tuples or instances of :class:`ImmutableSet`.  For convenience in implementing sets of sets, inner sets are automatically converted to immutable form, for example, ``Set([Set(['dog'])])`` is transformed to ``Set([ImmutableSet(['dog'])])``."
msgstr ""

#: ../../library/sets.rst:49
msgid "Constructs a new empty :class:`Set` object.  If the optional *iterable* parameter is supplied, updates the set with elements obtained from iteration. All of the elements in *iterable* should be immutable or be transformable to an immutable using the protocol described in section :ref:`immutable-transforms`."
msgstr ""

#: ../../library/sets.rst:57
msgid "Constructs a new empty :class:`ImmutableSet` object.  If the optional *iterable* parameter is supplied, updates the set with elements obtained from iteration. All of the elements in *iterable* should be immutable or be transformable to an immutable using the protocol described in section :ref:`immutable-transforms`."
msgstr ""

#: ../../library/sets.rst:62
msgid "Because :class:`ImmutableSet` objects provide a :meth:`__hash__` method, they can be used as set elements or as dictionary keys.  :class:`ImmutableSet` objects do not have methods for adding or removing elements, so all of the elements must be known when the constructor is called."
msgstr ""

#: ../../library/sets.rst:71
msgid "Set Objects"
msgstr ""

#: ../../library/sets.rst:73
msgid "Instances of :class:`Set` and :class:`ImmutableSet` both provide the following operations:"
msgstr ""

#: ../../library/sets.rst:77
#: ../../library/sets.rst:138
#: ../../library/sets.rst:147
msgid "Operation"
msgstr ""

#: ../../library/sets.rst:77
#: ../../library/sets.rst:147
msgid "Equivalent"
msgstr ""

#: ../../library/sets.rst:77
#: ../../library/sets.rst:138
#: ../../library/sets.rst:147
msgid "Result"
msgstr ""

#: ../../library/sets.rst:79
msgid "``len(s)``"
msgstr ""

#: ../../library/sets.rst:79
msgid "cardinality of set *s*"
msgstr ""

#: ../../library/sets.rst:81
msgid "``x in s``"
msgstr ""

#: ../../library/sets.rst:81
msgid "test *x* for membership in *s*"
msgstr ""

#: ../../library/sets.rst:83
msgid "``x not in s``"
msgstr ""

#: ../../library/sets.rst:83
msgid "test *x* for non-membership in *s*"
msgstr ""

#: ../../library/sets.rst:86
msgid "``s.issubset(t)``"
msgstr ""

#: ../../library/sets.rst:86
msgid "``s <= t``"
msgstr ""

#: ../../library/sets.rst:86
msgid "test whether every element in *s* is in *t*"
msgstr ""

#: ../../library/sets.rst:89
msgid "``s.issuperset(t)``"
msgstr ""

#: ../../library/sets.rst:89
msgid "``s >= t``"
msgstr ""

#: ../../library/sets.rst:89
msgid "test whether every element in *t* is in *s*"
msgstr ""

#: ../../library/sets.rst:92
msgid "``s.union(t)``"
msgstr ""

#: ../../library/sets.rst:92
msgid "``s | t``"
msgstr ""

#: ../../library/sets.rst:92
msgid "new set with elements from both *s* and *t*"
msgstr ""

#: ../../library/sets.rst:95
msgid "``s.intersection(t)``"
msgstr ""

#: ../../library/sets.rst:95
msgid "``s & t``"
msgstr ""

#: ../../library/sets.rst:95
msgid "new set with elements common to *s* and *t*"
msgstr ""

#: ../../library/sets.rst:98
msgid "``s.difference(t)``"
msgstr ""

#: ../../library/sets.rst:98
msgid "``s - t``"
msgstr ""

#: ../../library/sets.rst:98
msgid "new set with elements in *s* but not in *t*"
msgstr ""

#: ../../library/sets.rst:101
msgid "``s.symmetric_difference(t)``"
msgstr ""

#: ../../library/sets.rst:101
msgid "``s ^ t``"
msgstr ""

#: ../../library/sets.rst:101
msgid "new set with elements in either *s* or *t* but not both"
msgstr ""

#: ../../library/sets.rst:104
msgid "``s.copy()``"
msgstr ""

#: ../../library/sets.rst:104
msgid "new set with a shallow copy of *s*"
msgstr ""

#: ../../library/sets.rst:108
msgid "Note, the non-operator versions of :meth:`union`, :meth:`intersection`, :meth:`difference`, and :meth:`symmetric_difference` will accept any iterable as an argument. In contrast, their operator based counterparts require their arguments to be sets.  This precludes error-prone constructions like ``Set('abc') & 'cbs'`` in favor of the more readable ``Set('abc').intersection('cbs')``."
msgstr ""

#: ../../library/sets.rst:115
#: ../../library/sets.rst:181
msgid "Formerly all arguments were required to be sets."
msgstr ""

#: ../../library/sets.rst:118
msgid "In addition, both :class:`Set` and :class:`ImmutableSet` support set to set comparisons.  Two sets are equal if and only if every element of each set is contained in the other (each is a subset of the other). A set is less than another set if and only if the first set is a proper subset of the second set (is a subset, but is not equal). A set is greater than another set if and only if the first set is a proper superset of the second set (is a superset, but is not equal)."
msgstr ""

#: ../../library/sets.rst:126
msgid "The subset and equality comparisons do not generalize to a complete ordering function.  For example, any two disjoint sets are not equal and are not subsets of each other, so *all* of the following return ``False``:  ``a<b``, ``a==b``, or ``a>b``. Accordingly, sets do not implement the :meth:`__cmp__` method."
msgstr ""

#: ../../library/sets.rst:131
msgid "Since sets only define partial ordering (subset relationships), the output of the :meth:`list.sort` method is undefined for lists of sets."
msgstr ""

#: ../../library/sets.rst:134
msgid "The following table lists operations available in :class:`ImmutableSet` but not found in :class:`Set`:"
msgstr ""

#: ../../library/sets.rst:140
msgid "``hash(s)``"
msgstr ""

#: ../../library/sets.rst:140
msgid "returns a hash value for *s*"
msgstr ""

#: ../../library/sets.rst:143
msgid "The following table lists operations available in :class:`Set` but not found in :class:`ImmutableSet`:"
msgstr ""

#: ../../library/sets.rst:149
msgid "``s.update(t)``"
msgstr ""

#: ../../library/sets.rst:149
msgid "*s* \\|= *t*"
msgstr ""

#: ../../library/sets.rst:149
msgid "return set *s* with elements added from *t*"
msgstr ""

#: ../../library/sets.rst:152
msgid "``s.intersection_update(t)``"
msgstr ""

#: ../../library/sets.rst:152
msgid "*s* &= *t*"
msgstr ""

#: ../../library/sets.rst:152
msgid "return set *s* keeping only elements also found in *t*"
msgstr ""

#: ../../library/sets.rst:155
msgid "``s.difference_update(t)``"
msgstr ""

#: ../../library/sets.rst:155
msgid "*s* -= *t*"
msgstr ""

#: ../../library/sets.rst:155
msgid "return set *s* after removing elements found in *t*"
msgstr ""

#: ../../library/sets.rst:158
msgid "``s.symmetric_difference_update(t)``"
msgstr ""

#: ../../library/sets.rst:158
msgid "*s* ^= *t*"
msgstr ""

#: ../../library/sets.rst:158
msgid "return set *s* with elements from *s* or *t* but not both"
msgstr ""

#: ../../library/sets.rst:161
msgid "``s.add(x)``"
msgstr ""

#: ../../library/sets.rst:161
msgid "add element *x* to set *s*"
msgstr ""

#: ../../library/sets.rst:163
msgid "``s.remove(x)``"
msgstr ""

#: ../../library/sets.rst:163
msgid "remove *x* from set *s*; raises :exc:`KeyError` if not present"
msgstr ""

#: ../../library/sets.rst:166
msgid "``s.discard(x)``"
msgstr ""

#: ../../library/sets.rst:166
msgid "removes *x* from set *s* if present"
msgstr ""

#: ../../library/sets.rst:169
msgid "``s.pop()``"
msgstr ""

#: ../../library/sets.rst:169
msgid "remove and return an arbitrary element from *s*; raises :exc:`KeyError` if empty"
msgstr ""

#: ../../library/sets.rst:173
msgid "``s.clear()``"
msgstr ""

#: ../../library/sets.rst:173
msgid "remove all elements from set *s*"
msgstr ""

#: ../../library/sets.rst:177
msgid "Note, the non-operator versions of :meth:`update`, :meth:`intersection_update`, :meth:`difference_update`, and :meth:`symmetric_difference_update` will accept any iterable as an argument."
msgstr ""

#: ../../library/sets.rst:184
msgid "Also note, the module also includes a :meth:`union_update` method which is an alias for :meth:`update`.  The method is included for backwards compatibility. Programmers should prefer the :meth:`update` method because it is supported by the built-in :class:`set()` and :class:`frozenset()` types."
msgstr ""

#: ../../library/sets.rst:193
msgid "Example"
msgstr ""

#: ../../library/sets.rst:223
msgid "Protocol for automatic conversion to immutable"
msgstr ""

#: ../../library/sets.rst:225
msgid "Sets can only contain immutable elements.  For convenience, mutable :class:`Set` objects are automatically copied to an :class:`ImmutableSet` before being added as a set element."
msgstr ""

#: ../../library/sets.rst:229
msgid "The mechanism is to always add a :term:`hashable` element, or if it is not hashable, the element is checked to see if it has an :meth:`__as_immutable__` method which returns an immutable equivalent."
msgstr ""

#: ../../library/sets.rst:233
msgid "Since :class:`Set` objects have a :meth:`__as_immutable__` method returning an instance of :class:`ImmutableSet`, it is possible to construct sets of sets."
msgstr ""

#: ../../library/sets.rst:236
msgid "A similar mechanism is needed by the :meth:`__contains__` and :meth:`remove` methods which need to hash an element to check for membership in a set.  Those methods check an element for hashability and, if not, check for a :meth:`__as_temporarily_immutable__` method which returns the element wrapped by a class that provides temporary methods for :meth:`__hash__`, :meth:`__eq__`, and :meth:`__ne__`."
msgstr ""

#: ../../library/sets.rst:243
msgid "The alternate mechanism spares the need to build a separate copy of the original mutable object."
msgstr ""

#: ../../library/sets.rst:246
msgid ":class:`Set` objects implement the :meth:`__as_temporarily_immutable__` method which returns the :class:`Set` object wrapped by a new class :class:`_TemporarilyImmutableSet`."
msgstr ""

#: ../../library/sets.rst:250
msgid "The two mechanisms for adding hashability are normally invisible to the user; however, a conflict can arise in a multi-threaded environment where one thread is updating a set while another has temporarily wrapped it in :class:`_TemporarilyImmutableSet`.  In other words, sets of mutable sets are not thread-safe."
msgstr ""

#: ../../library/sets.rst:260
msgid "Comparison to the built-in :class:`set` types"
msgstr ""

#: ../../library/sets.rst:262
msgid "The built-in :class:`set` and :class:`frozenset` types were designed based on lessons learned from the :mod:`sets` module.  The key differences are:"
msgstr ""

#: ../../library/sets.rst:265
msgid ":class:`Set` and :class:`ImmutableSet` were renamed to :class:`set` and :class:`frozenset`."
msgstr ""

#: ../../library/sets.rst:268
msgid "There is no equivalent to :class:`BaseSet`.  Instead, use ``isinstance(x, (set, frozenset))``."
msgstr ""

#: ../../library/sets.rst:271
msgid "The hash algorithm for the built-ins performs significantly better (fewer collisions) for most datasets."
msgstr ""

#: ../../library/sets.rst:274
msgid "The built-in versions have more space efficient pickles."
msgstr ""

#: ../../library/sets.rst:276
msgid "The built-in versions do not have a :meth:`union_update` method. Instead, use the :meth:`update` method which is equivalent."
msgstr ""

#: ../../library/sets.rst:279
msgid "The built-in versions do not have a ``_repr(sorted=True)`` method. Instead, use the built-in :func:`repr` and :func:`sorted` functions: ``repr(sorted(s))``."
msgstr ""

#: ../../library/sets.rst:283
msgid "The built-in version does not have a protocol for automatic conversion to immutable.  Many found this feature to be confusing and no one in the community reported having found real uses for it."
msgstr ""

