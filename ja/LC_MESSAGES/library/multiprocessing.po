# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2016, Python Software Foundation
# This file is distributed under the same license as the Python package.
# 
# Translators:
# Hiroaki Itoh <xwhhsprings@gmail.com>, 2016
msgid ""
msgstr ""
"Project-Id-Version: Python 2.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2016-01-01 17:54+0900\n"
"PO-Revision-Date: 2016-08-27 07:12+0000\n"
"Last-Translator: Hiroaki Itoh <xwhhsprings@gmail.com>\n"
"Language-Team: Japanese (http://www.transifex.com/python-doc-ja/python-27/language/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/multiprocessing.rst:2
msgid ":mod:`multiprocessing` --- Process-based \"threading\" interface"
msgstr ":mod:`multiprocessing` --- プロセスベースの \"並列処理\" インタフェース"

#: ../../library/multiprocessing.rst:11
msgid "Introduction"
msgstr "はじめに"

#: ../../library/multiprocessing.rst:13
msgid ""
":mod:`multiprocessing` is a package that supports spawning processes using "
"an API similar to the :mod:`threading` module.  The :mod:`multiprocessing` "
"package offers both local and remote concurrency, effectively side-stepping "
"the :term:`Global Interpreter Lock` by using subprocesses instead of "
"threads.  Due to this, the :mod:`multiprocessing` module allows the "
"programmer to fully leverage multiple processors on a given machine.  It "
"runs on both Unix and Windows."
msgstr ":mod:`multiprocessing` は、 :mod:`threading` と似た API で複数のプロセスを生成をサポートするパッケージです。 :mod:`multiprocessing` パッケージは、ローカルとリモート両方の並行処理を提供します。また、このパッケージはスレッドの代わりにサブプロセスを使用することにより、:term:`グローバルインタープリタロック <Global Interpreter Lock>` の問題を避ける工夫が行われています。このような特徴があるため :mod:`multiprocessing` モジュールを使うことで、マルチプロセッサーマシンの性能を最大限に活用することができるでしょう。なお、このモジュールは Unix と Windows で動作します。"

#: ../../library/multiprocessing.rst:21
msgid ""
"The :mod:`multiprocessing` module also introduces APIs which do not have "
"analogs in the :mod:`threading` module.  A prime example of this is the "
":class:`Pool` object which offers a convenient means of parallelizing the "
"execution of a function across multiple input values, distributing the input"
" data across processes (data parallelism).  The following example "
"demonstrates the common practice of defining such functions in a module so "
"that child processes can successfully import that module.  This basic "
"example of data parallelism using :class:`Pool`, ::"
msgstr ":mod:`multiprocessing` モジュールでは :mod:`threading` モジュールには似たものがない API も導入しています。その最たるものが :class:`~multiprocessing.pool.Pool` オブジェクトです。これは複数の入力データに対して、サブプロセス群に入力データを分配して並列に関数実行する (データ並列) のに便利な手段を提供します。以下の例では、モジュール内で関数を定義するのに、子プロセスがそのモジュールをつつがなくインポート出来るようにする一般的な慣例を使っています。 :class:`~multiprocessing.pool.Pool` を用いたデータ並列の基礎的な実例はこのようなものです::"

#: ../../library/multiprocessing.rst:39
msgid "will print to standard output ::"
msgstr "標準出力に以下が出力されます::"

#: ../../library/multiprocessing.rst:45
msgid "The :class:`Process` class"
msgstr ":class:`Process` クラス"

#: ../../library/multiprocessing.rst:47
msgid ""
"In :mod:`multiprocessing`, processes are spawned by creating a "
":class:`Process` object and then calling its :meth:`~Process.start` method."
"  :class:`Process` follows the API of :class:`threading.Thread`.  A trivial "
"example of a multiprocess program is ::"
msgstr ":mod:`multiprocessing` モジュールでは、プロセスは以下の手順によって生成されます。はじめに :class:`Process` のオブジェクトを作成し、続いて :meth:`~Process.start` メソッドを呼び出します。この :class:`Process` クラスは :class:`threading.Thread` クラスと同様の API を持っています。まずは、簡単な例をもとにマルチプロセスを使用したプログラムについてみていきましょう ::"

#: ../../library/multiprocessing.rst:62
msgid ""
"To show the individual process IDs involved, here is an expanded example::"
msgstr "実行された個々のプロセス ID を表示するために拡張したサンプルコードを以下に例を示します::"

#: ../../library/multiprocessing.rst:84
msgid ""
"For an explanation of why (on Windows) the ``if __name__ == '__main__'`` "
"part is necessary, see :ref:`multiprocessing-programming`."
msgstr "(Windows 環境で) ``if __name__ == '__main__'`` という記述が必要な理由については、 :ref:`multiprocessing-programming` を参照してください。"

#: ../../library/multiprocessing.rst:89
msgid "Exchanging objects between processes"
msgstr "プロセス間でのオブジェクト交換"

#: ../../library/multiprocessing.rst:91
msgid ""
":mod:`multiprocessing` supports two types of communication channel between "
"processes:"
msgstr ":mod:`multiprocessing` モジュールでは、プロセス間通信の手段が2つ用意されています。それぞれ以下に詳細を示します:"

#: ../../library/multiprocessing.rst:94
msgid "**Queues**"
msgstr "**キュー (Queue)**"

#: ../../library/multiprocessing.rst:96
msgid ""
"The :class:`~multiprocessing.Queue` class is a near clone of "
":class:`Queue.Queue`.  For example::"
msgstr ":class:`~multiprocessing.Queue` クラスは :class:`Queue.Queue` クラスとほとんど同じように使うことができます。以下に例を示します。 ::"

#: ../../library/multiprocessing.rst:111
msgid "Queues are thread and process safe."
msgstr "キューはスレッドセーフであり、プロセスセーフです。"

#: ../../library/multiprocessing.rst:113
msgid "**Pipes**"
msgstr "**パイプ (Pipe)**"

#: ../../library/multiprocessing.rst:115
msgid ""
"The :func:`Pipe` function returns a pair of connection objects connected by "
"a pipe which by default is duplex (two-way).  For example::"
msgstr ":func:`Pipe` 関数はパイプで繋がれたコネクションオブジェクトのペアを返します。デフォルトでは双方向性パイプを返します。以下に例を示します::"

#: ../../library/multiprocessing.rst:131
msgid ""
"The two connection objects returned by :func:`Pipe` represent the two ends "
"of the pipe.  Each connection object has :meth:`~Connection.send` and "
":meth:`~Connection.recv` methods (among others).  Note that data in a pipe "
"may become corrupted if two processes (or threads) try to read from or write"
" to the *same* end of the pipe at the same time.  Of course there is no risk"
" of corruption from processes using different ends of the pipe at the same "
"time."
msgstr "パイプのそれぞれの端を表す2つのコネクションオブジェクトが :func:`Pipe` 関数から返されます。各コネクションオブジェクトには、 :meth:`~Connection.send`、 :meth:`~Connection.recv`、その他のメソッドがあります。2つのプロセス (またはスレッド) がパイプの *同じ* 端で同時に読み込みや書き込みを行うと、パイプ内のデータが破損してしまうかもしれないことに注意してください。もちろん、各プロセスがパイプの別々の端を同時に使用するならば、データが破壊される危険性はありません。"

#: ../../library/multiprocessing.rst:141
msgid "Synchronization between processes"
msgstr "プロセス間の同期"

#: ../../library/multiprocessing.rst:143
msgid ""
":mod:`multiprocessing` contains equivalents of all the synchronization "
"primitives from :mod:`threading`.  For instance one can use a lock to ensure"
" that only one process prints to standard output at a time::"
msgstr ":mod:`multiprocessing` は :mod:`threading` モジュールと等価な同期プリミティブを備えています。以下の例では、ロックを使用して、一度に1つのプロセスしか標準出力に書き込まないようにしています::"

#: ../../library/multiprocessing.rst:160
msgid ""
"Without using the lock output from the different processes is liable to get "
"all mixed up."
msgstr "ロックを使用しないで標準出力に書き込んだ場合は、各プロセスからの出力がごちゃまぜになってしまいます。"

#: ../../library/multiprocessing.rst:165
msgid "Sharing state between processes"
msgstr "プロセス間での状態の共有"

#: ../../library/multiprocessing.rst:167
msgid ""
"As mentioned above, when doing concurrent programming it is usually best to "
"avoid using shared state as far as possible.  This is particularly true when"
" using multiple processes."
msgstr "これまでの話の流れで触れたとおり、並行プログラミングを行うときには、できるかぎり状態を共有しないのが定石です。複数のプロセスを使用するときは特にそうでしょう。"

#: ../../library/multiprocessing.rst:171
msgid ""
"However, if you really do need to use some shared data then "
":mod:`multiprocessing` provides a couple of ways of doing so."
msgstr "しかし、どうしてもプロセス間のデータ共有が必要な場合のために :mod:`multiprocessing` モジュールには2つの方法が用意されています。"

#: ../../library/multiprocessing.rst:174
msgid "**Shared memory**"
msgstr "**共有メモリ (Shared memory)**"

#: ../../library/multiprocessing.rst:176
msgid ""
"Data can be stored in a shared memory map using :class:`Value` or "
":class:`Array`.  For example, the following code ::"
msgstr "データを共有メモリ上に保持するために :class:`Value` クラス、もしくは :class:`Array` クラスを使用することができます。以下のサンプルコードを使って、この機能についてみていきましょう ::"

#: ../../library/multiprocessing.rst:197 ../../library/multiprocessing.rst:244
msgid "will print ::"
msgstr "このサンプルコードを実行すると以下のように表示されます ::"

#: ../../library/multiprocessing.rst:202
msgid ""
"The ``'d'`` and ``'i'`` arguments used when creating ``num`` and ``arr`` are"
" typecodes of the kind used by the :mod:`array` module: ``'d'`` indicates a "
"double precision float and ``'i'`` indicates a signed integer.  These shared"
" objects will be process and thread-safe."
msgstr "``num`` と ``arr`` を生成するときに使用されている、引数 ``'d'`` と ``'i'`` は :mod:`array` モジュールにより使用される種別の型コードです。ここで使用されている ``'d'`` は倍精度浮動小数、 ``'i'`` は符号付整数を表します。これらの共有オブジェクトは、プロセスセーフでありスレッドセーフです。"

#: ../../library/multiprocessing.rst:207
msgid ""
"For more flexibility in using shared memory one can use the "
":mod:`multiprocessing.sharedctypes` module which supports the creation of "
"arbitrary ctypes objects allocated from shared memory."
msgstr "共有メモリを使用して、さらに柔軟なプログラミングを行うには :mod:`multiprocessing.sharedctypes` モジュールを使用します。このモジュールは共有メモリから割り当てられた任意の ctypes オブジェクトの生成をサポートします。"

#: ../../library/multiprocessing.rst:211
msgid "**Server process**"
msgstr "**サーバープロセス (Server process)**"

#: ../../library/multiprocessing.rst:213
msgid ""
"A manager object returned by :func:`Manager` controls a server process which"
" holds Python objects and allows other processes to manipulate them using "
"proxies."
msgstr ":func:`Manager` 関数により生成されたマネージャーオブジェクトはサーバープロセスを管理します。マネージャーオブジェクトは Python のオブジェクトを保持して、他のプロセスがプロキシ経由でその Python オブジェクトを操作することができます。"

#: ../../library/multiprocessing.rst:217
msgid ""
"A manager returned by :func:`Manager` will support types :class:`list`, "
":class:`dict`, :class:`Namespace`, :class:`Lock`, :class:`RLock`, "
":class:`Semaphore`, :class:`BoundedSemaphore`, :class:`Condition`, "
":class:`Event`, :class:`~multiprocessing.Queue`, :class:`Value` and "
":class:`Array`.  For example, ::"
msgstr ":func:`Manager` 関数が返すマネージャは :class:`list` 、 :class:`dict` 、 :class:`Namespace` 、 :class:`Lock` 、 :class:`RLock` 、 :class:`Semaphore` 、 :class:`BoundedSemaphore` 、 :class:`Condition` 、 :class:`Event` 、 :class:`~multiprocessing.Queue` 、 :class:`Value` 、 :class:`Array` をサポートします。以下にサンプルコードを示します。 ::"

#: ../../library/multiprocessing.rst:249
msgid ""
"Server process managers are more flexible than using shared memory objects "
"because they can be made to support arbitrary object types.  Also, a single "
"manager can be shared by processes on different computers over a network. "
"They are, however, slower than using shared memory."
msgstr "サーバープロセスのマネージャーオブジェクトは共有メモリのオブジェクトよりも柔軟であるといえます。それは、どのような型のオブジェクトでも使えるからです。また、1つのマネージャーオブジェクトはネットワーク経由で他のコンピューター上のプロセスによって共有することもできます。しかし、共有メモリより動作が遅いという欠点があります。"

#: ../../library/multiprocessing.rst:256
msgid "Using a pool of workers"
msgstr "ワーカープロセスのプールを使用"

#: ../../library/multiprocessing.rst:258
msgid ""
"The :class:`~multiprocessing.pool.Pool` class represents a pool of worker "
"processes.  It has methods which allows tasks to be offloaded to the worker "
"processes in a few different ways."
msgstr ":class:`~multiprocessing.pool.Pool` クラスは、ワーカープロセスをプールする機能を備えています。このクラスには、異なる方法でワーカープロセスへタスクを割り当てるいくつかのメソッドがあります。"

#: ../../library/multiprocessing.rst:262
msgid "For example::"
msgstr "例えば::"

#: ../../library/multiprocessing.rst:275
msgid ""
"Note that the methods of a pool should only ever be used by the process "
"which created it."
msgstr "プールオブジェクトのメソッドは、そのプールを作成したプロセスのみが呼び出すべきです。"

#: ../../library/multiprocessing.rst:280
msgid ""
"Functionality within this package requires that the ``__main__`` module be "
"importable by the children. This is covered in :ref:`multiprocessing-"
"programming` however it is worth pointing out here. This means that some "
"examples, such as the :class:`Pool` examples will not work in the "
"interactive interpreter. For example::"
msgstr "このパッケージに含まれる機能を使用するためには、子プロセスから ``__main__`` モジュールをインポートできる必要があります。このことについては :ref:`multiprocessing-programming` で触れていますが、ここであらためて強調しておきます。なぜかというと、いくつかのサンプルコード、例えば :class:`multiprocessing.pool.Pool` のサンプルはインタラクティブシェル上では動作しないからです。以下に例を示します::"

#: ../../library/multiprocessing.rst:302
msgid ""
"(If you try this it will actually output three full tracebacks interleaved "
"in a semi-random fashion, and then you may have to stop the master process "
"somehow.)"
msgstr "(このサンプルを試すと、3つのトレースバックすべてがほぼランダムに交互に重なって表示されます。そうなったら、なんとかしてマスタープロセスを止めましょう。)"

#: ../../library/multiprocessing.rst:308
msgid "Reference"
msgstr "リファレンス"

#: ../../library/multiprocessing.rst:310
msgid ""
"The :mod:`multiprocessing` package mostly replicates the API of the "
":mod:`threading` module."
msgstr ":mod:`multiprocessing` パッケージは :mod:`threading` モジュールの API とほとんど同じです。"

#: ../../library/multiprocessing.rst:315
msgid ":class:`Process` and exceptions"
msgstr ":class:`Process` クラスと例外"

#: ../../library/multiprocessing.rst:319
msgid ""
"Process objects represent activity that is run in a separate process. The "
":class:`Process` class has equivalents of all the methods of "
":class:`threading.Thread`."
msgstr "Process オブジェクトは各プロセスの処理を表します。 :class:`Process` クラスは :class:`threading.Thread` クラスのすべてのメソッドと同じインタフェースを提供します。"

#: ../../library/multiprocessing.rst:323
msgid ""
"The constructor should always be called with keyword arguments. *group* "
"should always be ``None``; it exists solely for compatibility with "
":class:`threading.Thread`.  *target* is the callable object to be invoked by"
" the :meth:`run()` method.  It defaults to ``None``, meaning nothing is "
"called. *name* is the process name.  By default, a unique name is "
"constructed of the form 'Process-N\\ :sub:`1`:N\\ :sub:`2`:...:N\\ :sub:`k`'"
" where N\\ :sub:`1`,N\\ :sub:`2`,...,N\\ :sub:`k` is a sequence of integers "
"whose length is determined by the *generation* of the process.  *args* is "
"the argument tuple for the target invocation.  *kwargs* is a dictionary of "
"keyword arguments for the target invocation.  By default, no arguments are "
"passed to *target*."
msgstr "コンストラクタは必ずキーワード引数で呼び出すべきです。引数 *group* には必ず ``None`` を渡してください。この引数は :class:`threading.Thread` クラスとの互換性のためだけに残されています。引数 *target* には、呼び出し可能オブジェクト (Callable Object) を渡します。このオブジェクトは :meth:`run()` メソッドから呼び出されます。この引数はデフォルトで ``None`` となっており、何も呼び出されません。引数 *name* にはプロセス名を渡します。デフォルトでは、自動でユニークな名前が割り当てられます。命名規則は、 'Process-N\\ :sub:`1`:N\\ :sub:`2`:...:N\\ :sub:`k`' となります。ここで N\\ :sub:`1`,N\\ :sub:`2`,...,N\\ :sub:`k` は整数の数列で、 *作成した* プロセス数に対応します。引数 *args* は target で指定された呼び出し可能オブジェクトへの引数を渡します。同じく、引数 *kwargs* はキーワード引数を渡します。デフォルトでは、 *target* には引数が渡されないようになっています。"

#: ../../library/multiprocessing.rst:335
msgid ""
"If a subclass overrides the constructor, it must make sure it invokes the "
"base class constructor (:meth:`Process.__init__`) before doing anything else"
" to the process."
msgstr "サブクラスがコンストラクターをオーバーライドする場合は、そのプロセスに対する処理を行う前に基底クラスのコンストラクター (:meth:`Process.__init__`) を実行しなければなりません。"

#: ../../library/multiprocessing.rst:341
msgid "Method representing the process's activity."
msgstr "プロセスが実行する処理を表すメソッドです。"

#: ../../library/multiprocessing.rst:343
msgid ""
"You may override this method in a subclass.  The standard :meth:`run` method"
" invokes the callable object passed to the object's constructor as the "
"target argument, if any, with sequential and keyword arguments taken from "
"the *args* and *kwargs* arguments, respectively."
msgstr "このメソッドはサブクラスでオーバーライドすることができます。標準の :meth:`run` メソッドは、コンストラクターの target 引数として渡された呼び出し可能オブジェクトを呼び出します。もしコンストラクターに *args* もしくは *kwargs* 引数が渡されていれば、呼び出すオブジェクトにこれらの引数を渡します。"

#: ../../library/multiprocessing.rst:350
msgid "Start the process's activity."
msgstr "プロセスの処理を開始するためのメソッドです。"

#: ../../library/multiprocessing.rst:352
msgid ""
"This must be called at most once per process object.  It arranges for the "
"object's :meth:`run` method to be invoked in a separate process."
msgstr "各 Process オブジェクトに対し、このメソッドが2回以上呼び出されてはいけません。各プロセスでオブジェクトの :meth:`run` メソッドを呼び出す準備を行います。"

#: ../../library/multiprocessing.rst:357
msgid ""
"Block the calling thread until the process whose :meth:`join` method is "
"called terminates or until the optional timeout occurs."
msgstr ":meth:`join` されたプロセスが terminate を呼び出すまで、もしくはオプションで指定したタイムアウトが発生するまで呼び出し側のスレッドをブロックします。"

#: ../../library/multiprocessing.rst:360
msgid "If *timeout* is ``None`` then there is no timeout."
msgstr "*timeout* が ``None`` ならタイムアウトは設定されません。"

#: ../../library/multiprocessing.rst:362
msgid "A process can be joined many times."
msgstr "1つのプロセスは何回も join されることができます。"

#: ../../library/multiprocessing.rst:364
msgid ""
"A process cannot join itself because this would cause a deadlock.  It is an "
"error to attempt to join a process before it has been started."
msgstr "プロセスは自分自身を join することはできません。それはデッドロックを引き起こすことがあるからです。プロセスが start される前に join しようとするとエラーが発生します。"

#: ../../library/multiprocessing.rst:369
msgid "The process's name."
msgstr "プロセス名です。"

#: ../../library/multiprocessing.rst:371
msgid ""
"The name is a string used for identification purposes only.  It has no "
"semantics.  Multiple processes may be given the same name.  The initial name"
" is set by the constructor."
msgstr "この名前は文字列で、プロセスの識別にのみ使用されます。特別な命名規則はありません。複数のプロセスが同じ名前を持つ場合もあります。また、この名前はコンストラクタにより初期化されます。"

#: ../../library/multiprocessing.rst:377
msgid "Return whether the process is alive."
msgstr "プロセスが実行中かを判別します。"

#: ../../library/multiprocessing.rst:379
msgid ""
"Roughly, a process object is alive from the moment the :meth:`start` method "
"returns until the child process terminates."
msgstr "おおまかに言って、プロセスオブジェクトは :meth:`start` メソッドを呼び出してから子プロセス終了までの期間が実行中となります。"

#: ../../library/multiprocessing.rst:384
msgid ""
"The process's daemon flag, a Boolean value.  This must be set before "
":meth:`start` is called."
msgstr "デーモンプロセスであるかのフラグであり、ブール値です。この属性は :meth:`start` が呼び出される前に設定されている必要があります。"

#: ../../library/multiprocessing.rst:387
msgid "The initial value is inherited from the creating process."
msgstr "初期値は作成するプロセスから継承します。"

#: ../../library/multiprocessing.rst:389
msgid ""
"When a process exits, it attempts to terminate all of its daemonic child "
"processes."
msgstr "あるプロセスが終了するとき、そのプロセスはその子プロセスであるデーモンプロセスすべてを終了させようとします。"

#: ../../library/multiprocessing.rst:392
msgid ""
"Note that a daemonic process is not allowed to create child processes. "
"Otherwise a daemonic process would leave its children orphaned if it gets "
"terminated when its parent process exits. Additionally, these are **not** "
"Unix daemons or services, they are normal processes that will be terminated "
"(and not joined) if non-daemonic processes have exited."
msgstr "デーモンプロセスは子プロセスを作成できないことに注意してください。もし作成できてしまうと、そのデーモンプロセスの親プロセスが終了したときにデーモンプロセスの子プロセスが孤児になってしまう場合があるからです。さらに言えば、デーモンプロセスはUnix デーモンやサービスでは **なく** 通常のプロセスであり、非デーモンプロセスが終了すると終了されます (そして join されません)。"

#: ../../library/multiprocessing.rst:398
msgid ""
"In addition to the  :class:`threading.Thread` API, :class:`Process` objects "
"also support the following attributes and methods:"
msgstr ":class:`threading.Thread` クラスの API に加えて :class:`Process` クラスのオブジェクトには以下の属性およびメソッドがあります:"

#: ../../library/multiprocessing.rst:403
msgid ""
"Return the process ID.  Before the process is spawned, this will be "
"``None``."
msgstr "プロセスIDを返します。プロセスの生成前は ``None`` が設定されています。"

#: ../../library/multiprocessing.rst:408
msgid ""
"The child's exit code.  This will be ``None`` if the process has not yet "
"terminated.  A negative value *-N* indicates that the child was terminated "
"by signal *N*."
msgstr "子プロセスの終了コードです。子プロセスがまだ終了していない場合は ``None`` が返されます。負の値 *-N* は子プロセスがシグナル *N* で終了したことを表します。"

#: ../../library/multiprocessing.rst:414
msgid "The process's authentication key (a byte string)."
msgstr "プロセスの認証キーです (バイト文字列です)。"

#: ../../library/multiprocessing.rst:416
msgid ""
"When :mod:`multiprocessing` is initialized the main process is assigned a "
"random string using :func:`os.urandom`."
msgstr ":mod:`multiprocessing` モジュールがメインプロセスにより初期化される場合には、 :func:`os.urandom` 関数を使用してランダムな値が設定されます。"

#: ../../library/multiprocessing.rst:419
msgid ""
"When a :class:`Process` object is created, it will inherit the "
"authentication key of its parent process, although this may be changed by "
"setting :attr:`authkey` to another byte string."
msgstr ":class:`Process` クラスのオブジェクトの作成時にその親プロセスから認証キーを継承します。もしくは :attr:`authkey` に別のバイト文字列を設定することもできます。"

#: ../../library/multiprocessing.rst:423
msgid "See :ref:`multiprocessing-auth-keys`."
msgstr "詳細は :ref:`multiprocessing-auth-keys` を参照してください。"

#: ../../library/multiprocessing.rst:427
msgid ""
"Terminate the process.  On Unix this is done using the ``SIGTERM`` signal; "
"on Windows :c:func:`TerminateProcess` is used.  Note that exit handlers and "
"finally clauses, etc., will not be executed."
msgstr "プロセスを終了します。Unix 環境では ``SIGTERM`` シグナルを、 Windows 環境では :c:func:`TerminateProcess` を使用して終了させます。終了ハンドラーや finally 節などは、実行されないことに注意してください。"

#: ../../library/multiprocessing.rst:431
msgid ""
"Note that descendant processes of the process will *not* be terminated -- "
"they will simply become orphaned."
msgstr "このメソッドにより終了するプロセスの子孫プロセスは、終了 *しません* 。そういった子孫プロセスは単純に孤児になります。"

#: ../../library/multiprocessing.rst:436
msgid ""
"If this method is used when the associated process is using a pipe or queue "
"then the pipe or queue is liable to become corrupted and may become unusable"
" by other process.  Similarly, if the process has acquired a lock or "
"semaphore etc. then terminating it is liable to cause other processes to "
"deadlock."
msgstr "このメソッドの使用時に、関連付けられたプロセスがパイプやキューを使用している場合には、使用中のパイプやキューが破損して他のプロセスから使用できなくなる可能性があります。同様に、プロセスがロックやセマフォなどを取得している場合には、このプロセスが終了してしまうと他のプロセスのデッドロックの原因になるでしょう。"

#: ../../library/multiprocessing.rst:442
msgid ""
"Note that the :meth:`start`, :meth:`join`, :meth:`is_alive`, "
":meth:`terminate` and :attr:`exitcode` methods should only be called by the "
"process that created the process object."
msgstr "プロセスオブジェクトが作成したプロセスのみが :meth:`start`, :meth:`join`, :meth:`is_alive`, :meth:`terminate` と :attr:`exitcode` のメソッドを呼び出すべきです。"

#: ../../library/multiprocessing.rst:446
msgid "Example usage of some of the methods of :class:`Process`:"
msgstr "以下の例では :class:`Process` のメソッドの使い方を示しています:"

#: ../../library/multiprocessing.rst:467
msgid ""
"Exception raised by :meth:`Connection.recv_bytes_into()` when the supplied "
"buffer object is too small for the message read."
msgstr "この例外は :meth:`Connection.recv_bytes_into()` によって発生し、バッファーオブジェクトが小さすぎてメッセージが読み込めないことを示します。"

#: ../../library/multiprocessing.rst:470
msgid ""
"If ``e`` is an instance of :exc:`BufferTooShort` then ``e.args[0]`` will "
"give the message as a byte string."
msgstr "``e`` が :exc:`BufferTooShort` のインスタンスとすると、 ``e.args[0]`` はバイト文字列でそのメッセージを取得できます。"

#: ../../library/multiprocessing.rst:475
msgid "Pipes and Queues"
msgstr "パイプ (Pipe) とキュー (Queue)"

#: ../../library/multiprocessing.rst:477
msgid ""
"When using multiple processes, one generally uses message passing for "
"communication between processes and avoids having to use any synchronization"
" primitives like locks."
msgstr "複数のプロセスを使う場合、一般的にはメッセージパッシングをプロセス間通信に使用し、ロックのような同期プリミティブを使用しないようにします。"

#: ../../library/multiprocessing.rst:481
msgid ""
"For passing messages one can use :func:`Pipe` (for a connection between two "
"processes) or a queue (which allows multiple producers and consumers)."
msgstr "メッセージのやりとりのために :func:`Pipe` (2つのプロセス間の通信用)、もしくはキュー (複数のメッセージ生成プロセス (producer)、消費プロセス (consumer) の実現用) を使うことができます。"

#: ../../library/multiprocessing.rst:484
msgid ""
"The :class:`~multiprocessing.Queue`, "
":class:`multiprocessing.queues.SimpleQueue` and :class:`JoinableQueue` types"
" are multi-producer, multi-consumer FIFO queues modelled on the "
":class:`Queue.Queue` class in the standard library.  They differ in that "
":class:`~multiprocessing.Queue` lacks the :meth:`~Queue.Queue.task_done` and"
" :meth:`~Queue.Queue.join` methods introduced into Python 2.5's "
":class:`Queue.Queue` class."
msgstr ":class:`~multiprocessing.Queue`, :class:`multiprocessing.queues.SimpleQueue`, :class:`JoinableQueue` は複数プロセスから生成/消費を行う FIFO キューです。これらのキューは標準ライブラリの :class:`Queue.Queue` を模倣しています。 :class:`~multiprocessing.Queue` には Python 2.5 の :class:`Queue.Queue` クラスで導入された :meth:`~Queue.Queue.task_done` と :meth:`~Queue.Queue.join` メソッドがないことが違う点です。"

#: ../../library/multiprocessing.rst:490
msgid ""
"If you use :class:`JoinableQueue` then you **must** call "
":meth:`JoinableQueue.task_done` for each task removed from the queue or else"
" the semaphore used to count the number of unfinished tasks may eventually "
"overflow, raising an exception."
msgstr "もし :class:`JoinableQueue` を使用するなら、キューから削除される各タスクのために :meth:`JoinableQueue.task_done` を呼び出さなければ **なりません** 。さもないと、いつか完了していないタスクを数えるためのセマフォがオーバーフローし、例外を発生させるでしょう。"

#: ../../library/multiprocessing.rst:495
msgid ""
"Note that one can also create a shared queue by using a manager object -- "
"see :ref:`multiprocessing-managers`."
msgstr "管理オブジェクトを使用することで共有キューを作成できることも覚えておいてください。詳細は :ref:`multiprocessing-managers` を参照してください。"

#: ../../library/multiprocessing.rst:500
msgid ""
":mod:`multiprocessing` uses the usual :exc:`Queue.Empty` and "
":exc:`Queue.Full` exceptions to signal a timeout.  They are not available in"
" the :mod:`multiprocessing` namespace so you need to import them from "
":mod:`Queue`."
msgstr ":mod:`multiprocessing` は通常の :exc:`Queue.Empty` と、タイムアウトのシグナルを送るために :exc:`Queue.Full` 例外を使用します。それらは :mod:`Queue` からインポートする必要があるので :mod:`multiprocessing` の名前空間では利用できません。"

#: ../../library/multiprocessing.rst:507
msgid ""
"When an object is put on a queue, the object is pickled and a background "
"thread later flushes the pickled data to an underlying pipe.  This has some "
"consequences which are a little surprising, but should not cause any "
"practical difficulties -- if they really bother you then you can instead use"
" a queue created with a :ref:`manager <multiprocessing-managers>`."
msgstr "オブジェクトがキューに追加される際、そのオブジェクトは pickle 化されています。そのため、バックグラウンドのスレッドが後になって下位層のパイプに pickle 化されたデータをフラッシュすることがあります。これにより、少し驚くような結果になりますが、実際に問題になることはないはずです。これが問題になるような状況では、かわりに :ref:`manager <multiprocessing-managers>` を使ってキューを作成することができるからです。"

#: ../../library/multiprocessing.rst:514
msgid ""
"After putting an object on an empty queue there may be an infinitesimal "
"delay before the queue's :meth:`~Queue.empty` method returns :const:`False` "
"and :meth:`~Queue.get_nowait` can return without raising :exc:`Queue.Empty`."
msgstr "空のキューの中にオブジェクトを追加した後、キューの :meth:`~Queue.empty` メソッドが :const:`False` を返すまでの間にごくわずかな遅延が起きることがあり、:meth:`~Queue.get_nowait` が :exc:`Queue.Empty` を発生させることなく制御が呼び出し元に返ってしまうことがあります。"

#: ../../library/multiprocessing.rst:519
msgid ""
"If multiple processes are enqueuing objects, it is possible for the objects "
"to be received at the other end out-of-order. However, objects enqueued by "
"the same process will always be in the expected order with respect to each "
"other."
msgstr "複数のプロセスがオブジェクトをキューに詰めている場合、キューの反対側ではオブジェクトが詰められたのとは違う順序で取得される可能性があります。ただし、同一のプロセスから詰め込まれたオブジェクトは、それらのオブジェクト間では、必ず期待どおりの順序になります。"

#: ../../library/multiprocessing.rst:526
msgid ""
"If a process is killed using :meth:`Process.terminate` or :func:`os.kill` "
"while it is trying to use a :class:`~multiprocessing.Queue`, then the data "
"in the queue is likely to become corrupted.  This may cause any other "
"process to get an exception when it tries to use the queue later on."
msgstr ":class:`~multiprocessing.Queue` を利用しようとしている最中にプロセスを :meth:`Process.terminate` や :func:`os.kill` で終了させる場合、キューにあるデータは破損し易くなります。終了した後で他のプロセスがキューを利用しようとすると、例外を発生させる可能性があります。"

#: ../../library/multiprocessing.rst:533
msgid ""
"As mentioned above, if a child process has put items on a queue (and it has "
"not used :meth:`JoinableQueue.cancel_join_thread "
"<multiprocessing.Queue.cancel_join_thread>`), then that process will not "
"terminate until all buffered items have been flushed to the pipe."
msgstr "上述したように、もし子プロセスがキューへ要素を追加するなら (かつ :meth:`JoinableQueue.cancel_join_thread <multiprocessing.Queue.cancel_join_thread>` を使用しないなら) そのプロセスはバッファーされたすべての要素がパイプへフラッシュされるまで終了しません。"

#: ../../library/multiprocessing.rst:538
msgid ""
"This means that if you try joining that process you may get a deadlock "
"unless you are sure that all items which have been put on the queue have "
"been consumed.  Similarly, if the child process is non-daemonic then the "
"parent process may hang on exit when it tries to join all its non-daemonic "
"children."
msgstr "これは、そのプロセスを join しようとする場合、キューに追加されたすべての要素が消費されたことが確実でないかぎり、デッドロックを発生させる可能性があることを意味します。似たような現象で、子プロセスが非デーモンプロセスの場合、親プロセスは終了時に非デーモンのすべての子プロセスを join しようとしてハングアップする可能性があります。"

#: ../../library/multiprocessing.rst:543
msgid ""
"Note that a queue created using a manager does not have this issue.  See "
":ref:`multiprocessing-programming`."
msgstr "マネージャーを使用して作成されたキューではこの問題はありません。詳細は :ref:`multiprocessing-programming` を参照してください。"

#: ../../library/multiprocessing.rst:546
msgid ""
"For an example of the usage of queues for interprocess communication see "
":ref:`multiprocessing-examples`."
msgstr "プロセス間通信におけるキューの使用例を知りたいなら :ref:`multiprocessing-examples` を参照してください。"

#: ../../library/multiprocessing.rst:552
msgid ""
"Returns a pair ``(conn1, conn2)`` of :class:`Connection` objects "
"representing the ends of a pipe."
msgstr "パイプの両端を表す :class:`Connection` オブジェクトのペア ``(conn1, conn2)`` を返します。"

#: ../../library/multiprocessing.rst:555
msgid ""
"If *duplex* is ``True`` (the default) then the pipe is bidirectional.  If "
"*duplex* is ``False`` then the pipe is unidirectional: ``conn1`` can only be"
" used for receiving messages and ``conn2`` can only be used for sending "
"messages."
msgstr "*duplex* が ``True`` (デフォルト) ならパイプは双方向性です。*duplex* が ``False`` ならパイプは一方向性で、``conn1`` はメッセージの受信専用、``conn2`` はメッセージの送信専用になります。"

#: ../../library/multiprocessing.rst:563
msgid ""
"Returns a process shared queue implemented using a pipe and a few "
"locks/semaphores.  When a process first puts an item on the queue a feeder "
"thread is started which transfers objects from a buffer into the pipe."
msgstr "パイプや2～3個のロック/セマフォを使用して実装されたプロセス共有キューを返します。あるプロセスが最初に要素をキューへ追加するとき、バッファーからパイプの中へオブジェクトを転送する供給スレッドが開始されます。"

#: ../../library/multiprocessing.rst:567
msgid ""
"The usual :exc:`Queue.Empty` and :exc:`Queue.Full` exceptions from the "
"standard library's :mod:`Queue` module are raised to signal timeouts."
msgstr "標準ライブラリの :mod:`Queue` モジュールからの通常の :exc:`Queue.Empty` や :exc:`Queue.Full` 例外はタイムアウトのシグナルを送るために発生します。"

#: ../../library/multiprocessing.rst:570
msgid ""
":class:`~multiprocessing.Queue` implements all the methods of "
":class:`Queue.Queue` except for :meth:`~Queue.Queue.task_done` and "
":meth:`~Queue.Queue.join`."
msgstr ":class:`~multiprocessing.Queue` は :meth:`~Queue.Queue.task_done` や :meth:`~Queue.Queue.join` を除く :class:`Queue.Queue` の全てのメソッドを実装します。"

#: ../../library/multiprocessing.rst:575
msgid ""
"Return the approximate size of the queue.  Because of "
"multithreading/multiprocessing semantics, this number is not reliable."
msgstr "おおよそのキューのサイズを返します。マルチスレッディング/マルチプロセスの特性上、この数値は信用できません。"

#: ../../library/multiprocessing.rst:578
msgid ""
"Note that this may raise :exc:`NotImplementedError` on Unix platforms like "
"Mac OS X where ``sem_getvalue()`` is not implemented."
msgstr "これは ``sem_getvalue()`` が実装されていない Mac OS X のような Unix プラットホーム上で :exc:`NotImplementedError` を発生させる可能性があることを覚えておいてください。"

#: ../../library/multiprocessing.rst:583
msgid ""
"Return ``True`` if the queue is empty, ``False`` otherwise.  Because of "
"multithreading/multiprocessing semantics, this is not reliable."
msgstr "キューが空っぽなら ``True`` を、そうでなければ ``False`` を返します。マルチスレッディング/マルチプロセシングの特性上、これは信用できません。"

#: ../../library/multiprocessing.rst:588
msgid ""
"Return ``True`` if the queue is full, ``False`` otherwise.  Because of "
"multithreading/multiprocessing semantics, this is not reliable."
msgstr "キューがいっぱいなら ``True`` を、そうでなければ ``False`` を返します。マルチスレッディング/マルチプロセシングの特性上、これは信用できません。"

#: ../../library/multiprocessing.rst:593
msgid ""
"Put obj into the queue.  If the optional argument *block* is ``True`` (the "
"default) and *timeout* is ``None`` (the default), block if necessary until a"
" free slot is available.  If *timeout* is a positive number, it blocks at "
"most *timeout* seconds and raises the :exc:`Queue.Full` exception if no free"
" slot was available within that time.  Otherwise (*block* is ``False``), put"
" an item on the queue if a free slot is immediately available, else raise "
"the :exc:`Queue.Full` exception (*timeout* is ignored in that case)."
msgstr "キューの中へ要素を追加します。オプションの引数 *block* が ``True`` (デフォルト) 且つ *timeout* が ``None`` (デフォルト) なら、空きスロットが利用可能になるまで必要であればブロックします。 *timeout* が正の数なら、最大 *timeout* 秒ブロックして、その時間内に空きスロットが利用できなかったら :exc:`Queue.Full` 例外を発生させます。それ以外 ( *block* が ``False`` ) で、空きスロットがすぐに利用可能な場合はキューに要素を追加します。そうでなければ :exc:`Queue.Full` 例外が発生します(その場合 *timeout* は無視されます)。"

#: ../../library/multiprocessing.rst:604
msgid "Equivalent to ``put(obj, False)``."
msgstr "``put(obj, False)`` と等価です。"

#: ../../library/multiprocessing.rst:608
msgid ""
"Remove and return an item from the queue.  If optional args *block* is "
"``True`` (the default) and *timeout* is ``None`` (the default), block if "
"necessary until an item is available.  If *timeout* is a positive number, it"
" blocks at most *timeout* seconds and raises the :exc:`Queue.Empty` "
"exception if no item was available within that time.  Otherwise (block is "
"``False``), return an item if one is immediately available, else raise the "
":exc:`Queue.Empty` exception (*timeout* is ignored in that case)."
msgstr "キューから要素を取り出して削除します。オプションの引数 *block* が ``True`` (デフォルト) 且つ *timeout* が ``None`` (デフォルト) なら、要素が取り出せるまで必要であればブロックします。 *timeout* が正の数なら、最大 *timeout* 秒ブロックして、その時間内に要素が取り出せなかったら :exc:`Queue.Empty` 例外を発生させます。それ以外 ( *block* が ``False`` ) で、要素がすぐに取り出せる場合は要素を返します。そうでなければ :exc:`Queue.Empty` 例外が発生します(その場合 *timeout* は無視されます)。"

#: ../../library/multiprocessing.rst:618
msgid "Equivalent to ``get(False)``."
msgstr "``get(False)`` と等価です。"

#: ../../library/multiprocessing.rst:620
msgid ""
":class:`~multiprocessing.Queue` has a few additional methods not found in "
":class:`Queue.Queue`.  These methods are usually unnecessary for most code:"
msgstr ":class:`~multiprocessing.Queue` は :class:`Queue.Queue` にはない追加メソッドがあります。これらのメソッドは通常、ほとんどのコードに必要ありません。"

#: ../../library/multiprocessing.rst:626
msgid ""
"Indicate that no more data will be put on this queue by the current process."
"  The background thread will quit once it has flushed all buffered data to "
"the pipe.  This is called automatically when the queue is garbage collected."
msgstr "カレントプロセスからこのキューへそれ以上データが追加されないことを表します。バックグラウンドスレッドはパイプへバッファーされたすべてのデータをフラッシュするとすぐに終了します。これはキューがガベージコレクトされるときに自動的に呼び出されます。"

#: ../../library/multiprocessing.rst:633
msgid ""
"Join the background thread.  This can only be used after :meth:`close` has "
"been called.  It blocks until the background thread exits, ensuring that all"
" data in the buffer has been flushed to the pipe."
msgstr "バックグラウンドスレッドを join します。このメソッドは :meth:`close` が呼び出された後でのみ使用されます。バッファーされたすべてのデータがパイプへフラッシュされるのを保証するため、バックグラウンドスレッドが終了するまでブロックします。"

#: ../../library/multiprocessing.rst:637
msgid ""
"By default if a process is not the creator of the queue then on exit it will"
" attempt to join the queue's background thread.  The process can call "
":meth:`cancel_join_thread` to make :meth:`join_thread` do nothing."
msgstr "デフォルトでは、あるプロセスがキューを作成していない場合、終了時にキューのバックグラウンドスレッドを join しようとします。そのプロセスは :meth:`join_thread` が何もしないように :meth:`cancel_join_thread` を呼び出すことができます。"

#: ../../library/multiprocessing.rst:643
msgid ""
"Prevent :meth:`join_thread` from blocking.  In particular, this prevents the"
" background thread from being joined automatically when the process exits --"
" see :meth:`join_thread`."
msgstr ":meth:`join_thread` がブロッキングするのを防ぎます。特にこれはバックグラウンドスレッドがそのプロセスの終了時に自動的に join されるのを防ぎます。詳細は :meth:`join_thread` を参照してください。"

#: ../../library/multiprocessing.rst:647
msgid ""
"A better name for this method might be ``allow_exit_without_flush()``.  It "
"is likely to cause enqueued data to lost, and you almost certainly will not "
"need to use it. It is really only there if you need the current process to "
"exit immediately without waiting to flush enqueued data to the underlying "
"pipe, and you don't care about lost data."
msgstr "このメソッドは ``allow_exit_without_flush()`` という名前のほうがよかったかもしれません。キューに追加されたデータが失われてしまいがちなため、このメソッドを使う必要はほぼ確実にないでしょう。本当にこれが必要になるのは、キューに追加されたデータを下位層のパイプにフラッシュすることなくカレントプロセスを直ちに終了する必要があり、かつ失われるデータに関心がない場合です。"

#: ../../library/multiprocessing.rst:656
msgid ""
"This class's functionality requires a functioning shared semaphore "
"implementation on the host operating system. Without one, the functionality "
"in this class will be disabled, and attempts to instantiate a :class:`Queue`"
" will result in an :exc:`ImportError`. See :issue:`3770` for additional "
"information.  The same holds true for any of the specialized queue types "
"listed below."
msgstr "このクラスに含まれる機能には、ホストとなるオペレーティングシステム上で動作している共有セマフォ (shared semaphore) を使用しているものがあります。これが使用できない場合には、このクラスが無効になり、 :class:`Queue` をインスタンス化する時に :exc:`ImportError` が発生します。詳細は :issue:`3770` を参照してください。同様のことが、以下に列挙されている特殊なキューでも成り立ちます。"

#: ../../library/multiprocessing.rst:666
msgid ""
"It is a simplified :class:`~multiprocessing.Queue` type, very close to a "
"locked :class:`Pipe`."
msgstr "単純化された :class:`~multiprocessing.Queue` 型です。ロックされた :class:`Pipe` に非常に似ています。"

#: ../../library/multiprocessing.rst:670
msgid "Return ``True`` if the queue is empty, ``False`` otherwise."
msgstr "もしキューが空ならば ``True`` を、そうでなければ ``False`` を返します。"

#: ../../library/multiprocessing.rst:674
msgid "Remove and return an item from the queue."
msgstr "キューからアイテムを取り除いて返します。"

#: ../../library/multiprocessing.rst:678
msgid "Put *item* into the queue."
msgstr "*item* をキューに追加します。"

#: ../../library/multiprocessing.rst:683
msgid ""
":class:`JoinableQueue`, a :class:`~multiprocessing.Queue` subclass, is a "
"queue which additionally has :meth:`task_done` and :meth:`join` methods."
msgstr ":class:`JoinableQueue` は :class:`~multiprocessing.Queue` のサブクラスであり、 :meth:`task_done` や :meth:`join` メソッドが追加されているキューです。"

#: ../../library/multiprocessing.rst:688
msgid ""
"Indicate that a formerly enqueued task is complete. Used by queue consumer "
"threads.  For each :meth:`~Queue.get` used to fetch a task, a subsequent "
"call to :meth:`task_done` tells the queue that the processing on the task is"
" complete."
msgstr "以前にキューへ追加されたタスクが完了したことを表します。キュー消費スレッドによって使用されます。タスクをフェッチするために使用されるそれぞれの :meth:`~Queue.get` では、次に :meth:`task_done` を呼び出してタスクの処理が完了したことをキューへ伝えます。"

#: ../../library/multiprocessing.rst:693
msgid ""
"If a :meth:`~Queue.Queue.join` is currently blocking, it will resume when "
"all items have been processed (meaning that a :meth:`task_done` call was "
"received for every item that had been :meth:`~Queue.put` into the queue)."
msgstr "もし :meth:`~Queue.Queue.join` がブロッキング状態なら、全ての要素が処理されたときに復帰します( :meth:`task_done` 呼び出しが全ての要素からキュー内へ :meth:`~Queue.put` されたと受け取ったことを意味します)。"

#: ../../library/multiprocessing.rst:697
msgid ""
"Raises a :exc:`ValueError` if called more times than there were items placed"
" in the queue."
msgstr "キューにある要素より多く呼び出された場合 :exc:`ValueError` が発生します。"

#: ../../library/multiprocessing.rst:703
msgid "Block until all items in the queue have been gotten and processed."
msgstr "キューにあるすべてのアイテムが取り出されて処理されるまでブロックします。"

#: ../../library/multiprocessing.rst:705
msgid ""
"The count of unfinished tasks goes up whenever an item is added to the "
"queue.  The count goes down whenever a consumer thread calls "
":meth:`task_done` to indicate that the item was retrieved and all work on it"
" is complete.  When the count of unfinished tasks drops to zero, "
":meth:`~Queue.Queue.join` unblocks."
msgstr "キューに要素が追加されると未終了タスク数が増えます。キューの要素が取り出されて全て処理が完了したことを表す :meth:`task_done` を消費スレッドが呼び出すと数が減ります。未終了タスク数がゼロになると :meth:`~Queue.Queue.join` はブロッキングを解除します。"

#: ../../library/multiprocessing.rst:713
msgid "Miscellaneous"
msgstr "その他の関数"

#: ../../library/multiprocessing.rst:717
msgid "Return list of all live children of the current process."
msgstr "カレントプロセスのアクティブな子プロセスのすべてのリストを返します。"

#: ../../library/multiprocessing.rst:719
msgid ""
"Calling this has the side effect of \"joining\" any processes which have "
"already finished."
msgstr "これを呼び出すと \"join\" してすでに終了しているプロセスには副作用があります。"

#: ../../library/multiprocessing.rst:724
msgid ""
"Return the number of CPUs in the system.  May raise "
":exc:`NotImplementedError`."
msgstr "システムの CPU 数を返します。 :exc:`NotImplementedError` が送出される場合があります。"

#: ../../library/multiprocessing.rst:729
msgid ""
"Return the :class:`Process` object corresponding to the current process."
msgstr "カレントプロセスに対応する :class:`Process` オブジェクトを返します。"

#: ../../library/multiprocessing.rst:731
msgid "An analogue of :func:`threading.current_thread`."
msgstr ":func:`threading.current_thread` とよく似た関数です。"

#: ../../library/multiprocessing.rst:735
msgid ""
"Add support for when a program which uses :mod:`multiprocessing` has been "
"frozen to produce a Windows executable.  (Has been tested with **py2exe**, "
"**PyInstaller** and **cx_Freeze**.)"
msgstr ":mod:`multiprocessing` を使用するプログラムが Windows の実行可能形式を生成しようとして固まったときのサポートを追加します。(**py2exe** , **PyInstaller** や **cx_Freeze** でテストされています。)"

#: ../../library/multiprocessing.rst:739
msgid ""
"One needs to call this function straight after the ``if __name__ == "
"'__main__'`` line of the main module.  For example::"
msgstr "メインモジュールの ``if __name__ == '__main__'`` の直後にこの関数を呼び出す必要があります。以下に例を示します::"

#: ../../library/multiprocessing.rst:751
msgid ""
"If the ``freeze_support()`` line is omitted then trying to run the frozen "
"executable will raise :exc:`RuntimeError`."
msgstr "もし ``freeze_support()`` の行がない場合、固まった実行可能形式を実行しようとすると :exc:`RuntimeError` を発生させます。"

#: ../../library/multiprocessing.rst:754
msgid ""
"If the module is being run normally by the Python interpreter then "
":func:`freeze_support` has no effect."
msgstr "そのモジュールが Python インタープリターによって普通に実行されるなら :func:`freeze_support` は何の影響もありません。"

#: ../../library/multiprocessing.rst:759
msgid ""
"Sets the path of the Python interpreter to use when starting a child "
"process. (By default :data:`sys.executable` is used).  Embedders will "
"probably need to do some thing like ::"
msgstr "子プロセスを開始するときに、使用する Python インタープリターのパスを設定します。(デフォルトでは :data:`sys.executable` が使用されます)。コードに組み込むときは、おそらく次のようにする必要があります ::"

#: ../../library/multiprocessing.rst:765
msgid "before they can create child processes.  (Windows only)"
msgstr "子プロセスを生成する前に行なってください。 (Windows only)"

#: ../../library/multiprocessing.rst:770
msgid ""
":mod:`multiprocessing` contains no analogues of "
":func:`threading.active_count`, :func:`threading.enumerate`, "
":func:`threading.settrace`, :func:`threading.setprofile`, "
":class:`threading.Timer`, or :class:`threading.local`."
msgstr ":mod:`multiprocessing` には :func:`threading.active_count`, :func:`threading.enumerate`, :func:`threading.settrace`, :func:`threading.setprofile`, :class:`threading.Timer` や :class:`threading.local` のような関数はありません。"

#: ../../library/multiprocessing.rst:777
msgid "Connection Objects"
msgstr "Connection オブジェクト"

#: ../../library/multiprocessing.rst:779
msgid ""
"Connection objects allow the sending and receiving of picklable objects or "
"strings.  They can be thought of as message oriented connected sockets."
msgstr "Connection オブジェクトは pickle でシリアライズ可能なオブジェクトか文字列を送ったり、受け取ったりします。そういったオブジェクトはメッセージ指向の接続ソケットと考えられます。"

#: ../../library/multiprocessing.rst:782
msgid ""
"Connection objects are usually created using :func:`Pipe` -- see also :ref"
":`multiprocessing-listeners-clients`."
msgstr "Connection オブジェクトは通常は :func:`Pipe` を使用して作成されます。詳細は :ref:`multiprocessing-listeners-clients` も参照してください。"

#: ../../library/multiprocessing.rst:789
msgid ""
"Send an object to the other end of the connection which should be read using"
" :meth:`recv`."
msgstr "コネクションの相手側へ :meth:`recv` を使用して読み込むオブジェクトを送ります。"

#: ../../library/multiprocessing.rst:792
msgid ""
"The object must be picklable.  Very large pickles (approximately 32 MB+, "
"though it depends on the OS) may raise a :exc:`ValueError` exception."
msgstr "オブジェクトは pickle でシリアライズ可能でなければなりません。 pickle が極端に大きすぎる (OS にも依りますが、およそ 32 MB+) と、 :exc:`ValueError` 例外が送出されることがあります。"

#: ../../library/multiprocessing.rst:797
msgid ""
"Return an object sent from the other end of the connection using "
":meth:`send`.  Blocks until there its something to receive.  Raises "
":exc:`EOFError` if there is nothing left to receive and the other end was "
"closed."
msgstr "コネクションの相手側から :meth:`send` を使用して送られたオブジェクトを返します。 何か受け取るまでブロックします。何も受け取らずにコネクションの相手側でクローズされた場合 :exc:`EOFError` が発生します。"

#: ../../library/multiprocessing.rst:804
msgid "Return the file descriptor or handle used by the connection."
msgstr "コネクションが使用するハンドラーか、ファイル記述子を返します。"

#: ../../library/multiprocessing.rst:808
msgid "Close the connection."
msgstr "コネクションをクローズします。"

#: ../../library/multiprocessing.rst:810
msgid "This is called automatically when the connection is garbage collected."
msgstr "コネクションがガベージコレクトされるときに自動的に呼び出されます。"

#: ../../library/multiprocessing.rst:814
msgid "Return whether there is any data available to be read."
msgstr "読み込み可能なデータがあるかどうかを返します。"

#: ../../library/multiprocessing.rst:816
msgid ""
"If *timeout* is not specified then it will return immediately.  If *timeout*"
" is a number then this specifies the maximum time in seconds to block.  If "
"*timeout* is ``None`` then an infinite timeout is used."
msgstr "*timeout* が指定されていなければすぐに返します。 *timeout* に数値を指定すると、最大指定した秒数をブロッキングします。 *timeout* に ``None`` を指定するとタイムアウトせずにずっとブロッキングします。"

#: ../../library/multiprocessing.rst:822
msgid ""
"Send byte data from an object supporting the buffer interface as a complete "
"message."
msgstr "バッファインタフェースをサポートするオブジェクトから完全なメッセージとしてバイトデータを送ります。"

#: ../../library/multiprocessing.rst:825
msgid ""
"If *offset* is given then data is read from that position in *buffer*.  If "
"*size* is given then that many bytes will be read from buffer.  Very large "
"buffers (approximately 32 MB+, though it depends on the OS) may raise a "
":exc:`ValueError` exception"
msgstr "*offset* が指定されると *buffer* のその位置からデータが読み込まれます。 *size* が指定されるとバッファーからその量のデータが読み込まれます。非常に大きなバッファー (OS に依存しますが、およそ 32MB+) を指定すると、 :exc:`ValueError` 例外が発生するかもしれません。"

#: ../../library/multiprocessing.rst:832
msgid ""
"Return a complete message of byte data sent from the other end of the "
"connection as a string.  Blocks until there is something to receive. Raises "
":exc:`EOFError` if there is nothing left to receive and the other end has "
"closed."
msgstr "コネクションの相手側から送られたバイトデータの完全なメッセージを文字列として返します。何か受け取るまでブロックします。受け取るデータが何も残っておらず、相手側がコネクションを閉じていた場合、 :exc:`EOFError` が送出されます。"

#: ../../library/multiprocessing.rst:837
msgid ""
"If *maxlength* is specified and the message is longer than *maxlength* then "
":exc:`IOError` is raised and the connection will no longer be readable."
msgstr "*maxlength* を指定して、且つ *maxlength* よりメッセージが長い場合、 :exc:`IOError` を発生させて、それ以上はコネクションから読み込めなくなります。"

#: ../../library/multiprocessing.rst:843
msgid ""
"Read into *buffer* a complete message of byte data sent from the other end "
"of the connection and return the number of bytes in the message.  Blocks "
"until there is something to receive.  Raises :exc:`EOFError` if there is "
"nothing left to receive and the other end was closed."
msgstr "コネクションの相手側から送られたバイトデータを *buffer* に読み込み、メッセージのバイト数を返します。 何か受け取るまでブロックします。何も受け取らずにコネクションの相手側でクローズされた場合 :exc:`EOFError` が発生します。"

#: ../../library/multiprocessing.rst:849
msgid ""
"*buffer* must be an object satisfying the writable buffer interface.  If "
"*offset* is given then the message will be written into the buffer from that"
" position.  Offset must be a non-negative integer less than the length of "
"*buffer* (in bytes)."
msgstr "*buffer* は書き込み可能なバッファインタフェースを備えたオブジェクトでなければなりません。 *offset* が与えられたら、その位置からバッファへメッセージが書き込まれます。オフセットは *buffer* バイトよりも小さい正の数でなければなりません。"

#: ../../library/multiprocessing.rst:854
msgid ""
"If the buffer is too short then a :exc:`BufferTooShort` exception is raised "
"and the complete message is available as ``e.args[0]`` where ``e`` is the "
"exception instance."
msgstr "バッファーがあまりに小さいと :exc:`BufferTooShort` 例外が発生します。 ``e`` が例外インスタンスとすると完全なメッセージは ``e.args[0]`` で確認できます。"

#: ../../library/multiprocessing.rst:859
msgid "For example:"
msgstr "例えば:"

#: ../../library/multiprocessing.rst:883
msgid ""
"The :meth:`Connection.recv` method automatically unpickles the data it "
"receives, which can be a security risk unless you can trust the process "
"which sent the message."
msgstr ":meth:`Connection.recv` メソッドは受信したデータを自動的に unpickle 化します。それはメッセージを送ったプロセスが信頼できる場合を除いてセキュリティリスクになります。"

#: ../../library/multiprocessing.rst:887
msgid ""
"Therefore, unless the connection object was produced using :func:`Pipe` you "
"should only use the :meth:`~Connection.recv` and :meth:`~Connection.send` "
"methods after performing some sort of authentication.  See :ref"
":`multiprocessing-auth-keys`."
msgstr "そのため :func:`Pipe` を使用してコネクションオブジェクトを生成する場合を除いて、何らかの認証処理を実行した後で :meth:`~Connection.recv` や :meth:`~Connection.send` メソッドのみを使用すべきです。詳細は :ref:`multiprocessing-auth-keys` を参照してください。"

#: ../../library/multiprocessing.rst:894
msgid ""
"If a process is killed while it is trying to read or write to a pipe then "
"the data in the pipe is likely to become corrupted, because it may become "
"impossible to be sure where the message boundaries lie."
msgstr "もしプロセスがパイプの読み込みまたは書き込み中に kill されると、メッセージの境界がどこなのか分からなくなってしまうので、そのパイプ内のデータは破損してしまいがちです。"

#: ../../library/multiprocessing.rst:900
msgid "Synchronization primitives"
msgstr "同期プリミティブ"

#: ../../library/multiprocessing.rst:902
msgid ""
"Generally synchronization primitives are not as necessary in a multiprocess "
"program as they are in a multithreaded program.  See the documentation for "
":mod:`threading` module."
msgstr "一般的にマルチプロセスプログラムは、マルチスレッドプログラムほどは同期プリミティブを必要としません。詳細は :mod:`threading` モジュールのドキュメントを参照してください。"

#: ../../library/multiprocessing.rst:906
msgid ""
"Note that one can also create synchronization primitives by using a manager "
"object -- see :ref:`multiprocessing-managers`."
msgstr "マネージャーオブジェクトを使用して同期プリミティブを作成できることも覚えておいてください。詳細は :ref:`multiprocessing-managers` を参照してください。"

#: ../../library/multiprocessing.rst:911
msgid ""
"A bounded semaphore object: a close analog of "
":class:`threading.BoundedSemaphore`."
msgstr "有限セマフォオブジェクト: :class:`threading.BoundedSemaphore` のクローンです。"

#: ../../library/multiprocessing.rst:914
#: ../../library/multiprocessing.rst:1054
msgid ""
"A solitary difference from its close analog exists: its ``acquire`` method's"
" first argument is named *block* and it supports an optional second argument"
" *timeout*, as is consistent with :meth:`Lock.acquire`."
msgstr "インターフェイスがスレッドのものと一つだけ違います: ``acquire`` メソッドの最初の引数は *block* 、オプション引数として *timeout* を取ります。これは :meth:`Lock.acquire` でのものと同じです。"

#: ../../library/multiprocessing.rst:919
msgid ""
"On Mac OS X, this is indistinguishable from :class:`Semaphore` because "
"``sem_getvalue()`` is not implemented on that platform."
msgstr "Mac OS X では ``sem_getvalue()`` が実装されていないので :class:`Semaphore` と区別がつきません。"

#: ../../library/multiprocessing.rst:924
msgid "A condition variable: a clone of :class:`threading.Condition`."
msgstr "状態変数: :class:`threading.Condition` のクローンです。"

#: ../../library/multiprocessing.rst:926
msgid ""
"If *lock* is specified then it should be a :class:`Lock` or :class:`RLock` "
"object from :mod:`multiprocessing`."
msgstr "*lock* を指定するなら :mod:`multiprocessing` の :class:`Lock` か :class:`RLock` オブジェクトにすべきです。"

#: ../../library/multiprocessing.rst:931
msgid ""
"A clone of :class:`threading.Event`. This method returns the state of the "
"internal semaphore on exit, so it will always return ``True`` except if a "
"timeout is given and the operation times out."
msgstr ":class:`threading.Event` のクローンです。このメソッドは、終了時の内部セマフォの状態を返すので、タイムアウトが与えられ、実際にオペレーションがタイムアウトしたのでなければ、必ず ``True`` を返します。"

#: ../../library/multiprocessing.rst:936
msgid "Previously, the method always returned ``None``."
msgstr "以前はこのメソッドは常に ``None`` を返していました。"

#: ../../library/multiprocessing.rst:942
msgid ""
"A non-recursive lock object: a close analog of :class:`threading.Lock`. Once"
" a process or thread has acquired a lock, subsequent attempts to acquire it "
"from any process or thread will block until it is released; any process or "
"thread may release it.  The concepts and behaviors of "
":class:`threading.Lock` as it applies to threads are replicated here in "
":class:`multiprocessing.Lock` as it applies to either processes or threads, "
"except as noted."
msgstr "再帰しないロックオブジェクトで、 :class:`threading.Lock` 相当のものです。プロセスやスレッドがロックをいったん獲得 (acquire) すると、それに続くほかのプロセスやスレッドが獲得しようとする際、それが解放 (release) されるまではブロックされます。解放はどのプロセス、スレッドからも行えます。スレッドに対して適用される :class:`threading.Lock` のコンセプトと振る舞いは、特筆すべきものがない限り、プロセスとスレッドに適用される :class:`multiprocessing.Lock` に引き継がれています。"

#: ../../library/multiprocessing.rst:950
msgid ""
"Note that :class:`Lock` is actually a factory function which returns an "
"instance of ``multiprocessing.synchronize.Lock`` initialized with a default "
"context."
msgstr ":class:`Lock` は実際にはファクトリ関数で、デフォルトコンテキストで初期化された ``multiprocessing.synchronize.Lock`` のインスタンスを返すことに注意してください。"

#: ../../library/multiprocessing.rst:954
msgid ""
":class:`Lock` supports the :term:`context manager` protocol and thus may be "
"used in :keyword:`with` statements."
msgstr ":class:`Lock` は :term:`context manager` プロトコルをサポートしています。つまり :keyword:`with` 文で使うことができます。"

#: ../../library/multiprocessing.rst:959
#: ../../library/multiprocessing.rst:1008
msgid "Acquire a lock, blocking or non-blocking."
msgstr "ブロックあり、またはブロックなしでロックを獲得します。"

#: ../../library/multiprocessing.rst:961
msgid ""
"With the *block* argument set to ``True`` (the default), the method call "
"will block until the lock is in an unlocked state, then set it to locked and"
" return ``True``.  Note that the name of this first argument differs from "
"that in :meth:`threading.Lock.acquire`."
msgstr "引数 *block* を ``True`` (デフォルト) に設定して呼び出した場合、ロックがアンロック状態になるまでブロックします。ブロックから抜けるとそれをロック状態にしてから ``True`` を返します。 :meth:`threading.Lock.acquire` の最初の引数とは名前が違っているので注意してください。"

#: ../../library/multiprocessing.rst:966
msgid ""
"With the *block* argument set to ``False``, the method call does not block."
"  If the lock is currently in a locked state, return ``False``; otherwise "
"set the lock to a locked state and return ``True``."
msgstr "引数 *block* の値を ``False`` にして呼び出すとブロックしません。 現在ロック状態であれば、直ちに ``False`` を返します。それ以外の場合には、ロックをロック状態にして ``True`` を返します。"

#: ../../library/multiprocessing.rst:970
msgid ""
"When invoked with a positive, floating-point value for *timeout*, block for "
"at most the number of seconds specified by *timeout* as long as the lock can"
" not be acquired.  Invocations with a negative value for *timeout* are "
"equivalent to a *timeout* of zero.  Invocations with a *timeout* value of "
"``None`` (the default) set the timeout period to infinite.  The *timeout* "
"argument has no practical implications if the *block* argument is set to "
"``False`` and is thus ignored.  Returns ``True`` if the lock has been "
"acquired or ``False`` if the timeout period has elapsed.  Note that the "
"*timeout* argument does not exist in this method's analog, "
":meth:`threading.Lock.acquire`."
msgstr "*timeout* として正の浮動小数点数を与えて呼び出すと、ロックが獲得出来ないあいだ最大でこれで指定した秒数だけブロックします。 *timeout* 値の負数はゼロと同じです。 *timeout* 値の ``None`` (デフォルト) は無限にブロックすることを意味します。 *block* が ``False`` の場合には *timeout* には実際的な意味はないので無視されます。ロックを獲得すると ``True`` 、タイムアウトした場合は ``False`` で戻ります。 *timeout* 引数は類似品の :meth:`threading.Lock.acquire` にはないことに注意してください。"

#: ../../library/multiprocessing.rst:983
msgid ""
"Release a lock.  This can be called from any process or thread, not only the"
" process or thread which originally acquired the lock."
msgstr "ロックを解放します。これはロックを獲得したプロセスやスレッドだけでなく、任意のプロセスやスレッドから呼ぶことができます。"

#: ../../library/multiprocessing.rst:986
msgid ""
"Behavior is the same as in :meth:`threading.Lock.release` except that when "
"invoked on an unlocked lock, a :exc:`ValueError` is raised."
msgstr ":meth:`threading.Lock.release` と同じように振舞いますが、ロックされていない場合に呼び出すと :exc:`ValueError` となる点だけが違います。"

#: ../../library/multiprocessing.rst:992
msgid ""
"A recursive lock object: a close analog of :class:`threading.RLock`.  A "
"recursive lock must be released by the process or thread that acquired it. "
"Once a process or thread has acquired a recursive lock, the same process or "
"thread may acquire it again without blocking; that process or thread must "
"release it once for each time it has been acquired."
msgstr "再帰ロックオブジェクトで、 :class:`threading.RLock` 相当のものです。再帰ロックオブジェクトはそれを獲得 (acquire) したプロセスやスレッドが解放 (release) しなければなりません。プロセスやスレッドがロックをいったん獲得すると、同じプロセスやスレッドはブロックされずに再度獲得出来ます。そのプロセスやスレッドは獲得した回数ぶん解放しなければなりません。"

#: ../../library/multiprocessing.rst:998
msgid ""
"Note that :class:`RLock` is actually a factory function which returns an "
"instance of ``multiprocessing.synchronize.RLock`` initialized with a default"
" context."
msgstr ":class:`RLock` は実際にはファクトリ関数で、デフォルトコンテキストで初期化された ``multiprocessing.synchronize.Lock`` のインスタンスを返すことに注意してください。"

#: ../../library/multiprocessing.rst:1002
msgid ""
":class:`RLock` supports the :term:`context manager` protocol and thus may be"
" used in :keyword:`with` statements."
msgstr ":class:`RLock` は :term:`context manager` プロトコルをサポートしています。つまり :keyword:`with` 文で使うことができます。"

#: ../../library/multiprocessing.rst:1010
msgid ""
"When invoked with the *block* argument set to ``True``, block until the lock"
" is in an unlocked state (not owned by any process or thread) unless the "
"lock is already owned by the current process or thread.  The current process"
" or thread then takes ownership of the lock (if it does not already have "
"ownership) and the recursion level inside the lock increments by one, "
"resulting in a return value of ``True``.  Note that there are several "
"differences in this first argument's behavior compared to the implementation"
" of :meth:`threading.RLock.acquire`, starting with the name of the argument "
"itself."
msgstr "*block* 引数を ``True`` にして呼び出した場合、ロックが既にカレントプロセスもしくはカレントスレッドが既に所有していない限りは、アンロック状態 (どのプロセス、スレッドも所有していない状態) になるまでブロックします。ブロックから抜けるとカレントプロセスもしくはカレントスレッドが (既に持っていなければ) 所有権を得て、再帰レベルをインクリメントし、 ``True`` で戻ります。 :meth:`threading.RLock.acquire` の実装とはこの最初の引数の振る舞いが、その名前自身を始めとしていくつか違うので注意してください。"

#: ../../library/multiprocessing.rst:1020
msgid ""
"When invoked with the *block* argument set to ``False``, do not block. If "
"the lock has already been acquired (and thus is owned) by another process or"
" thread, the current process or thread does not take ownership and the "
"recursion level within the lock is not changed, resulting in a return value "
"of ``False``.  If the lock is in an unlocked state, the current process or "
"thread takes ownership and the recursion level is incremented, resulting in "
"a return value of ``True``."
msgstr "*block* 引数を ``False`` にして呼び出した場合、ブロックしません。ロックが他のプロセスもしくはスレッドにより獲得済み (つまり所有されている) であれば、カレントプロセスまたはカレントスレッドは所有権を得ず、再帰レベルも変更せずに、 ``False`` で戻ります。ロックがアンロック状態の場合、カレントプロセスもしくはカレントスレッドは所有権を得て再帰レベルがインクリメントされ、 ``True`` で戻ります。(---訳注: *block* の True/False 関係なくここでの説明では「所有権を持っている場合の2度目以降の aquire」の説明が欠けています。2度目以降の acquire では再帰レベルがインクリメントされて即座に返ります。全体読めばわかるとは思いますが一応。---)"

#: ../../library/multiprocessing.rst:1028
msgid ""
"Use and behaviors of the *timeout* argument are the same as in "
":meth:`Lock.acquire`.  Note that the *timeout* argument does not exist in "
"this method's analog, :meth:`threading.RLock.acquire`."
msgstr "*timeout* 引数の使い方と振る舞いは :meth:`Lock.acquire` と同じです。 *timeout* 引数は類似品の :meth:`threading.RLock.acquire` にはないことに注意してください。"

#: ../../library/multiprocessing.rst:1035
msgid ""
"Release a lock, decrementing the recursion level.  If after the decrement "
"the recursion level is zero, reset the lock to unlocked (not owned by any "
"process or thread) and if any other processes or threads are blocked waiting"
" for the lock to become unlocked, allow exactly one of them to proceed.  If "
"after the decrement the recursion level is still nonzero, the lock remains "
"locked and owned by the calling process or thread."
msgstr "再帰レベルをデクリメントしてロックを解放します。デクリメント後に再帰レベルがゼロになった場合、ロックの状態をアンロック (いかなるプロセス、いかなるスレッドにも所有されていない状態) にリセットし、ロックの状態がアンロックになるのを待ってブロックしているプロセスもしくはスレッドがある場合にはその中のただ一つだけが処理を進行できるようにします。デクリメント後も再帰レベルがゼロでない場合、ロックの状態はロックのままで、呼び出し側のプロセスもしくはスレッドに所有されたままになります。"

#: ../../library/multiprocessing.rst:1043
msgid ""
"Only call this method when the calling process or thread owns the lock. An "
":exc:`AssertionError` is raised if this method is called by a process or "
"thread other than the owner or if the lock is in an unlocked (unowned) "
"state.  Note that the type of exception raised in this situation differs "
"from the implemented behavior in :meth:`threading.RLock.release`."
msgstr "このメソッドは呼び出しプロセスあるいはスレッドがロックを所有している場合に限り呼び出してください。所有者でないプロセスもしくはスレッドによって呼ばれるか、あるいはアンロック (未所有) 状態で呼ばれた場合、 :exc:`AssertionError` が送出されます。同じ状況での :meth:`threading.RLock.release` 実装とは例外の型が異なるので注意してください。"

#: ../../library/multiprocessing.rst:1052
msgid "A semaphore object: a close analog of :class:`threading.Semaphore`."
msgstr "セマフォオブジェクト: :class:`threading.Semaphore` のクローンです。"

#: ../../library/multiprocessing.rst:1060
msgid ""
"The :meth:`acquire` method of :class:`BoundedSemaphore`, :class:`Lock`, "
":class:`RLock` and :class:`Semaphore` has a timeout parameter not supported "
"by the equivalents in :mod:`threading`.  The signature is "
"``acquire(block=True, timeout=None)`` with keyword parameters being "
"acceptable.  If *block* is ``True`` and *timeout* is not ``None`` then it "
"specifies a timeout in seconds.  If *block* is ``False`` then *timeout* is "
"ignored."
msgstr ":class:`BoundedSemaphore`, :class:`Lock`, :class:`RLock` と :class:`Semaphore` の :meth:`acquire` メソッドは :mod:`threading` ではサポートされていないタイムアウトパラメータを取ります。その引数はキーワード引数で受け取れる ``acquire(block=True, timeout=None)`` です。 *block* が ``True`` 且つ *timeout* が ``None`` ではないなら、タイムアウトが秒単位で設定されます。 *block* が ``False`` なら *timeout* は無視されます。"

#: ../../library/multiprocessing.rst:1068
msgid ""
"On Mac OS X, ``sem_timedwait`` is unsupported, so calling ``acquire()`` with"
" a timeout will emulate that function's behavior using a sleeping loop."
msgstr "Mac OS X では ``sem_timedwait`` がサポートされていないので、``acquire()`` にタイムアウトを与えて呼ぶと、ループ内でスリープすることでこの関数がエミュレートされます。"

#: ../../library/multiprocessing.rst:1073
msgid ""
"If the SIGINT signal generated by :kbd:`Ctrl-C` arrives while the main "
"thread is blocked by a call to :meth:`BoundedSemaphore.acquire`, "
":meth:`Lock.acquire`, :meth:`RLock.acquire`, :meth:`Semaphore.acquire`, "
":meth:`Condition.acquire` or :meth:`Condition.wait` then the call will be "
"immediately interrupted and :exc:`KeyboardInterrupt` will be raised."
msgstr "メインスレッドが :meth:`BoundedSemaphore.acquire`, :meth:`Lock.acquire`, :meth:`RLock.acquire`, :meth:`Semaphore.acquire`, :meth:`Condition.acquire` 又は :meth:`Condition.wait` を呼び出してブロッキング状態のときに :kbd:`Ctrl-C` で生成される SIGINT シグナルを受け取ると、その呼び出しはすぐに中断されて :exc:`KeyboardInterrupt` が発生します。"

#: ../../library/multiprocessing.rst:1079
msgid ""
"This differs from the behaviour of :mod:`threading` where SIGINT will be "
"ignored while the equivalent blocking calls are in progress."
msgstr "これは同等のブロッキング呼び出しが実行中のときに SIGINT が無視される :mod:`threading` の振る舞いとは違っています。"

#: ../../library/multiprocessing.rst:1084
msgid ""
"Some of this package's functionality requires a functioning shared semaphore"
" implementation on the host operating system. Without one, the "
":mod:`multiprocessing.synchronize` module will be disabled, and attempts to "
"import it will result in an :exc:`ImportError`. See :issue:`3770` for "
"additional information."
msgstr "このパッケージに含まれる機能には、ホストとなるオペレーティングシステム上で動作している共有セマフォを使用しているものがあります。これが使用できない場合には、:mod:`multiprocessing.synchronize` モジュールが無効になり、このモジュールのインポート時に :exc:`ImportError` が発生します。詳細は :issue:`3770` を参照してください。"

#: ../../library/multiprocessing.rst:1092
msgid "Shared :mod:`ctypes` Objects"
msgstr "共有 :mod:`ctypes` オブジェクト"

#: ../../library/multiprocessing.rst:1094
msgid ""
"It is possible to create shared objects using shared memory which can be "
"inherited by child processes."
msgstr "子プロセスにより継承される共有メモリを使用する共有オブジェクトを作成することができます。"

#: ../../library/multiprocessing.rst:1099
msgid ""
"Return a :mod:`ctypes` object allocated from shared memory.  By default the "
"return value is actually a synchronized wrapper for the object."
msgstr "共有メモリから割り当てられた :mod:`ctypes` オブジェクトを返します。デフォルトでは、返り値は実際のオブジェクトの同期ラッパーです。"

#: ../../library/multiprocessing.rst:1102
#: ../../library/multiprocessing.rst:1189
msgid ""
"*typecode_or_type* determines the type of the returned object: it is either "
"a ctypes type or a one character typecode of the kind used by the "
":mod:`array` module.  *\\*args* is passed on to the constructor for the "
"type."
msgstr "*typecode_or_type* は返されるオブジェクトの型を決めます。それは ctypes の型か :mod:`array` モジュールで使用されるような1文字の型コードかのどちらか一方です。 *\\*args* は型のコンストラクターへ渡されます。"

#: ../../library/multiprocessing.rst:1106
msgid ""
"If *lock* is ``True`` (the default) then a new recursive lock object is "
"created to synchronize access to the value.  If *lock* is a :class:`Lock` or"
" :class:`RLock` object then that will be used to synchronize access to the "
"value.  If *lock* is ``False`` then access to the returned object will not "
"be automatically protected by a lock, so it will not necessarily be "
"\"process-safe\"."
msgstr "*lock* が ``True`` (デフォルト) なら、値へ同期アクセスするために新たに再帰的なロックオブジェクトが作成されます。 *lock* が :class:`Lock` か :class:`RLock` なら値への同期アクセスに使用されます。 *lock* が ``False`` なら、返されたオブジェクトへのアクセスはロックにより自動的に保護されません。そのため、必ずしも \"プロセスセーフ\" ではありません。"

#: ../../library/multiprocessing.rst:1113
msgid ""
"Operations like ``+=`` which involve a read and write are not atomic.  So "
"if, for instance, you want to atomically increment a shared value it is "
"insufficient to just do ::"
msgstr "``+=`` のような演算は、読み込みと書き込みを含むためアトミックでありません。このため、たとえば自動的に共有の値を増加させたい場合、以下のようにするのでは不十分です ::"

#: ../../library/multiprocessing.rst:1119
msgid ""
"Assuming the associated lock is recursive (which it is by default) you can "
"instead do ::"
msgstr "関連するロックが再帰的 (それがデフォルトです) なら、かわりに次のようにします ::"

#: ../../library/multiprocessing.rst:1125
#: ../../library/multiprocessing.rst:1215
#: ../../library/multiprocessing.rst:1230
msgid "Note that *lock* is a keyword-only argument."
msgstr "*lock* はキーワード引数でのみ指定することに注意してください。"

#: ../../library/multiprocessing.rst:1129
msgid ""
"Return a ctypes array allocated from shared memory.  By default the return "
"value is actually a synchronized wrapper for the array."
msgstr "共有メモリから割り当てられた ctypes 配列を返します。デフォルトでは、返り値は実際の配列の同期ラッパーです。"

#: ../../library/multiprocessing.rst:1132
msgid ""
"*typecode_or_type* determines the type of the elements of the returned "
"array: it is either a ctypes type or a one character typecode of the kind "
"used by the :mod:`array` module.  If *size_or_initializer* is an integer, "
"then it determines the length of the array, and the array will be initially "
"zeroed. Otherwise, *size_or_initializer* is a sequence which is used to "
"initialize the array and whose length determines the length of the array."
msgstr "*typecode_or_type* は返される配列の要素の型を決めます。それは ctypes の型か :mod:`array` モジュールで使用されるような1文字の型コードかのどちらか一方です。 *size_or_initializer* が整数なら、配列の長さを決定し、その配列はゼロで初期化されます。別の使用方法として *size_or_initializer* は配列の初期化に使用されるシーケンスになり、そのシーケンス長が配列の長さを決定します。"

#: ../../library/multiprocessing.rst:1139
msgid ""
"If *lock* is ``True`` (the default) then a new lock object is created to "
"synchronize access to the value.  If *lock* is a :class:`Lock` or "
":class:`RLock` object then that will be used to synchronize access to the "
"value.  If *lock* is ``False`` then access to the returned object will not "
"be automatically protected by a lock, so it will not necessarily be "
"\"process-safe\"."
msgstr "*lock* が ``True`` (デフォルト) なら、値へ同期アクセスするために新たなロックオブジェクトが作成されます。 *lock* が :class:`Lock` か :class:`RLock` なら値への同期アクセスに使用されます。 *lock* が ``False`` なら、返されたオブジェクトへのアクセスはロックにより自動的に保護されません。そのため、必ずしも \"プロセスセーフ\" ではありません。"

#: ../../library/multiprocessing.rst:1146
msgid "Note that *lock* is a keyword only argument."
msgstr "*lock* はキーワード引数としてのみ利用可能なことに注意してください。"

#: ../../library/multiprocessing.rst:1148
msgid ""
"Note that an array of :data:`ctypes.c_char` has *value* and *raw* attributes"
" which allow one to use it to store and retrieve strings."
msgstr ":data:`ctypes.c_char` の配列は文字列を格納して取り出せる *value* と *raw* 属性を持っていることを覚えておいてください。"

#: ../../library/multiprocessing.rst:1153
msgid "The :mod:`multiprocessing.sharedctypes` module"
msgstr ":mod:`multiprocessing.sharedctypes` モジュール"

#: ../../library/multiprocessing.rst:1158
msgid ""
"The :mod:`multiprocessing.sharedctypes` module provides functions for "
"allocating :mod:`ctypes` objects from shared memory which can be inherited "
"by child processes."
msgstr ":mod:`multiprocessing.sharedctypes` モジュールは子プロセスに継承される共有メモリの :mod:`ctypes` オブジェクトを割り当てる関数を提供します。"

#: ../../library/multiprocessing.rst:1164
msgid ""
"Although it is possible to store a pointer in shared memory remember that "
"this will refer to a location in the address space of a specific process. "
"However, the pointer is quite likely to be invalid in the context of a "
"second process and trying to dereference the pointer from the second process"
" may cause a crash."
msgstr "共有メモリのポインターを格納することは可能ではありますが、特定プロセスのアドレス空間の位置を参照するということを覚えておいてください。しかし、そのポインターは別のプロセスのコンテキストにおいて無効になる確率が高いです。そして、別のプロセスからそのポインターを逆参照しようとするとクラッシュを引き起こす可能性があります。"

#: ../../library/multiprocessing.rst:1172
msgid "Return a ctypes array allocated from shared memory."
msgstr "共有メモリから割り当てられた ctypes 配列を返します。"

#: ../../library/multiprocessing.rst:1174
msgid ""
"*typecode_or_type* determines the type of the elements of the returned "
"array: it is either a ctypes type or a one character typecode of the kind "
"used by the :mod:`array` module.  If *size_or_initializer* is an integer "
"then it determines the length of the array, and the array will be initially "
"zeroed. Otherwise *size_or_initializer* is a sequence which is used to "
"initialize the array and whose length determines the length of the array."
msgstr "*typecode_or_type* は返される配列の要素の型を決めます。それは ctypes の型か :mod:`array` モジュールで使用されるような1文字の型コードのどちらか一方です。 *size_or_initializer* が整数なら、それが配列の長さになり、その配列はゼロで初期化されます。別の使用方法として *size_or_initializer* には配列の初期化に使用されるシーケンスを設定することもでき、その場合はシーケンスの長さが配列の長さになります。"

#: ../../library/multiprocessing.rst:1181
msgid ""
"Note that setting and getting an element is potentially non-atomic -- use "
":func:`Array` instead to make sure that access is automatically synchronized"
" using a lock."
msgstr "要素を取得したり設定したりすることは潜在的に非アトミックであることに注意してください。ロックを使用して自動的に同期化されたアクセスを保証するには :func:`Array` を使用してください。"

#: ../../library/multiprocessing.rst:1187
msgid "Return a ctypes object allocated from shared memory."
msgstr "共有メモリから割り当てられた ctypes オブジェクトを返します。"

#: ../../library/multiprocessing.rst:1193
msgid ""
"Note that setting and getting the value is potentially non-atomic -- use "
":func:`Value` instead to make sure that access is automatically synchronized"
" using a lock."
msgstr "値を取得したり設定したりすることは潜在的に非アトミックであることに注意してください。ロックを使用して自動的に同期化されたアクセスを保証するには :func:`Value` を使用してください。"

#: ../../library/multiprocessing.rst:1197
msgid ""
"Note that an array of :data:`ctypes.c_char` has ``value`` and ``raw`` "
"attributes which allow one to use it to store and retrieve strings -- see "
"documentation for :mod:`ctypes`."
msgstr ":data:`ctypes.c_char` の配列は文字列を格納して取り出せる ``value`` と ``raw`` 属性を持っていることを覚えておいてください。詳細は :mod:`ctypes` を参照してください。"

#: ../../library/multiprocessing.rst:1203
msgid ""
"The same as :func:`RawArray` except that depending on the value of *lock* a "
"process-safe synchronization wrapper may be returned instead of a raw ctypes"
" array."
msgstr ":func:`RawArray` と同様ですが、 *lock* の値によっては ctypes 配列をそのまま返す代わりに、プロセスセーフな同期ラッパーが返されます。"

#: ../../library/multiprocessing.rst:1207
#: ../../library/multiprocessing.rst:1223
msgid ""
"If *lock* is ``True`` (the default) then a new lock object is created to "
"synchronize access to the value.  If *lock* is a "
":class:`~multiprocessing.Lock` or :class:`~multiprocessing.RLock` object "
"then that will be used to synchronize access to the value.  If *lock* is "
"``False`` then access to the returned object will not be automatically "
"protected by a lock, so it will not necessarily be \"process-safe\"."
msgstr "*lock* が ``True`` (デフォルト) なら、値へ同期アクセスするために新たな ロックオブジェクトが作成されます。 *lock* が :class:`~multiprocessing.Lock` か :class:`~multiprocessing.RLock` なら値への同期アクセスに使用されます。 *lock* が ``False`` なら、返された オブジェクトへのアクセスはロックにより自動的に保護されません。 そのため、必ずしも \"プロセスセーフ\" ではありません。"

#: ../../library/multiprocessing.rst:1219
msgid ""
"The same as :func:`RawValue` except that depending on the value of *lock* a "
"process-safe synchronization wrapper may be returned instead of a raw ctypes"
" object."
msgstr ":func:`RawValue` と同様ですが、 *lock* の値によっては ctypes オブジェクトをそのまま返す代わりに、プロセスセーフな同期ラッパーが返されます。"

#: ../../library/multiprocessing.rst:1234
msgid ""
"Return a ctypes object allocated from shared memory which is a copy of the "
"ctypes object *obj*."
msgstr "共有メモリから割り当てられた ctypes オブジェクト *obj* をコピーしたオブジェクトを返します。"

#: ../../library/multiprocessing.rst:1239
msgid ""
"Return a process-safe wrapper object for a ctypes object which uses *lock* "
"to synchronize access.  If *lock* is ``None`` (the default) then a "
":class:`multiprocessing.RLock` object is created automatically."
msgstr "同期アクセスに *lock* を使用する ctypes オブジェクトのためにプロセスセーフなラッパーオブジェクトを返します。 *lock* が ``None`` (デフォルト) なら、 :class:`multiprocessing.RLock` オブジェクトが自動的に作成されます。"

#: ../../library/multiprocessing.rst:1243
msgid ""
"A synchronized wrapper will have two methods in addition to those of the "
"object it wraps: :meth:`get_obj` returns the wrapped object and "
":meth:`get_lock` returns the lock object used for synchronization."
msgstr "同期ラッパーがラップするオブジェクトに加えて2つのメソッドがあります。 :meth:`get_obj` はラップされたオブジェクトを返します。 :meth:`get_lock` は同期のために使用されるロックオブジェクトを返します。"

#: ../../library/multiprocessing.rst:1247
msgid ""
"Note that accessing the ctypes object through the wrapper can be a lot "
"slower than accessing the raw ctypes object."
msgstr "ラッパー経由で ctypes オブジェクトにアクセスすることは raw ctypes オブジェクトへアクセスするよりずっと遅くなることに注意してください。"

#: ../../library/multiprocessing.rst:1251
msgid ""
"The table below compares the syntax for creating shared ctypes objects from "
"shared memory with the normal ctypes syntax.  (In the table ``MyStruct`` is "
"some subclass of :class:`ctypes.Structure`.)"
msgstr "次の表は通常の ctypes 構文で共有メモリから共有 ctypes オブジェクトを作成するための構文を比較します。 (``MyStruct`` テーブル内には :class:`ctypes.Structure` のサブクラスがあります。)"

#: ../../library/multiprocessing.rst:1256
msgid "ctypes"
msgstr "ctypes"

#: ../../library/multiprocessing.rst:1256
msgid "sharedctypes using type"
msgstr "type を使用する sharedctypes"

#: ../../library/multiprocessing.rst:1256
msgid "sharedctypes using typecode"
msgstr "typecode を使用する sharedctypes"

#: ../../library/multiprocessing.rst:1258
msgid "c_double(2.4)"
msgstr "c_double(2.4)"

#: ../../library/multiprocessing.rst:1258
msgid "RawValue(c_double, 2.4)"
msgstr "RawValue(c_double, 2.4)"

#: ../../library/multiprocessing.rst:1258
msgid "RawValue('d', 2.4)"
msgstr "RawValue('d', 2.4)"

#: ../../library/multiprocessing.rst:1259
msgid "MyStruct(4, 6)"
msgstr "MyStruct(4, 6)"

#: ../../library/multiprocessing.rst:1259
msgid "RawValue(MyStruct, 4, 6)"
msgstr "RawValue(MyStruct, 4, 6)"

#: ../../library/multiprocessing.rst:1260
msgid "(c_short * 7)()"
msgstr "(c_short * 7)()"

#: ../../library/multiprocessing.rst:1260
msgid "RawArray(c_short, 7)"
msgstr "RawArray(c_short, 7)"

#: ../../library/multiprocessing.rst:1260
msgid "RawArray('h', 7)"
msgstr "RawArray('h', 7)"

#: ../../library/multiprocessing.rst:1261
msgid "(c_int * 3)(9, 2, 8)"
msgstr "(c_int * 3)(9, 2, 8)"

#: ../../library/multiprocessing.rst:1261
msgid "RawArray(c_int, (9, 2, 8))"
msgstr "RawArray(c_int, (9, 2, 8))"

#: ../../library/multiprocessing.rst:1261
msgid "RawArray('i', (9, 2, 8))"
msgstr "RawArray('i', (9, 2, 8))"

#: ../../library/multiprocessing.rst:1265
msgid ""
"Below is an example where a number of ctypes objects are modified by a child"
" process::"
msgstr "以下に子プロセスが多くの ctypes オブジェクトを変更する例を紹介します::"

#: ../../library/multiprocessing.rst:1303
msgid "The results printed are ::"
msgstr "結果は以下のように表示されます ::"

#: ../../library/multiprocessing.rst:1316
msgid "Managers"
msgstr "マネージャー"

#: ../../library/multiprocessing.rst:1318
msgid ""
"Managers provide a way to create data which can be shared between different "
"processes. A manager object controls a server process which manages *shared "
"objects*.  Other processes can access the shared objects by using proxies."
msgstr "Manager は別のプロセス間で共有されるデータの作成方法を提供します。マネージャオブジェクトは *共有オブジェクト* を管理するサーバプロセスを制御します。他のプロセスはプロキシ経由で共有オブジェクトへアクセスすることができます。"

#: ../../library/multiprocessing.rst:1324
msgid ""
"Returns a started :class:`~multiprocessing.managers.SyncManager` object "
"which can be used for sharing objects between processes.  The returned "
"manager object corresponds to a spawned child process and has methods which "
"will create shared objects and return corresponding proxies."
msgstr "プロセス間でオブジェクトを共有するために使用される :class:`~multiprocessing.managers.SyncManager` オブジェクトを返します。返されたマネージャーオブジェクトは生成される子プロセスに対応付けられ、共有オブジェクトを作成するメソッドや、共有オブジェクトに対応するプロキシを返すメソッドを持ちます。"

#: ../../library/multiprocessing.rst:1332
msgid ""
"Manager processes will be shutdown as soon as they are garbage collected or "
"their parent process exits.  The manager classes are defined in the "
":mod:`multiprocessing.managers` module:"
msgstr "マネージャープロセスは親プロセスが終了するか、ガベージコレクトされると停止します。マネージャークラスは :mod:`multiprocessing.managers` モジュールで定義されています:"

#: ../../library/multiprocessing.rst:1338
msgid "Create a BaseManager object."
msgstr "BaseManager オブジェクトを作成します。"

#: ../../library/multiprocessing.rst:1340
msgid ""
"Once created one should call :meth:`start` or "
"``get_server().serve_forever()`` to ensure that the manager object refers to"
" a started manager process."
msgstr "作成後、:meth:`start` か ``get_server().serve_forever()`` を呼び出して、マネージャーオブジェクトが確実に開始されたマネージャープロセスを参照するようにしてください。"

#: ../../library/multiprocessing.rst:1343
msgid ""
"*address* is the address on which the manager process listens for new "
"connections.  If *address* is ``None`` then an arbitrary one is chosen."
msgstr "*address* はマネージャープロセスが新たなコネクションを待ち受けるアドレスです。*address* が ``None`` の場合、任意のアドレスが設定されます。"

#: ../../library/multiprocessing.rst:1346
msgid ""
"*authkey* is the authentication key which will be used to check the validity"
" of incoming connections to the server process.  If *authkey* is ``None`` "
"then ``current_process().authkey``.  Otherwise *authkey* is used and it must"
" be a string."
msgstr "*authkey* はサーバプロセスへ接続しようとするコネクションの正当性を検証するために使用される認証キーです。 *authkey* が ``None`` の場合 ``current_process().authkey`` が使用されます。 *authkey* を使用する場合は文字列でなければなりません。"

#: ../../library/multiprocessing.rst:1353
msgid ""
"Start a subprocess to start the manager.  If *initializer* is not ``None`` "
"then the subprocess will call ``initializer(*initargs)`` when it starts."
msgstr "マネージャーを開始するためにサブプロセスを開始します。*initializer* が ``None`` でなければ、サブプロセスは開始時に ``initializer(*initargs)`` を呼び出します。"

#: ../../library/multiprocessing.rst:1358
msgid ""
"Returns a :class:`Server` object which represents the actual server under "
"the control of the Manager. The :class:`Server` object supports the "
":meth:`serve_forever` method::"
msgstr "マネージャーの制御下にある実際のサーバーを表す :class:`Server` オブジェクトを返します。 :class:`Server` オブジェクトは :meth:`serve_forever` メソッドをサポートします::"

#: ../../library/multiprocessing.rst:1367
msgid ":class:`Server` additionally has an :attr:`address` attribute."
msgstr ":class:`Server` はさらに :attr:`address` 属性も持っています。"

#: ../../library/multiprocessing.rst:1371
msgid "Connect a local manager object to a remote manager process::"
msgstr "ローカルからリモートのマネージャーオブジェクトへ接続します::"

#: ../../library/multiprocessing.rst:1379
msgid ""
"Stop the process used by the manager.  This is only available if "
":meth:`start` has been used to start the server process."
msgstr "マネージャーが使用するプロセスを停止します。これはサーバープロセスを開始するために :meth:`start` が使用された場合のみ有効です。"

#: ../../library/multiprocessing.rst:1382
msgid "This can be called multiple times."
msgstr "これは複数回呼び出すことができます。"

#: ../../library/multiprocessing.rst:1386
msgid ""
"A classmethod which can be used for registering a type or callable with the "
"manager class."
msgstr "マネージャークラスで呼び出し可能オブジェクト(callable)や型を登録するために使用されるクラスメソッドです。"

#: ../../library/multiprocessing.rst:1389
msgid ""
"*typeid* is a \"type identifier\" which is used to identify a particular "
"type of shared object.  This must be a string."
msgstr "*typeid* は特に共有オブジェクトの型を識別するために使用される \"型識別子\" です。これは文字列でなければなりません。"

#: ../../library/multiprocessing.rst:1392
msgid ""
"*callable* is a callable used for creating objects for this type identifier."
"  If a manager instance will be created using the :meth:`from_address` "
"classmethod or if the *create_method* argument is ``False`` then this can be"
" left as ``None``."
msgstr "*callable* はこの型識別子のオブジェクトを作成するために使用される呼び出し可能オブジェクトです。マネージャインスタンスが :meth:`from_address` クラスメソッドを使用して作成されるか、 *create_method* 引数が ``False`` の場合は ``None`` でも構いません。"

#: ../../library/multiprocessing.rst:1397
msgid ""
"*proxytype* is a subclass of :class:`BaseProxy` which is used to create "
"proxies for shared objects with this *typeid*.  If ``None`` then a proxy "
"class is created automatically."
msgstr "*proxytype* はこの *typeid* で共有オブジェクトのプロキシを作成するために使用される :class:`BaseProxy` のサブクラスです。 ``None`` の場合、プロキシクラスは自動的に作成されます。"

#: ../../library/multiprocessing.rst:1401
msgid ""
"*exposed* is used to specify a sequence of method names which proxies for "
"this typeid should be allowed to access using :meth:`BaseProxy._callmethod`."
"  (If *exposed* is ``None`` then :attr:`proxytype._exposed_` is used instead"
" if it exists.)  In the case where no exposed list is specified, all "
"\"public methods\" of the shared object will be accessible.  (Here a "
"\"public method\" means any attribute which has a :meth:`~object.__call__` "
"method and whose name does not begin with ``'_'``.)"
msgstr "*exposed* は :meth:`BaseProxy._callmethod` を使用したアクセスが許されるべき typeid をプロキシするメソッド名のシーケンスを指定するために使用されます (*exposed* が ``None`` の場合 :attr:`proxytype._exposed_` が存在すればそれが代わりに使用されます)。*exposed* リストが指定されない場合、共有オブジェクトのすべての \"パブリックメソッド\" がアクセス可能になります。 (ここでいう \"パブリックメソッド\" とは :meth:`~object.__call__` メソッドを持つものと名前が ``'_'`` で始まらないあらゆる属性を意味します。)"

#: ../../library/multiprocessing.rst:1410
msgid ""
"*method_to_typeid* is a mapping used to specify the return type of those "
"exposed methods which should return a proxy.  It maps method names to typeid"
" strings.  (If *method_to_typeid* is ``None`` then "
":attr:`proxytype._method_to_typeid_` is used instead if it exists.)  If a "
"method's name is not a key of this mapping or if the mapping is ``None`` "
"then the object returned by the method will be copied by value."
msgstr "*method_to_typeid* はプロキシが返す exposed メソッドの返り値の型を指定するために使用されるマッピングで、メソッド名を typeid 文字列にマップします。 (*method_to_typeid* が ``None`` の場合 :attr:`proxytype._method_to_typeid_` が存在すれば、それが代わりに使用されます。) メソッド名がこのマッピングのキーではないか、マッピングが ``None`` の場合、そのメソッドによって返されるオブジェクトが値として (by value) コピーされます。"

#: ../../library/multiprocessing.rst:1417
msgid ""
"*create_method* determines whether a method should be created with name "
"*typeid* which can be used to tell the server process to create a new shared"
" object and return a proxy for it.  By default it is ``True``."
msgstr "*create_method* は、共有オブジェクトを作成し、それに対するプロキシを返すようサーバープロセスに伝える、名前 *typeid* のメソッドを作成するかを決定します。デフォルトでは ``True`` です。"

#: ../../library/multiprocessing.rst:1421
msgid ":class:`BaseManager` instances also have one read-only property:"
msgstr ":class:`BaseManager` インスタンスも読み取り専用属性を1つ持っています:"

#: ../../library/multiprocessing.rst:1425
msgid "The address used by the manager."
msgstr "マネージャーが使用するアドレスです。"

#: ../../library/multiprocessing.rst:1430
msgid ""
"A subclass of :class:`BaseManager` which can be used for the synchronization"
" of processes.  Objects of this type are returned by "
":func:`multiprocessing.Manager`."
msgstr "プロセス間の同期のために使用される :class:`BaseManager` のサブクラスです。 :func:`multiprocessing.Manager` はこの型のオブジェクトを返します。"

#: ../../library/multiprocessing.rst:1434
msgid "It also supports creation of shared lists and dictionaries."
msgstr "また共有のリストやディクショナリの作成もサポートします。"

#: ../../library/multiprocessing.rst:1438
msgid ""
"Create a shared :class:`threading.BoundedSemaphore` object and return a "
"proxy for it."
msgstr "共有 :class:`threading.BoundedSemaphore` オブジェクトを作成して、そのプロキシを返します。"

#: ../../library/multiprocessing.rst:1443
msgid ""
"Create a shared :class:`threading.Condition` object and return a proxy for "
"it."
msgstr "共有 :class:`threading.Condition` オブジェクトを作成して、そのプロキシを返します。"

#: ../../library/multiprocessing.rst:1446
msgid ""
"If *lock* is supplied then it should be a proxy for a "
":class:`threading.Lock` or :class:`threading.RLock` object."
msgstr "*lock* が提供される場合 :class:`threading.Lock` か :class:`threading.RLock` オブジェクトのためのプロキシになります。"

#: ../../library/multiprocessing.rst:1451
msgid ""
"Create a shared :class:`threading.Event` object and return a proxy for it."
msgstr "共有 :class:`threading.Event` オブジェクトを作成して、そのプロキシを返します。"

#: ../../library/multiprocessing.rst:1455
msgid ""
"Create a shared :class:`threading.Lock` object and return a proxy for it."
msgstr "共有 :class:`threading.Lock` オブジェクトを作成して、そのプロキシを返します。"

#: ../../library/multiprocessing.rst:1459
msgid "Create a shared :class:`Namespace` object and return a proxy for it."
msgstr "共有 :class:`Namespace` オブジェクトを作成して、そのプロキシを返します。"

#: ../../library/multiprocessing.rst:1463
msgid "Create a shared :class:`Queue.Queue` object and return a proxy for it."
msgstr "共有 :class:`Queue.Queue` オブジェクトを作成して、そのプロキシを返します。"

#: ../../library/multiprocessing.rst:1467
msgid ""
"Create a shared :class:`threading.RLock` object and return a proxy for it."
msgstr "共有 :class:`threading.RLock` オブジェクトを作成して、そのプロキシを返します。"

#: ../../library/multiprocessing.rst:1471
msgid ""
"Create a shared :class:`threading.Semaphore` object and return a proxy for "
"it."
msgstr "共有 :class:`threading.Semaphore` オブジェクトを作成して、そのプロキシを返します。"

#: ../../library/multiprocessing.rst:1476
msgid "Create an array and return a proxy for it."
msgstr "配列を作成して、そのプロキシを返します。"

#: ../../library/multiprocessing.rst:1480
msgid ""
"Create an object with a writable ``value`` attribute and return a proxy for "
"it."
msgstr "書き込み可能な ``value`` 属性を作成して、そのプロキシを返します。"

#: ../../library/multiprocessing.rst:1487
msgid "Create a shared ``dict`` object and return a proxy for it."
msgstr "共有 ``dict`` オブジェクトを作成して、そのプロキシを返します。"

#: ../../library/multiprocessing.rst:1492
msgid "Create a shared ``list`` object and return a proxy for it."
msgstr "共有 ``list`` オブジェクトを作成して、そのプロキシを返します。"

#: ../../library/multiprocessing.rst:1496
msgid ""
"Modifications to mutable values or items in dict and list proxies will not "
"be propagated through the manager, because the proxy has no way of knowing "
"when its values or items are modified.  To modify such an item, you can re-"
"assign the modified object to the container proxy::"
msgstr "プロキシには、自身の持つ辞書とリストのミュータブルな値や項目がいつ変更されたのかを知る方法がないため、これらの値や項目の変更はマネージャーを通して伝播しません。このような要素を変更するには、コンテナーのプロキシに変更されたオブジェクトを再代入してください::"

#: ../../library/multiprocessing.rst:1514
msgid "Namespace objects"
msgstr "Namespace オブジェクト"

#: ../../library/multiprocessing.rst:1516
msgid ""
"A namespace object has no public methods, but does have writable attributes."
" Its representation shows the values of its attributes."
msgstr "Namespace オブジェクトにはパブリックなメソッドはありませんが、書き込み可能な属性を持ちます。そのオブジェクト表現はその属性の値を表示します。"

#: ../../library/multiprocessing.rst:1519
msgid ""
"However, when using a proxy for a namespace object, an attribute beginning "
"with ``'_'`` will be an attribute of the proxy and not an attribute of the "
"referent:"
msgstr "しかし、Namespace オブジェクトのためにプロキシを使用するとき ``'_'`` が先頭に付く属性はプロキシの属性になり、参照対象の属性にはなりません:"

#: ../../library/multiprocessing.rst:1534
msgid "Customized managers"
msgstr "カスタマイズされたマネージャー"

#: ../../library/multiprocessing.rst:1536
msgid ""
"To create one's own manager, one creates a subclass of :class:`BaseManager` "
"and uses the :meth:`~BaseManager.register` classmethod to register new types"
" or callables with the manager class.  For example::"
msgstr "独自のマネージャーを作成するには、:class:`BaseManager` のサブクラスを作成して、 マネージャークラスで呼び出し可能なオブジェクトか新たな型を登録するために :meth:`~BaseManager.register` クラスメソッドを使用します。例えば::"

#: ../../library/multiprocessing.rst:1562
msgid "Using a remote manager"
msgstr "リモートマネージャーを使用する"

#: ../../library/multiprocessing.rst:1564
msgid ""
"It is possible to run a manager server on one machine and have clients use "
"it from other machines (assuming that the firewalls involved allow it)."
msgstr "あるマシン上でマネージャーサーバーを実行して、他のマシンからそのサーバーを使用するクライアントを持つことができます(ファイアウォールを通過できることが前提)。"

#: ../../library/multiprocessing.rst:1567
msgid ""
"Running the following commands creates a server for a single shared queue "
"which remote clients can access::"
msgstr "次のコマンドを実行することでリモートクライアントからアクセスを受け付ける1つの共有キューのためにサーバーを作成します::"

#: ../../library/multiprocessing.rst:1579
msgid "One client can access the server as follows::"
msgstr "あるクライアントからサーバーへのアクセスは次のようになります::"

#: ../../library/multiprocessing.rst:1589
msgid "Another client can also use it::"
msgstr "別のクライアントもそれを使用することができます::"

#: ../../library/multiprocessing.rst:1600
msgid ""
"Local processes can also access that queue, using the code from above on the"
" client to access it remotely::"
msgstr "ローカルプロセスもそのキューへアクセスすることができます。クライアント上で上述のコードを使用してアクセスします::"

#: ../../library/multiprocessing.rst:1623
msgid "Proxy Objects"
msgstr "Proxy オブジェクト"

#: ../../library/multiprocessing.rst:1625
msgid ""
"A proxy is an object which *refers* to a shared object which lives "
"(presumably) in a different process.  The shared object is said to be the "
"*referent* of the proxy.  Multiple proxy objects may have the same referent."
msgstr "プロキシは別のプロセスで(おそらく)有効な共有オブジェクトを *参照する* オブジェクトです。共有オブジェクトはプロキシの *参照対象* になるということができます。複数のプロキシオブジェクトが同じ参照対象を持つ可能性もあります。"

#: ../../library/multiprocessing.rst:1629
msgid ""
"A proxy object has methods which invoke corresponding methods of its "
"referent (although not every method of the referent will necessarily be "
"available through the proxy).  A proxy can usually be used in most of the "
"same ways that its referent can:"
msgstr "プロキシオブジェクトはその参照対象が持つ対応メソッドを実行するメソッドを持ちます。(そうは言っても、参照対象のすべてのメソッドが必ずしもプロキシ経由で利用可能ではありません) プロキシは通常その参照対象ができることと同じ方法で使用されます:"

#: ../../library/multiprocessing.rst:1648
msgid ""
"Notice that applying :func:`str` to a proxy will return the representation "
"of the referent, whereas applying :func:`repr` will return the "
"representation of the proxy."
msgstr "プロキシに :func:`str` を適用すると参照対象のオブジェクト表現を返すのに対して、 :func:`repr` を適用するとプロキシのオブジェクト表現を返すことに注意してください。"

#: ../../library/multiprocessing.rst:1652
msgid ""
"An important feature of proxy objects is that they are picklable so they can"
" be passed between processes.  Note, however, that if a proxy is sent to the"
" corresponding manager's process then unpickling it will produce the "
"referent itself.  This means, for example, that one shared object can "
"contain a second:"
msgstr "プロキシオブジェクトの重要な機能はプロセス間で受け渡し可能な pickle 化ができることです。しかし、プロキシが対応するマネージャープロセスに対して送信される場合、そのプロキシを unpickle するとその参照対象を生成することを覚えておいてください。例えば、これはある共有オブジェクトに別の共有オブジェクトが含められることを意味します:"

#: ../../library/multiprocessing.rst:1670
msgid ""
"The proxy types in :mod:`multiprocessing` do nothing to support comparisons "
"by value.  So, for instance, we have:"
msgstr ":mod:`multiprocessing` のプロキシ型は値による比較に対して何もサポートしません。そのため、例えば以下のようになります:"

#: ../../library/multiprocessing.rst:1678
msgid ""
"One should just use a copy of the referent instead when making comparisons."
msgstr "比較を行いたいときは参照対象のコピーを使用してください。"

#: ../../library/multiprocessing.rst:1682
msgid "Proxy objects are instances of subclasses of :class:`BaseProxy`."
msgstr "プロキシオブジェクトは :class:`BaseProxy` のサブクラスのインスタンスです。"

#: ../../library/multiprocessing.rst:1686
msgid "Call and return the result of a method of the proxy's referent."
msgstr "プロキシの参照対象のメソッドの実行結果を返します。"

#: ../../library/multiprocessing.rst:1688
msgid ""
"If ``proxy`` is a proxy whose referent is ``obj`` then the expression ::"
msgstr "``proxy`` がプロキシで、プロキシ内の参照対象が ``obj`` ならこの式 ::"

#: ../../library/multiprocessing.rst:1692
msgid "will evaluate the expression ::"
msgstr "はこの式を評価します ::"

#: ../../library/multiprocessing.rst:1696
msgid "in the manager's process."
msgstr "(マネージャープロセス内の)。"

#: ../../library/multiprocessing.rst:1698
msgid ""
"The returned value will be a copy of the result of the call or a proxy to a "
"new shared object -- see documentation for the *method_to_typeid* argument "
"of :meth:`BaseManager.register`."
msgstr "返される値はその呼び出し結果のコピーか、新たな共有オブジェクトに対するプロキシになります。詳細は :meth:`BaseManager.register` の *method_to_typeid* 引数のドキュメントを参照してください。"

#: ../../library/multiprocessing.rst:1702
msgid ""
"If an exception is raised by the call, then is re-raised by "
":meth:`_callmethod`.  If some other exception is raised in the manager's "
"process then this is converted into a :exc:`RemoteError` exception and is "
"raised by :meth:`_callmethod`."
msgstr "その呼び出しによって例外が発生した場合、:meth:`_callmethod` によってその例外は再送出されます。他の例外がマネージャープロセスで発生したなら、:exc:`RemoteError` 例外に変換されたものが :meth:`_callmethod` によって送出されます。"

#: ../../library/multiprocessing.rst:1707
msgid ""
"Note in particular that an exception will be raised if *methodname* has not "
"been *exposed*."
msgstr "特に *methodname* が *公開* されていない場合は例外が発生することに注意してください。"

#: ../../library/multiprocessing.rst:1710
msgid "An example of the usage of :meth:`_callmethod`:"
msgstr ":meth:`_callmethod` の使用例になります:"

#: ../../library/multiprocessing.rst:1726
msgid "Return a copy of the referent."
msgstr "参照対象のコピーを返します。"

#: ../../library/multiprocessing.rst:1728
msgid "If the referent is unpicklable then this will raise an exception."
msgstr "参照対象が unpickle 化できるなら例外を発生します。"

#: ../../library/multiprocessing.rst:1732
msgid "Return a representation of the proxy object."
msgstr "プロキシオブジェクトのオブジェクト表現を返します。"

#: ../../library/multiprocessing.rst:1736
msgid "Return the representation of the referent."
msgstr "参照対象のオブジェクト表現を返します。"

#: ../../library/multiprocessing.rst:1740
msgid "Cleanup"
msgstr "クリーンアップ"

#: ../../library/multiprocessing.rst:1742
msgid ""
"A proxy object uses a weakref callback so that when it gets garbage "
"collected it deregisters itself from the manager which owns its referent."
msgstr "プロキシオブジェクトは弱参照(weakref)コールバックを使用します。プロキシオブジェクトがガベージコレクトされるときにその参照対象が所有するマネージャーからその登録を取り消せるようにするためです。"

#: ../../library/multiprocessing.rst:1745
msgid ""
"A shared object gets deleted from the manager process when there are no "
"longer any proxies referring to it."
msgstr "共有オブジェクトはプロキシが参照しなくなったときにマネージャープロセスから削除されます。"

#: ../../library/multiprocessing.rst:1750
msgid "Process Pools"
msgstr "プロセスプール"

#: ../../library/multiprocessing.rst:1755
msgid ""
"One can create a pool of processes which will carry out tasks submitted to "
"it with the :class:`Pool` class."
msgstr ":class:`Pool` クラスでタスクを実行するプロセスのプールを作成することができます。"

#: ../../library/multiprocessing.rst:1760
msgid ""
"A process pool object which controls a pool of worker processes to which "
"jobs can be submitted.  It supports asynchronous results with timeouts and "
"callbacks and has a parallel map implementation."
msgstr "プロセスプールオブジェクトは、ジョブを送り込めるワーカープロセスのプールを制御します。タイムアウトやコールバックのある非同期の実行をサポートし、並列 map 実装を持ちます。"

#: ../../library/multiprocessing.rst:1764
msgid ""
"*processes* is the number of worker processes to use.  If *processes* is "
"``None`` then the number returned by :func:`cpu_count` is used.  If "
"*initializer* is not ``None`` then each worker process will call "
"``initializer(*initargs)`` when it starts."
msgstr "*processes* は使用するワーカープロセスの数です。 *processes* が ``None`` の場合 :func:`cpu_count` が返す数を使用します。 *initializer* が ``None`` でない場合、各ワーカープロセスが開始時に ``initializer(*initargs)`` を呼び出します。"

#: ../../library/multiprocessing.rst:1769
msgid ""
"Note that the methods of the pool object should only be called by the "
"process which created the pool."
msgstr "プールオブジェクトのメソッドは、そのプールを作成したプロセスのみが呼び出すべきです。"

#: ../../library/multiprocessing.rst:1772
msgid ""
"*maxtasksperchild* is the number of tasks a worker process can complete "
"before it will exit and be replaced with a fresh worker process, to enable "
"unused resources to be freed. The default *maxtasksperchild* is None, which "
"means worker processes will live as long as the pool."
msgstr "*maxtasksperchild* は、ワーカープロセスが exit して新たなワーカープロセスと置き替えられるまでの間に、ワーカープロセスが完了することのできるタスクの数です。この設定により未利用のリソースが解放されるようなります。デフォルトの *maxtasksperchild* は None で、これはワーカープロセスがプールと同じ期間だけ生き続けるということを意味します。"

#: ../../library/multiprocessing.rst:1780
msgid ""
"Worker processes within a :class:`Pool` typically live for the complete "
"duration of the Pool's work queue. A frequent pattern found in other systems"
" (such as Apache, mod_wsgi, etc) to free resources held by workers is to "
"allow a worker within a pool to complete only a set amount of work before "
"being exiting, being cleaned up and a new process spawned to replace the old"
" one. The *maxtasksperchild* argument to the :class:`Pool` exposes this "
"ability to the end user."
msgstr ":class:`Pool` 中のワーカープロセスは、典型的にはプールのワークキューの存続期間とちょうど同じだけ生き続けます。ワーカーに確保されたリソースを解放するために (Apache, mod_wsgi, などのような) 他のシステムによく見られるパターンは、プール内のワーカーが設定された量だけの仕事を完了したら exit とクリーンアップを行い、古いプロセスを置き換えるために新しいプロセスを生成するというものです。 :class:`Pool` の *maxtasksperchild* 引数は、この能力をエンドユーザーに提供します。"

#: ../../library/multiprocessing.rst:1790
msgid ""
"Equivalent of the :func:`apply` built-in function.  It blocks until the "
"result is ready, so :meth:`apply_async` is better suited for performing work"
" in parallel. Additionally, *func* is only executed in one of the workers of"
" the pool."
msgstr "組み込み関数 :func:`apply` の同等品で、結果が取得出来るようになるまでブロックします。ですから作業を並列に実行するのにより相応しいのは :meth:`apply_async` です。加えて *func* はプールのワーカーのうち一つの中で実行されるに過ぎません。"

#: ../../library/multiprocessing.rst:1797
msgid "A variant of the :meth:`apply` method which returns a result object."
msgstr ":meth:`apply` メソッドの派生版で結果オブジェクトを返します。"

#: ../../library/multiprocessing.rst:1799
#: ../../library/multiprocessing.rst:1817
msgid ""
"If *callback* is specified then it should be a callable which accepts a "
"single argument.  When the result becomes ready *callback* is applied to it "
"(unless the call failed).  *callback* should complete immediately since "
"otherwise the thread which handles the results will get blocked."
msgstr "*callback* を指定する場合は 1 つの引数を受け取る呼び出し可能オブジェクトでなければなりません。その結果を返せるようになったときに *callback* が結果オブジェクトに対して (その呼び出しが失敗しない限り)適用されます。コールバックは直ちに完了すべきです。なぜなら、そうしなければ、結果を扱うスレッドがブロックするからです。"

#: ../../library/multiprocessing.rst:1806
msgid ""
"A parallel equivalent of the :func:`map` built-in function (it supports only"
" one *iterable* argument though).  It blocks until the result is ready."
msgstr ":func:`map` 組み込み関数の並列版です (*iterable* な引数を1つだけサポートするという違いはありますが)。結果が出るまでブロックします。"

#: ../../library/multiprocessing.rst:1809
msgid ""
"This method chops the iterable into a number of chunks which it submits to "
"the process pool as separate tasks.  The (approximate) size of these chunks "
"can be specified by setting *chunksize* to a positive integer."
msgstr "このメソッドはイテラブルをいくつものチャンクに分割し、プロセスプールにそれぞれ独立したタスクとして送ります。(概算の) チャンクサイズは *chunksize* を正の整数に設定することで指定できます。"

#: ../../library/multiprocessing.rst:1815
msgid "A variant of the :meth:`.map` method which returns a result object."
msgstr ":meth:`.map` メソッドの派生版で結果オブジェクトを返します。"

#: ../../library/multiprocessing.rst:1824
msgid "An equivalent of :func:`itertools.imap`."
msgstr ":func:`itertools.imap` と同じです。"

#: ../../library/multiprocessing.rst:1826
msgid ""
"The *chunksize* argument is the same as the one used by the :meth:`.map` "
"method.  For very long iterables using a large value for *chunksize* can "
"make the job complete **much** faster than using the default value of ``1``."
msgstr "*chunksize* 引数は :meth:`.map` メソッドで使用されるものと同じです。 引数 iterable がとても長いなら *chunksize* に大きな値を指定して使用する方がデフォルト値の ``1`` を使用するよりもジョブの完了が **かなり** 速くなります。"

#: ../../library/multiprocessing.rst:1831
msgid ""
"Also if *chunksize* is ``1`` then the :meth:`!next` method of the iterator "
"returned by the :meth:`imap` method has an optional *timeout* parameter: "
"``next(timeout)`` will raise :exc:`multiprocessing.TimeoutError` if the "
"result cannot be returned within *timeout* seconds."
msgstr "また *chunksize* が ``1`` の場合 :meth:`imap` メソッドが返すイテレーターの :meth:`!next` メソッドはオプションで *timeout* パラメーターを持ちます。 ``next(timeout)`` は、その結果が *timeout* 秒以内に返されないときに :exc:`multiprocessing.TimeoutError` を発生させます。"

#: ../../library/multiprocessing.rst:1838
msgid ""
"The same as :meth:`imap` except that the ordering of the results from the "
"returned iterator should be considered arbitrary.  (Only when there is only "
"one worker process is the order guaranteed to be \"correct\".)"
msgstr "イテレーターが返す結果の順番が任意の順番で良いと見なされることを除けば :meth:`imap` と同じです。 (ワーカープロセスが1つしかない場合のみ \"正しい\" 順番になることが保証されます。)"

#: ../../library/multiprocessing.rst:1844
msgid ""
"Prevents any more tasks from being submitted to the pool.  Once all the "
"tasks have been completed the worker processes will exit."
msgstr "これ以上プールでタスクが実行されないようにします。すべてのタスクが完了した後でワーカープロセスが終了します。"

#: ../../library/multiprocessing.rst:1849
msgid ""
"Stops the worker processes immediately without completing outstanding work."
"  When the pool object is garbage collected :meth:`terminate` will be called"
" immediately."
msgstr "実行中の処理を完了させずにワーカープロセスをすぐに停止します。プールオブジェクトがガベージコレクトされるときに :meth:`terminate` が呼び出されます。"

#: ../../library/multiprocessing.rst:1855
msgid ""
"Wait for the worker processes to exit.  One must call :meth:`close` or "
":meth:`terminate` before using :meth:`join`."
msgstr "ワーカープロセスが終了するのを待ちます。 :meth:`join` を使用する前に :meth:`close` か :meth:`terminate` を呼び出さなければなりません。"

#: ../../library/multiprocessing.rst:1861
msgid ""
"The class of the result returned by :meth:`Pool.apply_async` and "
":meth:`Pool.map_async`."
msgstr ":meth:`Pool.apply_async` や :meth:`Pool.map_async` で返される結果のクラスです。"

#: ../../library/multiprocessing.rst:1866
msgid ""
"Return the result when it arrives.  If *timeout* is not ``None`` and the "
"result does not arrive within *timeout* seconds then "
":exc:`multiprocessing.TimeoutError` is raised.  If the remote call raised an"
" exception then that exception will be reraised by :meth:`get`."
msgstr "結果を受け取ったときに返します。 *timeout* が ``None`` ではなくて、その結果が *timeout* 秒以内に受け取れない場合 :exc:`multiprocessing.TimeoutError` が発生します。リモートの呼び出しが例外を発生させる場合、その例外は :meth:`get` が再発生させます。"

#: ../../library/multiprocessing.rst:1873
msgid "Wait until the result is available or until *timeout* seconds pass."
msgstr "その結果が有効になるか *timeout* 秒経つまで待ちます。"

#: ../../library/multiprocessing.rst:1877
msgid "Return whether the call has completed."
msgstr "その呼び出しが完了しているかどうかを返します。"

#: ../../library/multiprocessing.rst:1881
msgid ""
"Return whether the call completed without raising an exception.  Will raise "
":exc:`AssertionError` if the result is not ready."
msgstr "その呼び出しが例外を発生させることなく完了したかどうかを返します。その結果が返せる状態でない場合 :exc:`AssertionError` が発生します。"

#: ../../library/multiprocessing.rst:1884
msgid "The following example demonstrates the use of a pool::"
msgstr "次の例はプールの使用例を紹介します::"

#: ../../library/multiprocessing.rst:1912
msgid "Listeners and Clients"
msgstr "リスナーとクライアント"

#: ../../library/multiprocessing.rst:1917
msgid ""
"Usually message passing between processes is done using queues or by using "
":class:`~multiprocessing.Connection` objects returned by "
":func:`~multiprocessing.Pipe`."
msgstr "通常、プロセス間でメッセージを渡すにはキューを使用するか :func:`~multiprocessing.Pipe` が返す :class:`~multiprocessing.Connection` オブジェクトを使用します。"

#: ../../library/multiprocessing.rst:1921
msgid ""
"However, the :mod:`multiprocessing.connection` module allows some extra "
"flexibility.  It basically gives a high level message oriented API for "
"dealing with sockets or Windows named pipes, and also has support for "
"*digest authentication* using the :mod:`hmac` module."
msgstr "しかし :mod:`multiprocessing.connection` モジュールはさらに柔軟な仕組みがあります。基本的にはソケットもしくは Windows の名前付きパイプを扱う高レベルのメッセージ指向 API を提供して :mod:`hmac` モジュールを使用して *ダイジェスト認証* もサポートします。"

#: ../../library/multiprocessing.rst:1929
msgid ""
"Send a randomly generated message to the other end of the connection and "
"wait for a reply."
msgstr "ランダム生成したメッセージをコネクションの相手側へ送信して応答を待ちます。"

#: ../../library/multiprocessing.rst:1932
msgid ""
"If the reply matches the digest of the message using *authkey* as the key "
"then a welcome message is sent to the other end of the connection.  "
"Otherwise :exc:`AuthenticationError` is raised."
msgstr "その応答がキーとして *authkey* を使用するメッセージのダイジェストと一致する場合、コネクションの相手側へ歓迎メッセージを送信します。そうでなければ :exc:`AuthenticationError` を発生させます。"

#: ../../library/multiprocessing.rst:1938
msgid ""
"Receive a message, calculate the digest of the message using *authkey* as "
"the key, and then send the digest back."
msgstr "メッセージを受信して、そのキーとして *authkey* を使用するメッセージのダイジェストを計算し、ダイジェストを送り返します。"

#: ../../library/multiprocessing.rst:1941
msgid ""
"If a welcome message is not received, then :exc:`AuthenticationError` is "
"raised."
msgstr "歓迎メッセージを受け取れない場合 :exc:`AuthenticationError` が発生します。"

#: ../../library/multiprocessing.rst:1946
msgid ""
"Attempt to set up a connection to the listener which is using address "
"*address*, returning a :class:`~multiprocessing.Connection`."
msgstr "*address* で渡したアドレスを使用するリスナーに対してコネクションを確立しようとして :class:`~multiprocessing.Connection` を返します。"

#: ../../library/multiprocessing.rst:1949
msgid ""
"The type of the connection is determined by *family* argument, but this can "
"generally be omitted since it can usually be inferred from the format of "
"*address*. (See :ref:`multiprocessing-address-formats`)"
msgstr "コネクション種別は *family* 引数で決定しますが、一般的には *address* のフォーマットから推測できるので、これは指定されません。 (:ref:`multiprocessing-address-formats` を参照してください)"

#: ../../library/multiprocessing.rst:1953
msgid ""
"If *authenticate* is ``True`` or *authkey* is a string then digest "
"authentication is used.  The key used for authentication will be either "
"*authkey* or ``current_process().authkey)`` if *authkey* is ``None``. If "
"authentication fails then :exc:`AuthenticationError` is raised.  See :ref"
":`multiprocessing-auth-keys`."
msgstr "*authenticate* が ``True`` か *authkey* が文字列の場合、ダイジェスト認証が使用されます。認証に使用されるキーは *authkey* 、又は *authkey* が ``None`` の場合は ``current_process().authkey`` のどちらかです。認証が失敗した場合 :exc:`AuthenticationError` が発生します。 :ref:`multiprocessing-auth-keys` を参照してください。"

#: ../../library/multiprocessing.rst:1961
msgid ""
"A wrapper for a bound socket or Windows named pipe which is 'listening' for "
"connections."
msgstr "コネクションを '待ち受ける' 束縛されたソケットか Windows の名前付きパイプのラッパーです。"

#: ../../library/multiprocessing.rst:1964
msgid ""
"*address* is the address to be used by the bound socket or named pipe of the"
" listener object."
msgstr "*address* はリスナーオブジェクトの束縛されたソケットか名前付きパイプが使用するアドレスです。"

#: ../../library/multiprocessing.rst:1969
msgid ""
"If an address of '0.0.0.0' is used, the address will not be a connectable "
"end point on Windows. If you require a connectable end-point, you should use"
" '127.0.0.1'."
msgstr "'0.0.0.0' のアドレスを使用する場合、Windows 上の終点へ接続することができません。終点へ接続したい場合は '127.0.0.1' を使用すべきです。"

#: ../../library/multiprocessing.rst:1973
msgid ""
"*family* is the type of socket (or named pipe) to use.  This can be one of "
"the strings ``'AF_INET'`` (for a TCP socket), ``'AF_UNIX'`` (for a Unix "
"domain socket) or ``'AF_PIPE'`` (for a Windows named pipe).  Of these only "
"the first is guaranteed to be available.  If *family* is ``None`` then the "
"family is inferred from the format of *address*.  If *address* is also "
"``None`` then a default is chosen.  This default is the family which is "
"assumed to be the fastest available.  See :ref:`multiprocessing-address-"
"formats`.  Note that if *family* is ``'AF_UNIX'`` and address is ``None`` "
"then the socket will be created in a private temporary directory created "
"using :func:`tempfile.mkstemp`."
msgstr "*family* は使用するソケット(名前付きパイプ)の種別です。これは ``'AF_INET'`` (TCP ソケット), ``'AF_UNIX'`` (Unix ドメインソケット) または ``'AF_PIPE'`` (Windows 名前付きパイプ) という文字列のどれか1つになります。これらのうち ``'AF_INET'`` のみが利用可能であることが保証されています。 *family* が ``None`` の場合 *address* のフォーマットから推測されたものが使用されます。 *address* も ``None`` の場合はデフォルトが選択されます。詳細は :ref:`multiprocessing-address-formats` を参照してください。 *family* が ``'AF_UNIX'`` で *address* が ``None`` の場合 :func:`tempfile.mkstemp` を使用して作成されたプライベートな一時ディレクトリにソケットが作成されます。"

#: ../../library/multiprocessing.rst:1984
msgid ""
"If the listener object uses a socket then *backlog* (1 by default) is passed"
" to the :meth:`~socket.socket.listen` method of the socket once it has been "
"bound."
msgstr "リスナーオブジェクトがソケットを使用する場合、ソケットに束縛されるときに *backlog* (デフォルトでは1つ) がソケットの :meth:`~socket.socket.listen` メソッドに対して渡されます。"

#: ../../library/multiprocessing.rst:1988
msgid ""
"If *authenticate* is ``True`` (``False`` by default) or *authkey* is not "
"``None`` then digest authentication is used."
msgstr "*authenticate* が ``True`` (デフォルトでは ``False``) か *authkey* が ``None`` ではない場合、ダイジェスト認証が使用されます。"

#: ../../library/multiprocessing.rst:1991
msgid ""
"If *authkey* is a string then it will be used as the authentication key; "
"otherwise it must be *None*."
msgstr "*authkey* が文字列の場合、認証キーとして使用されます。そうでない場合は *None* でなければいけません。"

#: ../../library/multiprocessing.rst:1994
msgid ""
"If *authkey* is ``None`` and *authenticate* is ``True`` then "
"``current_process().authkey`` is used as the authentication key.  If "
"*authkey* is ``None`` and *authenticate* is ``False`` then no authentication"
" is done.  If authentication fails then :exc:`AuthenticationError` is "
"raised.  See :ref:`multiprocessing-auth-keys`."
msgstr "*authkey* が ``None`` 且つ *authenticate* が ``True`` の場合 ``current_process().authkey`` が認証キーとして使用されます。 *authkey* が ``None`` 且つ *authentication* が ``False`` の場合、認証は行われません。もし認証が失敗した場合 :exc:`AuthenticationError` が発生します。詳細 :ref:`multiprocessing-auth-keys` を参照してください。"

#: ../../library/multiprocessing.rst:2002
msgid ""
"Accept a connection on the bound socket or named pipe of the listener object"
" and return a :class:`~multiprocessing.Connection` object.  If "
"authentication is attempted and fails, then "
":exc:`~multiprocessing.AuthenticationError` is raised."
msgstr "リスナーオブジェクトの名前付きパイプか束縛されたソケット上でコネクションを受け付けて :class:`~multiprocessing.Connection` オブジェクトを返します。認証が失敗した場合 :exc:`~multiprocessing.AuthenticationError` が発生します。"

#: ../../library/multiprocessing.rst:2009
msgid ""
"Close the bound socket or named pipe of the listener object.  This is called"
" automatically when the listener is garbage collected.  However it is "
"advisable to call it explicitly."
msgstr "リスナーオブジェクトの名前付きパイプか束縛されたソケットをクローズします。これはリスナーがガベージコレクトされるときに自動的に呼ばれます。そうは言っても、明示的に close() を呼び出す方が望ましいです。"

#: ../../library/multiprocessing.rst:2013
msgid "Listener objects have the following read-only properties:"
msgstr "リスナーオブジェクトは次の読み取り専用属性を持っています:"

#: ../../library/multiprocessing.rst:2017
msgid "The address which is being used by the Listener object."
msgstr "リスナーオブジェクトが使用中のアドレスです。"

#: ../../library/multiprocessing.rst:2021
msgid ""
"The address from which the last accepted connection came.  If this is "
"unavailable then it is ``None``."
msgstr "最後にコネクションを受け付けたアドレスです。有効なアドレスがない場合は ``None`` になります。"

#: ../../library/multiprocessing.rst:2025
msgid "The module defines two exceptions:"
msgstr "このモジュールは2つの例外を定義します。"

#: ../../library/multiprocessing.rst:2029
msgid "Exception raised when there is an authentication error."
msgstr "認証エラーが起こったときに例外が発生します。"

#: ../../library/multiprocessing.rst:2032
msgid "**Examples**"
msgstr "**例**"

#: ../../library/multiprocessing.rst:2034
msgid ""
"The following server code creates a listener which uses ``'secret "
"password'`` as an authentication key.  It then waits for a connection and "
"sends some data to the client::"
msgstr "次のサーバーコードは認証キーとして ``'secret password'`` を使用するリスナーを作成します。このサーバーはコネクションを待ってクライアントへデータを送信します::"

#: ../../library/multiprocessing.rst:2056
msgid ""
"The following code connects to the server and receives some data from the "
"server::"
msgstr "次のコードはサーバーへ接続して、サーバーからデータを受信します::"

#: ../../library/multiprocessing.rst:2079
msgid "Address Formats"
msgstr "アドレスフォーマット"

#: ../../library/multiprocessing.rst:2081
msgid ""
"An ``'AF_INET'`` address is a tuple of the form ``(hostname, port)`` where "
"*hostname* is a string and *port* is an integer."
msgstr "``'AF_INET'`` アドレスは ``(hostname, port)`` のタプルになります。 *hostname* は文字列で *port* は整数です。"

#: ../../library/multiprocessing.rst:2084
msgid ""
"An ``'AF_UNIX'`` address is a string representing a filename on the "
"filesystem."
msgstr "``'AF_UNIX'`` アドレスはファイルシステム上のファイル名の文字列です。"

#: ../../library/multiprocessing.rst:2090
msgid "An 'AF_PIPE' address is a string of the form"
msgstr "``'AF_PIPE'`` アドレスは、次の形式を持つ文字列です"

#: ../../library/multiprocessing.rst:2088
msgid ""
":samp:`r'\\\\\\\\.\\\\pipe\\\\{PipeName}'`.  To use :func:`Client` to "
"connect to a named pipe on a remote computer called *ServerName* one should "
"use an address of the form "
":samp:`r'\\\\\\\\{ServerName}\\\\pipe\\\\{PipeName}'` instead."
msgstr ":samp:`r'\\\\\\\\.\\\\pipe\\\\{PipeName}'` 。 *ServerName* という名前のリモートコンピューター上の名前付きパイプに接続するために :func:`Client` を使用するには、代わりに :samp:`r'\\\\\\\\{ServerName}\\\\pipe\\\\{PipeName}'` 形式のアドレスを使用する必要があります。"

#: ../../library/multiprocessing.rst:2092
msgid ""
"Note that any string beginning with two backslashes is assumed by default to"
" be an ``'AF_PIPE'`` address rather than an ``'AF_UNIX'`` address."
msgstr "デフォルトでは、2つのバックスラッシュで始まる文字列は ``'AF_UNIX'`` よりも ``'AF_PIPE'`` として推測されることに注意してください。"

#: ../../library/multiprocessing.rst:2099
msgid "Authentication keys"
msgstr "認証キー"

#: ../../library/multiprocessing.rst:2101
msgid ""
"When one uses :meth:`Connection.recv <multiprocessing.Connection.recv>`, the"
" data received is automatically unpickled.  Unfortunately unpickling data "
"from an untrusted source is a security risk.  Therefore :class:`Listener` "
"and :func:`Client` use the :mod:`hmac` module to provide digest "
"authentication."
msgstr ":meth:`Connection.recv <multiprocessing.Connection.recv>` を使用するとき、データは自動的に unpickle されて受信します。信頼できない接続元からのデータを unpickle することはセキュリティリスクがあります。そのため :class:`Listener` や :func:`Client` はダイジェスト認証を提供するために :mod:`hmac` モジュールを使用します。"

#: ../../library/multiprocessing.rst:2107
msgid ""
"An authentication key is a string which can be thought of as a password: "
"once a connection is established both ends will demand proof that the other "
"knows the authentication key.  (Demonstrating that both ends are using the "
"same key does **not** involve sending the key over the connection.)"
msgstr "認証キーはパスワードとしてみなされる文字列です。コネクションが確立すると、双方の終点で正しい接続先であることを証明するために知っているお互いの認証キーを要求します。 (双方の終点が同じキーを使用して通信しようとしても、コネクション上でそのキーを送信することは **できません** 。)"

#: ../../library/multiprocessing.rst:2112
msgid ""
"If authentication is requested but do authentication key is specified then "
"the return value of ``current_process().authkey`` is used (see "
":class:`~multiprocessing.Process`).  This value will automatically inherited"
" by any :class:`~multiprocessing.Process` object that the current process "
"creates. This means that (by default) all processes of a multi-process "
"program will share a single authentication key which can be used when "
"setting up connections between themselves."
msgstr "認証が要求されて認証キーが指定されている場合 ``current_process().authkey`` の返す値が使用されます。 (詳細は :class:`~multiprocessing.Process` を参照してください。) この値はカレントプロセスを作成する :class:`~multiprocessing.Process` オブジェクトによって自動的に継承されます。これは(デフォルトでは)複数プロセスのプログラムの全プロセスが相互にコネクションを確立するときに使用される1つの認証キーを共有することを意味します。"

#: ../../library/multiprocessing.rst:2120
msgid ""
"Suitable authentication keys can also be generated by using "
":func:`os.urandom`."
msgstr "適当な認証キーを :func:`os.urandom` を使用して生成することもできます。"

#: ../../library/multiprocessing.rst:2124
msgid "Logging"
msgstr "ログ記録"

#: ../../library/multiprocessing.rst:2126
msgid ""
"Some support for logging is available.  Note, however, that the "
":mod:`logging` package does not use process shared locks so it is possible "
"(depending on the handler type) for messages from different processes to get"
" mixed up."
msgstr "ロギングのためにいくつかの機能が利用可能です。しかし :mod:`logging` パッケージは、 (ハンドラー種別に依存して)違うプロセスからのメッセージがごちゃ混ぜになるので、プロセスの共有ロックを使用しないことに注意してください。"

#: ../../library/multiprocessing.rst:2133
msgid ""
"Returns the logger used by :mod:`multiprocessing`.  If necessary, a new one "
"will be created."
msgstr ":mod:`multiprocessing` が使用するロガーを返します。必要に応じて新たなロガーを作成します。"

#: ../../library/multiprocessing.rst:2136
msgid ""
"When first created the logger has level :data:`logging.NOTSET` and no "
"default handler. Messages sent to this logger will not by default propagate "
"to the root logger."
msgstr "最初に作成するとき、ロガーはレベルに :data:`logging.NOTSET` が設定されていてデフォルトハンドラーがありません。このロガーへ送られるメッセージはデフォルトではルートロガーへ伝播されません。"

#: ../../library/multiprocessing.rst:2140
msgid ""
"Note that on Windows child processes will only inherit the level of the "
"parent process's logger -- any other customization of the logger will not be"
" inherited."
msgstr "Windows 上では子プロセスが親プロセスのロガーレベルを継承しないことに注意してください。さらにその他のロガーのカスタマイズ内容もすべて継承されません。"

#: ../../library/multiprocessing.rst:2147
msgid ""
"This function performs a call to :func:`get_logger` but in addition to "
"returning the logger created by get_logger, it adds a handler which sends "
"output to :data:`sys.stderr` using format ``'[%(levelname)s/%(processName)s]"
" %(message)s'``."
msgstr "この関数は :func:`get_logger` に対する呼び出しを実行しますが、 get_logger によって作成されるロガーを返すことに加えて、 ``'[%(levelname)s/%(processName)s] %(message)s'`` のフォーマットを使用して :data:`sys.stderr` へ出力を送るハンドラーを追加します。"

#: ../../library/multiprocessing.rst:2152
msgid "Below is an example session with logging turned on::"
msgstr "以下にロギングを有効にした例を紹介します::"

#: ../../library/multiprocessing.rst:2167
msgid ""
"In addition to having these two logging functions, the multiprocessing also "
"exposes two additional logging level attributes. These are  "
":const:`SUBWARNING` and :const:`SUBDEBUG`. The table below illustrates where"
" theses fit in the normal level hierarchy."
msgstr "これらの2つのロギング関数があることに加えて、 multiprocessing モジュールも2つの追加ロギングレベル属性を提供します。それは :const:`SUBWARNING` と :const:`SUBDEBUG` です。次の表は通常のレベル階層にうまく適合していることを表します。"

#: ../../library/multiprocessing.rst:2173
msgid "Level"
msgstr "レベル"

#: ../../library/multiprocessing.rst:2173
msgid "Numeric value"
msgstr "Numeric value"

#: ../../library/multiprocessing.rst:2175
msgid "``SUBWARNING``"
msgstr "``SUBWARNING``"

#: ../../library/multiprocessing.rst:2175
msgid "25"
msgstr "25"

#: ../../library/multiprocessing.rst:2177
msgid "``SUBDEBUG``"
msgstr "``SUBDEBUG``"

#: ../../library/multiprocessing.rst:2177
msgid "5"
msgstr "5"

#: ../../library/multiprocessing.rst:2180
msgid "For a full table of logging levels, see the :mod:`logging` module."
msgstr "完全なロギングレベルの表については :mod:`logging` モジュールを参照してください。"

#: ../../library/multiprocessing.rst:2182
msgid ""
"These additional logging levels are used primarily for certain debug "
"messages within the multiprocessing module. Below is the same example as "
"above, except with :const:`SUBDEBUG` enabled::"
msgstr "こういった追加のロギングレベルは主に multiprocessing モジュールの信頼できるデバッグメッセージのために使用されます。以下に上述の例に :const:`SUBDEBUG` を有効にしたものを紹介します::"

#: ../../library/multiprocessing.rst:2206
msgid "The :mod:`multiprocessing.dummy` module"
msgstr ":mod:`multiprocessing.dummy` モジュール"

#: ../../library/multiprocessing.rst:2211
msgid ""
":mod:`multiprocessing.dummy` replicates the API of :mod:`multiprocessing` "
"but is no more than a wrapper around the :mod:`threading` module."
msgstr ":mod:`multiprocessing.dummy` は :mod:`multiprocessing` の API を複製しますが :mod:`threading` モジュールのラッパーでしかありません。"

#: ../../library/multiprocessing.rst:2218
msgid "Programming guidelines"
msgstr "プログラミングガイドライン"

#: ../../library/multiprocessing.rst:2220
msgid ""
"There are certain guidelines and idioms which should be adhered to when "
"using :mod:`multiprocessing`."
msgstr ":mod:`multiprocessing` を使用するときに守るべき一定のガイドラインとイディオムを挙げます。"

#: ../../library/multiprocessing.rst:2225
msgid "All platforms"
msgstr "全てのプラットホーム"

#: ../../library/multiprocessing.rst:2227
msgid "Avoid shared state"
msgstr "共有状態を避ける"

#: ../../library/multiprocessing.rst:2229
msgid ""
"As far as possible one should try to avoid shifting large amounts of data "
"between processes."
msgstr "できるだけプロセス間で巨大なデータを移動することは避けるようにすべきです。"

#: ../../library/multiprocessing.rst:2232
msgid ""
"It is probably best to stick to using queues or pipes for communication "
"between processes rather than using the lower level synchronization "
"primitives from the :mod:`threading` module."
msgstr "プロセス間の通信には、 :mod:`threading` モジュールの低レベルな同期プリミティブを使うのではなく、キューやパイプを使うのが良いでしょう。"

#: ../../library/multiprocessing.rst:2236
msgid "Picklability"
msgstr "pickle 化の可能性"

#: ../../library/multiprocessing.rst:2238
msgid "Ensure that the arguments to the methods of proxies are picklable."
msgstr "プロキシのメソッドへの引数は、 pickle 化できるものにしてください。"

#: ../../library/multiprocessing.rst:2240
msgid "Thread safety of proxies"
msgstr "プロキシのスレッドセーフ性"

#: ../../library/multiprocessing.rst:2242
msgid ""
"Do not use a proxy object from more than one thread unless you protect it "
"with a lock."
msgstr "1 つのプロキシオブジェクトは、ロックで保護しないかぎり、2 つ以上のスレッドから使用してはいけません。"

#: ../../library/multiprocessing.rst:2245
msgid ""
"(There is never a problem with different processes using the *same* proxy.)"
msgstr "(異なるプロセスで *同じ* プロキシを使用することは問題ではありません。)"

#: ../../library/multiprocessing.rst:2247
msgid "Joining zombie processes"
msgstr "ゾンビプロセスを join する"

#: ../../library/multiprocessing.rst:2249
msgid ""
"On Unix when a process finishes but has not been joined it becomes a zombie."
" There should never be very many because each time a new process starts (or "
":func:`~multiprocessing.active_children` is called) all completed processes "
"which have not yet been joined will be joined.  Also calling a finished "
"process's :meth:`Process.is_alive <multiprocessing.Process.is_alive>` will "
"join the process.  Even so it is probably good practice to explicitly join "
"all the processes that you start."
msgstr "Unix 上ではプロセスが終了したときに join しないと、そのプロセスはゾンビになります。新たなプロセスが開始する (または :func:`~multiprocessing.active_children` が呼ばれる) ときに、join されていないすべての完了プロセスが join されるので、あまり多くにはならないでしょう。また、終了したプロセスの :meth:`Process.is_alive <multiprocessing.Process.is_alive>` はそのプロセスを join します。そうは言っても、自分で開始したすべてのプロセスを明示的に join することはおそらく良いプラクティスです。"

#: ../../library/multiprocessing.rst:2257
msgid "Better to inherit than pickle/unpickle"
msgstr "pickle/unpickle より継承する方が良い"

#: ../../library/multiprocessing.rst:2259
msgid ""
"On Windows many types from :mod:`multiprocessing` need to be picklable so "
"that child processes can use them.  However, one should generally avoid "
"sending shared objects to other processes using pipes or queues.  Instead "
"you should arrange the program so that a process which needs access to a "
"shared resource created elsewhere can inherit it from an ancestor process."
msgstr "Windows 上では :mod:`multiprocessing` の多くの型は子プロセスが使用できるようにするため pickle 化できなければなりません。しかし、パイプやキューを使用して他のプロセスへ共有オブジェクトを送ることは一般的に避けるべきです。その代わり、どこかで作成された共有リソースへのアクセスが必要なプロセスは、祖先のプロセスからそれを継承するようにプログラムを変更すべきです。"

#: ../../library/multiprocessing.rst:2265
msgid "Avoid terminating processes"
msgstr "プロセスの強制終了を避ける"

#: ../../library/multiprocessing.rst:2267
msgid ""
"Using the :meth:`Process.terminate <multiprocessing.Process.terminate>` "
"method to stop a process is liable to cause any shared resources (such as "
"locks, semaphores, pipes and queues) currently being used by the process to "
"become broken or unavailable to other processes."
msgstr "あるプロセスを停止するために :meth:`Process.terminate <multiprocessing.Process.terminate>` メソッドを使用すると、そのプロセスが現在使用されている (ロック、セマフォ、パイプやキューのような) 共有リソースを破壊したり他のプロセスから利用できない状態を引き起こし易いです。"

#: ../../library/multiprocessing.rst:2273
msgid ""
"Therefore it is probably best to only consider using "
":meth:`Process.terminate <multiprocessing.Process.terminate>` on processes "
"which never use any shared resources."
msgstr "そのため、共有リソースを使用しないプロセスでのみ :meth:`Process.terminate <multiprocessing.Process.terminate>` を使用することを考慮することがおそらく最善の方法です。"

#: ../../library/multiprocessing.rst:2277
msgid "Joining processes that use queues"
msgstr "キューを使用するプロセスを join する"

#: ../../library/multiprocessing.rst:2279
msgid ""
"Bear in mind that a process that has put items in a queue will wait before "
"terminating until all the buffered items are fed by the \"feeder\" thread to"
" the underlying pipe.  (The child process can call the "
":meth:`~multiprocessing.Queue.cancel_join_thread` method of the queue to "
"avoid this behaviour.)"
msgstr "キューに要素を追加するプロセスは、全てのバッファされた要素が \"feeder\" スレッドによって下位層のパイプに対してフィードされるまで終了を待つということを覚えておいてください。 (子プロセスはこの動作を避けるためにキューの :meth:`~multiprocessing.Queue.cancel_join_thread` メソッドを呼ぶことができます。)"

#: ../../library/multiprocessing.rst:2284
msgid ""
"This means that whenever you use a queue you need to make sure that all "
"items which have been put on the queue will eventually be removed before the"
" process is joined.  Otherwise you cannot be sure that processes which have "
"put items on the queue will terminate.  Remember also that non-daemonic "
"processes will be joined automatically."
msgstr "これはキューを使用するときに、キューに追加されたすべての要素が最終的にそのプロセスが join される前に削除されていることを確認する必要があることを意味します。そうしないと、そのキューに要素が追加したプロセスの終了を保証できません。デーモンではないプロセスは自動的に join されることも覚えておいてください。"

#: ../../library/multiprocessing.rst:2290
msgid "An example which will deadlock is the following::"
msgstr "次の例はデッドロックを引き起こします::"

#: ../../library/multiprocessing.rst:2304
msgid ""
"A fix here would be to swap the last two lines (or simply remove the "
"``p.join()`` line)."
msgstr "修正するには最後の2行を入れ替えます(または単純に ``p.join()`` の行を削除します)。"

#: ../../library/multiprocessing.rst:2307
msgid "Explicitly pass resources to child processes"
msgstr "明示的に子プロセスへリソースを渡す"

#: ../../library/multiprocessing.rst:2309
msgid ""
"On Unix a child process can make use of a shared resource created in a "
"parent process using a global resource.  However, it is better to pass the "
"object as an argument to the constructor for the child process."
msgstr "Unix 上では子プロセスはグローバルなリソースを使用する親プロセスが作成した共有リソースを使用することができます。しかし、引数としてそのオブジェクトを子プロセスのコンストラクタへ渡す方が良いです。"

#: ../../library/multiprocessing.rst:2313
msgid ""
"Apart from making the code (potentially) compatible with Windows this also "
"ensures that as long as the child process is still alive the object will not"
" be garbage collected in the parent process.  This might be important if "
"some resource is freed when the object is garbage collected in the parent "
"process."
msgstr "これにより、コードが (潜在的に) Windows 互換になるだけでなく、子プロセスが生き続ける限り、そのオブジェクトは親プロセスでガベージコレクトされないことも保証されます。これは親プロセスでそのオブジェクトがガベージコレクトされるときにリソースが解放される場合に重要になるでしょう。"

#: ../../library/multiprocessing.rst:2319
msgid "So for instance ::"
msgstr "そのため、例えば ::"

#: ../../library/multiprocessing.rst:2331
msgid "should be rewritten as ::"
msgstr "は、次のように書き直すべきです ::"

#: ../../library/multiprocessing.rst:2343
msgid "Beware of replacing :data:`sys.stdin` with a \"file like object\""
msgstr ":data:`sys.stdin` を file-like オブジェクトに置き換えることに注意する"

#: ../../library/multiprocessing.rst:2345
msgid ":mod:`multiprocessing` originally unconditionally called::"
msgstr ":mod:`multiprocessing` は元々無条件に::"

#: ../../library/multiprocessing.rst:2349
msgid ""
"in the :meth:`multiprocessing.Process._bootstrap` method --- this resulted "
"in issues with processes-in-processes. This has been changed to::"
msgstr "を :meth:`multiprocessing.Process._bootstrap` メソッドの中で呼び出していました --- これはプロセス内プロセス (processes-in-processes) で問題が起こしてしまいます。そこで、これは以下のように変更されました::"

#: ../../library/multiprocessing.rst:2355
msgid ""
"Which solves the fundamental issue of processes colliding with each other "
"resulting in a bad file descriptor error, but introduces a potential danger "
"to applications which replace :func:`sys.stdin` with a \"file-like object\" "
"with output buffering.  This danger is that if multiple processes call "
":meth:`~io.IOBase.close()` on this file-like object, it could result in the "
"same data being flushed to the object multiple times, resulting in "
"corruption."
msgstr "これによってプロセス同士が衝突して bad file descripter エラーを起こすという根本的な問題は解決しましたが、アプリケーションの出力バッファーを :func:`sys.stdin` から \"file-like オブジェクト\" に置き換えるという潜在的危険を持ち込んでしまいました。危険というのは、複数のプロセスが file-like オブジェクトの :meth:`~io.IOBase.close()` を呼び出すと、オブジェクトに同じデータが何度もフラッシュされ、破損してしまう可能性がある、というものです。"

#: ../../library/multiprocessing.rst:2362
msgid ""
"If you write a file-like object and implement your own caching, you can make"
" it fork-safe by storing the pid whenever you append to the cache, and "
"discarding the cache when the pid changes. For example::"
msgstr "もし file-like オブジェクトを書いて独自のキャッシュを実装するなら、キャッシュするときに常に pid を記録しておき、pid が変わったらキュッシュを捨てることで、フォークセーフにできます。例::"

#: ../../library/multiprocessing.rst:2374
msgid ""
"For more information, see :issue:`5155`, :issue:`5313` and :issue:`5331`"
msgstr "より詳しい情報は :issue:`5155` 、 :issue:`5313` 、 :issue:`5331` を見てください"

#: ../../library/multiprocessing.rst:2377
msgid "Windows"
msgstr "Windows"

#: ../../library/multiprocessing.rst:2379
msgid "Since Windows lacks :func:`os.fork` it has a few extra restrictions:"
msgstr "Windows には :func:`os.fork` がないのでいくつか追加制限があります:"

#: ../../library/multiprocessing.rst:2381
msgid "More picklability"
msgstr "さらなる pickle 化の可能性"

#: ../../library/multiprocessing.rst:2383
msgid ""
"Ensure that all arguments to :meth:`Process.__init__` are picklable.  This "
"means, in particular, that bound or unbound methods cannot be used directly "
"as the ``target`` argument on Windows --- just define a function and use "
"that instead."
msgstr ":meth:`Process.__init__` へ渡す全ての引数は、pickle化できるものにしてください。これはとりわけ、Windows 上で、束縛メソッドや非束縛メソッドを直接 ``target`` 引数として使ってはならない、ということを意味します。メソッドではなく、関数を使うしかありません。"

#: ../../library/multiprocessing.rst:2388
msgid ""
"Also, if you subclass :class:`~multiprocessing.Process` then make sure that "
"instances will be picklable when the :meth:`Process.start "
"<multiprocessing.Process.start>` method is called."
msgstr "また :class:`~multiprocessing.Process` をサブクラス化する場合、そのインスタンスが :meth:`Process.start <multiprocessing.Process.start>` メソッドが呼ばれたときに pickle 化できるようにしてください。"

#: ../../library/multiprocessing.rst:2392
msgid "Global variables"
msgstr "グローバル変数"

#: ../../library/multiprocessing.rst:2394
msgid ""
"Bear in mind that if code run in a child process tries to access a global "
"variable, then the value it sees (if any) may not be the same as the value "
"in the parent process at the time that :meth:`Process.start "
"<multiprocessing.Process.start>` was called."
msgstr "子プロセスで実行されるコードがグローバル変数にアクセスしようとする場合、子プロセスが見るその値は :meth:`Process.start <multiprocessing.Process.start>` が呼ばれたときの親プロセスの値と同じではない可能性があります。"

#: ../../library/multiprocessing.rst:2399
msgid ""
"However, global variables which are just module level constants cause no "
"problems."
msgstr "しかし、単にモジュールレベルの定数であるグローバル変数なら問題にはなりません。"

#: ../../library/multiprocessing.rst:2402
msgid "Safe importing of main module"
msgstr "メインモジュールの安全なインポート"

#: ../../library/multiprocessing.rst:2404
msgid ""
"Make sure that the main module can be safely imported by a new Python "
"interpreter without causing unintended side effects (such a starting a new "
"process)."
msgstr "新たな Python インタプリタによるメインモジュールのインポートが、意図しない副作用 (新たなプロセスを開始する等) を起こさずできるようにしてください。"

#: ../../library/multiprocessing.rst:2408
msgid ""
"For example, under Windows running the following module would fail with a "
":exc:`RuntimeError`::"
msgstr "例えば Windows で次のモジュールを実行しようとすると :exc:`RuntimeError` で失敗します::"

#: ../../library/multiprocessing.rst:2419
msgid ""
"Instead one should protect the \"entry point\" of the program by using ``if "
"__name__ == '__main__':`` as follows::"
msgstr "代わりに、次のように ``if __name__ == '__main__':`` を使用してプログラムの \"エントリポイント\" を保護すべきです::"

#: ../../library/multiprocessing.rst:2432
msgid ""
"(The ``freeze_support()`` line can be omitted if the program will be run "
"normally instead of frozen.)"
msgstr "(``freeze_support()`` 行はプログラムが固まらずに通常どおり実行されるなら取り除けます。)"

#: ../../library/multiprocessing.rst:2435
msgid ""
"This allows the newly spawned Python interpreter to safely import the module"
" and then run the module's ``foo()`` function."
msgstr "これは新たに生成された Python インタープリターがそのモジュールを安全にインポートして、モジュールの ``foo()`` 関数を実行します。"

#: ../../library/multiprocessing.rst:2438
msgid ""
"Similar restrictions apply if a pool or manager is created in the main "
"module."
msgstr "プールまたはマネージャーがメインモジュールで作成される場合に似たような制限が適用されます。"

#: ../../library/multiprocessing.rst:2445
msgid "Examples"
msgstr "例"

#: ../../library/multiprocessing.rst:2447
msgid ""
"Demonstration of how to create and use customized managers and proxies:"
msgstr "カスタマイズされたマネージャーやプロキシの作成方法と使用方法を紹介します:"

#: ../../library/multiprocessing.rst:2452
msgid "Using :class:`~multiprocessing.pool.Pool`:"
msgstr ":class:`~multiprocessing.pool.Pool` を使用する例です:"

#: ../../library/multiprocessing.rst:2457
msgid "Synchronization types like locks, conditions and queues:"
msgstr "ロック、コンディションやキューのような同期の例を紹介します:"

#: ../../library/multiprocessing.rst:2462
msgid ""
"An example showing how to use queues to feed tasks to a collection of worker"
" processes and collect the results:"
msgstr "ワーカープロセスのコレクションに対してタスクをフィードしてその結果をまとめるキューの使い方の例を紹介します:"

#: ../../library/multiprocessing.rst:2468
msgid ""
"An example of how a pool of worker processes can each run a "
":class:`SimpleHTTPServer.HttpServer` instance while sharing a single "
"listening socket."
msgstr "ワーカープロセスのプールが1つのソケットを共有してそれぞれの :class:`SimpleHTTPServer.HttpServer` インスタンスを実行する方法の例を紹介します。"

#: ../../library/multiprocessing.rst:2475
msgid ""
"Some simple benchmarks comparing :mod:`multiprocessing` with "
":mod:`threading`:"
msgstr ":mod:`multiprocessing` と :mod:`threading` を比較した簡単なベンチマークです:"
