# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2018, Python Software Foundation
# This file is distributed under the same license as the Python package.
# 
# Translators:
# cocoatomo, 2017
msgid ""
msgstr ""
"Project-Id-Version: Python 2.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-05-23 13:21+0900\n"
"PO-Revision-Date: 2018-05-23 04:24+0000\n"
"Last-Translator: cocoatomo\n"
"Language-Team: Japanese (http://www.transifex.com/python-doc/python-27/language/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../glossary.rst:5
msgid "Glossary"
msgstr "用語集"

#: ../../glossary.rst:10
msgid "``>>>``"
msgstr "``>>>``"

#: ../../glossary.rst:12
msgid ""
"The default Python prompt of the interactive shell.  Often seen for code "
"examples which can be executed interactively in the interpreter."
msgstr "インタラクティブシェルにおけるデフォルトの Python プロンプトです。インタプリタでインタラクティブに実行されるコード例でよく出てきます。"

#: ../../glossary.rst:14
msgid "``...``"
msgstr "``...``"

#: ../../glossary.rst:16
msgid ""
"The default Python prompt of the interactive shell when entering code for an"
" indented code block or within a pair of matching left and right delimiters "
"(parentheses, square brackets or curly braces)."
msgstr "インタラクティブシェルにおいて、インデントされたコードブロックや、対応する括弧 (丸括弧()、角括弧[]、波括弧{}) の内側で、コードを入力する際に表示されるデフォルトの Python プロンプトです。"

#: ../../glossary.rst:19
msgid "2to3"
msgstr "2to3"

#: ../../glossary.rst:21
msgid ""
"A tool that tries to convert Python 2.x code to Python 3.x code by handling "
"most of the incompatibilities which can be detected by parsing the source "
"and traversing the parse tree."
msgstr "Python 2.x のコードを Python 3.x のコードに変換するツールです。ソースコードを解析してその解析木を巡回(traverse)することで検知できる、非互換性の大部分を処理します。"

#: ../../glossary.rst:25
msgid ""
"2to3 is available in the standard library as :mod:`lib2to3`; a standalone "
"entry point is provided as :file:`Tools/scripts/2to3`.  See "
":ref:`2to3-reference`."
msgstr "2to3 は標準ライブラリの :mod:`lib2to3` として利用できます。単体のツールとしての使えるスクリプトが :file:`Tools/scripts/2to3` として提供されています。 :ref:`2to3-reference` を参照してください。"

#: ../../glossary.rst:28
msgid "abstract base class"
msgstr "abstract base class"

#: ../../glossary.rst:30
msgid ""
"Abstract base classes complement :term:`duck-typing` by providing a way to "
"define interfaces when other techniques like :func:`hasattr` would be clumsy"
" or subtly wrong (for example with :ref:`magic methods <new-style-special-"
"lookup>`).  ABCs introduce virtual subclasses, which are classes that don't "
"inherit from a class but are still recognized by :func:`isinstance` and "
":func:`issubclass`; see the :mod:`abc` module documentation.  Python comes "
"with many built-in ABCs for data structures (in the :mod:`collections` "
"module), numbers (in the :mod:`numbers` module), and streams (in the "
":mod:`io` module). You can create your own ABCs with the :mod:`abc` module."
msgstr "(抽象基底クラス) :ref:`abstract-base-classes` は :term:`duck-typing` を補完するもので、 :func:`hasattr` などの別のテクニックでは不恰好になる場合に インタフェースを定義する方法を提供します。 Pythonは沢山のビルトインABCsを、(:mod:`collections` モジュールで)データ構造、 (:mod:`numbers` モジュールで)数値型、(:mod:`io` モジュールで)ストリーム型で 提供いています。 :mod:`abc` モジュールを利用して独自のABCを作成することもできます。"

#: ../../glossary.rst:40
msgid "argument"
msgstr "argument"

#: ../../glossary.rst:42
msgid ""
"A value passed to a :term:`function` (or :term:`method`) when calling the "
"function.  There are two types of arguments:"
msgstr "関数を呼び出す際に、 :term:`function` (または :term:`method`) に渡す値です。引数には２種類あります。"

#: ../../glossary.rst:45
msgid ""
":dfn:`keyword argument`: an argument preceded by an identifier (e.g. "
"``name=``) in a function call or passed as a value in a dictionary preceded "
"by ``**``.  For example, ``3`` and ``5`` are both keyword arguments in the "
"following calls to :func:`complex`::"
msgstr ":dfn:`キーワード引数`: 関数呼び出しの際に引数の前に識別子がついたもの (例: ``name=``) や、 ``**`` に続けた辞書の中の値として渡された引数。例えば、次の :func:`complex` の呼び出しでは、 ``3`` と ``5`` がキーワード引数です::"

#: ../../glossary.rst:53
msgid ""
":dfn:`positional argument`: an argument that is not a keyword argument. "
"Positional arguments can appear at the beginning of an argument list and/or "
"be passed as elements of an :term:`iterable` preceded by ``*``. For example,"
" ``3`` and ``5`` are both positional arguments in the following calls::"
msgstr ":dfn:`位置引数`: キーワード引数以外の引数。位置引数は引数リストの先頭に書くことができ、また ``*`` に続けた :term:`iterable` の要素として渡すことができます。例えば、次の例では ``3`` と ``5`` は両方共位置引数です::"

#: ../../glossary.rst:62
msgid ""
"Arguments are assigned to the named local variables in a function body. See "
"the :ref:`calls` section for the rules governing this assignment. "
"Syntactically, any expression can be used to represent an argument; the "
"evaluated value is assigned to the local variable."
msgstr "実引数は関数の実体において名前付きのローカル変数に割り当てられます。割り当てを行う規則については :ref:`calls` を参照してください。シンタックスにおいて実引数を表すためにあらゆる式を使うことが出来ます。評価された値はローカル変数に割り当てられます。"

#: ../../glossary.rst:67
msgid ""
"See also the :term:`parameter` glossary entry and the FAQ question on "
":ref:`the difference between arguments and parameters <faq-argument-vs-"
"parameter>`."
msgstr ":term:`仮引数<parameter>`、FAQ の :ref:`実引数と仮引数の違いは何ですか? <faq-argument-vs-parameter>` を参照してください。"

#: ../../glossary.rst:70
msgid "attribute"
msgstr "attribute"

#: ../../glossary.rst:72
msgid ""
"A value associated with an object which is referenced by name using dotted "
"expressions.  For example, if an object *o* has an attribute *a* it would be"
" referenced as *o.a*."
msgstr "(属性) オブジェクトに関連付けられ、ドット表記式によって名前で参照される値です。例えば、オブジェクト *o* が属性 *a* を持っているとき、その属性は *o.a* で参照されます。"

#: ../../glossary.rst:75
msgid "BDFL"
msgstr "BDFL"

#: ../../glossary.rst:77
msgid ""
"Benevolent Dictator For Life, a.k.a. `Guido van Rossum "
"<https://www.python.org/~guido/>`_, Python's creator."
msgstr "慈悲深き終身独裁者 (Benevolent Dictator For Life) の略です。Python の作者、`Guido van Rossum <https://www.python.org/~guido/>`_ のことです。"

#: ../../glossary.rst:79
msgid "bytes-like object"
msgstr "bytes-like object"

#: ../../glossary.rst:81
msgid ""
"An object that supports the :ref:`buffer protocol <bufferobjects>`, like "
":class:`str`, :class:`bytearray` or :class:`memoryview`. Bytes-like objects "
"can be used for various operations that expect binary data, such as "
"compression, saving to a binary file or sending over a socket. Some "
"operations need the binary data to be mutable, in which case not all bytes-"
"like objects can apply."
msgstr "(バイト様オブジェクト) :class:`str`、:class:`bytearray` や :class:`memoryview` といった :ref:`buffer protocol <bufferobjects>` をサポートするオブジェクトです。バイト様オブジェクトは圧縮、バイナリーデータの保存、ソケット経由の送信等の様々な操作に用いることが出来ます。操作によってはバイナリーデータはミューテーブルでなくてはなりませんが、その場合全てのバイト様オブジェクトを用いることが出来るわけではありません。 "

#: ../../glossary.rst:87
msgid "bytecode"
msgstr "bytecode"

#: ../../glossary.rst:89
msgid ""
"Python source code is compiled into bytecode, the internal representation of"
" a Python program in the CPython interpreter.  The bytecode is also cached "
"in ``.pyc`` and ``.pyo`` files so that executing the same file is faster the"
" second time (recompilation from source to bytecode can be avoided).  This "
"\"intermediate language\" is said to run on a :term:`virtual machine` that "
"executes the machine code corresponding to each bytecode. Do note that "
"bytecodes are not expected to work between different Python virtual "
"machines, nor to be stable between Python releases."
msgstr "(バイトコード) Python のソースコードはバイトコードへとコンパイルされます。バイトコードは Python プログラムの CPython インタプリタ内部での表現です。バイトコードはまた、 ``.pyc`` や ``.pyo`` ファイルにキャッシュされ、同じファイルの実行が二度目にはより高速になります (ソースコードからバイトコードへの再度のコンパイルは回避されます)。このバイトコードは、各々のバイトコードに対応するサブルーチンを呼び出すような \"仮想機械(:term:`virtual machine`)\" で動作する \"中間言語 (intermediate language)\" といえます。重要な注意として、バイトコードは異なる Python 仮想マシン間で動作することは期待されていませんし、Python リリース間で安定でもありません。"

#: ../../glossary.rst:99
msgid ""
"A list of bytecode instructions can be found in the documentation for "
":ref:`the dis module <bytecodes>`."
msgstr "バイトコードの命令一覧は :ref:`dis モジュール <bytecodes>` にあります。"

#: ../../glossary.rst:101
msgid "class"
msgstr "class"

#: ../../glossary.rst:103
msgid ""
"A template for creating user-defined objects. Class definitions normally "
"contain method definitions which operate on instances of the class."
msgstr "(クラス) ユーザー定義オブジェクトを作成するためのテンプレートです。クラス定義は普通、そのクラスのインスタンス上の操作をするメソッドの定義を含みます。"

#: ../../glossary.rst:106
msgid "classic class"
msgstr "classic class"

#: ../../glossary.rst:108
msgid ""
"Any class which does not inherit from :class:`object`.  See :term:`new-style"
" class`.  Classic classes have been removed in Python 3."
msgstr "(旧スタイルクラス) :class:`object` を継承していないクラス全てを指します。 新スタイルクラス(:term:`new-style class`) も参照してください。 旧スタイルクラスは Python 3 で削除されます。"

#: ../../glossary.rst:110
msgid "coercion"
msgstr "coercion"

#: ../../glossary.rst:112
msgid ""
"The implicit conversion of an instance of one type to another during an "
"operation which involves two arguments of the same type.  For example, "
"``int(3.15)`` converts the floating point number to the integer ``3``, but "
"in ``3+4.5``, each argument is of a different type (one int, one float), and"
" both must be converted to the same type before they can be added or it will"
" raise a ``TypeError``.  Coercion between two operands can be performed with"
" the ``coerce`` built-in function; thus, ``3+4.5`` is equivalent to calling "
"``operator.add(*coerce(3, 4.5))`` and results in ``operator.add(3.0, 4.5)``."
"  Without coercion, all arguments of even compatible types would have to be "
"normalized to the same value by the programmer, e.g., ``float(3)+4.5`` "
"rather than just ``3+4.5``."
msgstr "(型強制) 同じ型の2つの引数を要する演算の最中に、ある型のインスタンスを別の型に暗黙のうちに変換することです。 例えば、 ``int(3.15)`` は浮動小数点数を整数の ``3`` にします。 しかし、 ``3+4.5`` の場合、各引数は型が異なっていて(一つは整数、一つは浮動小数点数)、 加算をする前に同じ型に変換しなければいけません。そうでないと、 ``TypeError`` 例外が投げられます。 2つの被演算子間の型強制は組み込み関数の ``coerce`` を使って行えます。 従って、 ``3+4.5`` は ``operator.add(*coerce(3, 4.5))`` を呼び出すことに等しく、 ``operator.add(3.0, 4.5)`` という結果になります。 型強制を行わない場合、たとえ互換性のある型であっても、すべての引数はプログラマーが、 単に ``3+4.5`` とするのではなく、 ``float(3)+4.5`` というように、同じ型に正規化しなければいけません。"

#: ../../glossary.rst:123
msgid "complex number"
msgstr "complex number"

#: ../../glossary.rst:125
msgid ""
"An extension of the familiar real number system in which all numbers are "
"expressed as a sum of a real part and an imaginary part.  Imaginary numbers "
"are real multiples of the imaginary unit (the square root of ``-1``), often "
"written ``i`` in mathematics or ``j`` in engineering.  Python has built-in "
"support for complex numbers, which are written with this latter notation; "
"the imaginary part is written with a ``j`` suffix, e.g., ``3+1j``.  To get "
"access to complex equivalents of the :mod:`math` module, use :mod:`cmath`.  "
"Use of complex numbers is a fairly advanced mathematical feature.  If you're"
" not aware of a need for them, it's almost certain you can safely ignore "
"them."
msgstr "(複素数) よく知られている実数系を拡張したもので、すべての数は実部と虚部の和として表されます。虚数は虚数単位 (``-1`` の平方根) に実数を掛けたもので、一般に数学では ``i`` と書かれ、工学では ``j`` と書かれます。Python は複素数に組み込みで対応し、後者の表記を取っています。虚部は末尾に ``j`` をつけて書きます。例えば ``3+1j`` です。 :mod:`math` モジュールの複素数版を利用するには、 :mod:`cmath` を使います。複素数の使用はかなり高度な数学の機能です。必要性を感じなければ、ほぼ間違いなく無視してしまってよいでしょう。"

#: ../../glossary.rst:135
msgid "context manager"
msgstr "context manager"

#: ../../glossary.rst:137
msgid ""
"An object which controls the environment seen in a :keyword:`with` statement"
" by defining :meth:`__enter__` and :meth:`__exit__` methods. See :pep:`343`."
msgstr "(コンテキストマネージャ) :keyword:`with` 文で扱われる、:meth:`__enter__` と :meth:`__exit__` メソッドを定義することで環境を制御するオブジェクトです。:pep:`343` を参照してください。"

#: ../../glossary.rst:140
msgid "CPython"
msgstr "CPython"

#: ../../glossary.rst:142
msgid ""
"The canonical implementation of the Python programming language, as "
"distributed on `python.org <https://www.python.org>`_.  The term \"CPython\""
" is used when necessary to distinguish this implementation from others such "
"as Jython or IronPython."
msgstr "`python.org <https://www.python.org>`_ で配布されている、Python プログラミング言語の標準的な実装です。\"CPython\" という単語は、この実装を Jython や IronPython といった他の実装と区別する必要が有る場合に利用されます。"

#: ../../glossary.rst:146
msgid "decorator"
msgstr "decorator"

#: ../../glossary.rst:148
msgid ""
"A function returning another function, usually applied as a function "
"transformation using the ``@wrapper`` syntax.  Common examples for "
"decorators are :func:`classmethod` and :func:`staticmethod`."
msgstr "(デコレータ) 別の関数を返す関数で、通常、 ``@wrapper`` 構文で関数変換として適用されます。デコレータの一般的な利用例は、 :func:`classmethod` と :func:`staticmethod` です。"

#: ../../glossary.rst:152
msgid ""
"The decorator syntax is merely syntactic sugar, the following two function "
"definitions are semantically equivalent::"
msgstr "デコレータの文法はシンタックスシュガーです。次の2つの関数定義は意味的に同じものです::"

#: ../../glossary.rst:163
msgid ""
"The same concept exists for classes, but is less commonly used there.  See "
"the documentation for :ref:`function definitions <function>` and :ref:`class"
" definitions <class>` for more about decorators."
msgstr "同じ概念がクラスにも存在しますが、あまり使われません。デコレータについて詳しくは、 :ref:`関数定義 <function>` および :ref:`クラス定義 <class>` のドキュメントを参照してください。"

#: ../../glossary.rst:166
msgid "descriptor"
msgstr "descriptor"

#: ../../glossary.rst:168
msgid ""
"Any *new-style* object which defines the methods :meth:`__get__`, "
":meth:`__set__`, or :meth:`__delete__`.  When a class attribute is a "
"descriptor, its special binding behavior is triggered upon attribute lookup."
"  Normally, using *a.b* to get, set or delete an attribute looks up the "
"object named *b* in the class dictionary for *a*, but if *b* is a "
"descriptor, the respective descriptor method gets called.  Understanding "
"descriptors is a key to a deep understanding of Python because they are the "
"basis for many features including functions, methods, properties, class "
"methods, static methods, and reference to super classes."
msgstr "(デスクリプタ) メソッド :meth:`__get__`, :meth:`__set__`, あるいは :meth:`__delete__` が定義されている *新スタイル (new-style)* のオブジェクトです。 あるクラス属性がデスクリプタである場合、その属性を参照するときに、 そのデスクリプタに束縛されている特別な動作を呼び出します。 通常、get,set,deleteのために *a.b* と書くと、 *a* のクラス辞書内でオブジェクト *b* を検索しますが、 *b* がデスクリプタの場合にはデスクリプタで定義された メソッドを呼び出します。 デスクリプタの理解は、 Python を深く理解する上で鍵となります。 というのは、デスクリプタこそが、関数、メソッド、プロパティ、 クラスメソッド、静的メソッド、そしてスーパクラスの参照といった多くの機能の基盤だからです。"

#: ../../glossary.rst:178
msgid ""
"For more information about descriptors' methods, see :ref:`descriptors`."
msgstr "デスクリプタのメソッドに関して詳しくは、 :ref:`descriptors` を参照してください。"

#: ../../glossary.rst:179
msgid "dictionary"
msgstr "dictionary"

#: ../../glossary.rst:181
msgid ""
"An associative array, where arbitrary keys are mapped to values.  The keys "
"can be any object with :meth:`__hash__`  and :meth:`__eq__` methods. Called "
"a hash in Perl."
msgstr "(辞書) 任意のキーを値に対応付ける連想配列です。 :meth:`__hash__` メソッドと :meth:`__eq__` メソッドを実装した任意のオブジェクトをキーにできます。 Perl ではハッシュ (hash) と呼ばれています。"

#: ../../glossary.rst:184
msgid "dictionary view"
msgstr "dictionary view"

#: ../../glossary.rst:186
msgid ""
"The objects returned from :meth:`dict.viewkeys`, :meth:`dict.viewvalues`, "
"and :meth:`dict.viewitems` are called dictionary views. They provide a "
"dynamic view on the dictionary’s entries, which means that when the "
"dictionary changes, the view reflects these changes. To force the dictionary"
" view to become a full list use ``list(dictview)``.  See :ref:`dict-views`."
msgstr "(ビュー) :meth:`dict.viewkeys`, :meth:`dict.viewvalues`, :meth:`dict.viewitems` が返すオブジェクトを辞書ビュー (dictionary view) と呼びます。これらは辞書のエントリに対する動的なビューで、つまり辞書の変更されるとビューはそれら変更を反映します。辞書ビューを完全なリストにするには ``list(dictview)`` としてください。 :ref:`dict-views` を参照してください。"

#: ../../glossary.rst:192
msgid "docstring"
msgstr "docstring"

#: ../../glossary.rst:194
msgid ""
"A string literal which appears as the first expression in a class, function "
"or module.  While ignored when the suite is executed, it is recognized by "
"the compiler and put into the :attr:`__doc__` attribute of the enclosing "
"class, function or module.  Since it is available via introspection, it is "
"the canonical place for documentation of the object."
msgstr "クラス、関数、モジュールの最初の式である文字列リテラルです。そのスイートの実行時には無視されますが、コンパイラによって識別され、そのクラス、関数、モジュールの :attr:`__doc__` 属性として保存されます。イントロスペクションできる（訳注: 属性として参照できる）ので、オブジェクトのドキュメントを書く標準的な場所です。"

#: ../../glossary.rst:200
msgid "duck-typing"
msgstr "duck-typing"

#: ../../glossary.rst:202
msgid ""
"A programming style which does not look at an object's type to determine if "
"it has the right interface; instead, the method or attribute is simply "
"called or used (\"If it looks like a duck and quacks like a duck, it must be"
" a duck.\")  By emphasizing interfaces rather than specific types, well-"
"designed code improves its flexibility by allowing polymorphic substitution."
"  Duck-typing avoids tests using :func:`type` or :func:`isinstance`.  (Note,"
" however, that duck-typing can be complemented with :term:`abstract base "
"classes <abstract base class>`.)  Instead, it typically employs "
":func:`hasattr` tests or :term:`EAFP` programming."
msgstr "あるオブジェクトが正しいインタフェースを持っているかを決定するのにオブジェクトの型を見ないプログラミングスタイルです。代わりに、単純にオブジェクトのメソッドや属性が呼ばれたり使われたりします。（「アヒルのように見えて、アヒルのように鳴けば、それはアヒルである。」）インタフェースを型より重視することで、上手くデザインされたコードは、ポリモーフィックな代替を許して柔軟性を向上させます。ダックタイピングは :func:`type` や :func:`isinstance` による判定を避けます。 (ただし、ダックタイピングを :term:`抽象基底クラス <abstract base class>` で補完することもできます。) その代わり、典型的に :func:`hasattr` 判定や :term:`EAFP` プログラミングを利用します。"

#: ../../glossary.rst:211
msgid "EAFP"
msgstr "EAFP"

#: ../../glossary.rst:213
msgid ""
"Easier to ask for forgiveness than permission.  This common Python coding "
"style assumes the existence of valid keys or attributes and catches "
"exceptions if the assumption proves false.  This clean and fast style is "
"characterized by the presence of many :keyword:`try` and :keyword:`except` "
"statements.  The technique contrasts with the :term:`LBYL` style common to "
"many other languages such as C."
msgstr "「認可をとるより許しを請う方が容易  (easier to ask for forgiveness than permission、マーフィーの法則)」の略です。この Python で広く使われているコーディングスタイルでは、通常は有効なキーや属性が存在するものと仮定し、その仮定が誤っていた場合に例外を捕捉します。この簡潔で手早く書けるコーディングスタイルには、 :keyword:`try` 文および :keyword:`except` 文がたくさんあるのが特徴です。このテクニックは、C のような言語でよく使われている :term:`LBYL` スタイルと対照的なものです。"

#: ../../glossary.rst:219
msgid "expression"
msgstr "expression"

#: ../../glossary.rst:221
msgid ""
"A piece of syntax which can be evaluated to some value.  In other words, an "
"expression is an accumulation of expression elements like literals, names, "
"attribute access, operators or function calls which all return a value.  In "
"contrast to many other languages, not all language constructs are "
"expressions.  There are also :term:`statement`\\s which cannot be used as "
"expressions, such as :keyword:`print` or :keyword:`if`.  Assignments are "
"also statements, not expressions."
msgstr "(式) 何かの値に評価される、一つづきの構文(a piece of syntax). 言い換えると、リテラル、名前、属性アクセス、演算子や関数呼び出しといった、 値を返す式の要素の組み合わせ。 他の多くの言語と違い、Pythonは言語の全ての構成要素が式というわけではありません。 :keyword:`print` や :keyword:`if` のように、式にはならない、文(:term:`statement`) もあります。代入も式ではなく文です。"

#: ../../glossary.rst:228
msgid "extension module"
msgstr "extension module"

#: ../../glossary.rst:230
msgid ""
"A module written in C or C++, using Python's C API to interact with the core"
" and with user code."
msgstr "(拡張モジュール) C や C++ で書かれたモジュールで、Python の C API を利用して Python コアやユーザーコードとやりとりします。"

#: ../../glossary.rst:232
msgid "file object"
msgstr "file object"

#: ../../glossary.rst:234
msgid ""
"An object exposing a file-oriented API (with methods such as :meth:`read()` "
"or :meth:`write()`) to an underlying resource.  Depending on the way it was "
"created, a file object can mediate access to a real on-disk file or to "
"another type of storage or communication device (for example standard "
"input/output, in-memory buffers, sockets, pipes, etc.).  File objects are "
"also called :dfn:`file-like objects` or :dfn:`streams`."
msgstr "(ファイルオブジェクト) 下位のリソースへのファイル志向 API (:meth:`read()` や :meth:`write()` メソッドを持つもの) を公開しているオブジェクトです。ファイルオブジェクトは、作成された手段によって、実際のディスク上のファイルや、その他のタイプのストレージや通信デバイス (例えば、標準入出力、インメモリバッファ、ソケット、パイプ、等) へのアクセスを媒介できます。ファイルオブジェクトは :dfn:`file-like objects` や :dfn:`streams` とも呼ばれます。"

#: ../../glossary.rst:242
msgid ""
"There are actually three categories of file objects: raw binary files, "
"buffered binary files and text files.  Their interfaces are defined in the "
":mod:`io` module.  The canonical way to create a file object is by using the"
" :func:`open` function."
msgstr "ファイルオブジェクトには3つの種類があります: 生のバイナリーファイル、バッファされたバイナリーファイル、そしてテキストファイルです。 これらのインターフェースは :mod:`io` モジュール内で定義されています。 ファイルオブジェクトを作成する標準的な方法は :func:`open` 関数を利用することです。"

#: ../../glossary.rst:246
msgid "file-like object"
msgstr "file-like object"

#: ../../glossary.rst:248
msgid "A synonym for :term:`file object`."
msgstr ":term:`file object` と同義です。"

#: ../../glossary.rst:249
msgid "finder"
msgstr "finder"

#: ../../glossary.rst:251
msgid ""
"An object that tries to find the :term:`loader` for a module. It must "
"implement a method named :meth:`find_module`. See :pep:`302` for details."
msgstr "モジュールの :term:`loader` を探すオブジェクト。 :meth:`find_module` という名前のメソッドを実装していなければなりません。 詳細については :pep:`302` を参照してください。"

#: ../../glossary.rst:254
msgid "floor division"
msgstr "floor division"

#: ../../glossary.rst:256
msgid ""
"Mathematical division that rounds down to nearest integer.  The floor "
"division operator is ``//``.  For example, the expression ``11 // 4`` "
"evaluates to ``2`` in contrast to the ``2.75`` returned by float true "
"division.  Note that ``(-11) // 4`` is ``-3`` because that is ``-2.75`` "
"rounded *downward*. See :pep:`238`."
msgstr "一番近い小さい整数に丸める数学除算。floor division 演算子は ``//`` です。例えば、 ``11 // 4`` は ``2`` になり、 float の true division の結果 ``2.75`` と異なります。 ``(-11) // 4`` は ``-2.75`` を *小さい方に* 丸めるので ``-3`` になることに注意してください。 :pep:`238` を参照してください。"

#: ../../glossary.rst:261
msgid "function"
msgstr "関数"

#: ../../glossary.rst:263
msgid ""
"A series of statements which returns some value to a caller. It can also be "
"passed zero or more :term:`arguments <argument>` which may be used in the "
"execution of the body. See also :term:`parameter`, :term:`method`, and the "
":ref:`function` section."
msgstr "(関数) 呼び出し側に値を返す一連の文のことです。関数には0以上の :term:`実引数 <argument>` を渡すことが出来ます。実体の実行時に引数を使用することが出来ます。 :term:`仮引数 <parameter>`、:term:`メソッド <method>`、:ref:`function` を参照してください。"

#: ../../glossary.rst:267
msgid "__future__"
msgstr "__future__"

#: ../../glossary.rst:269
msgid ""
"A pseudo-module which programmers can use to enable new language features "
"which are not compatible with the current interpreter.  For example, the "
"expression ``11/4`` currently evaluates to ``2``. If the module in which it "
"is executed had enabled *true division* by executing::"
msgstr "互換性のない新たな機能を現在のインタプリタで有効にするためにプログラマが 利用できる擬似モジュールです。例えば、式 ``11/4`` は現状では ``2`` になります。この式を実行しているモジュールで ::"

#: ../../glossary.rst:276
msgid ""
"the expression ``11/4`` would evaluate to ``2.75``.  By importing the "
":mod:`__future__` module and evaluating its variables, you can see when a "
"new feature was first added to the language and when it will become the "
"default::"
msgstr "を行って *真の除算操作 (true division)* を有効にすると、式 ``11/4`` は ``2.75`` になります。実際に :mod:`__future__` モジュールを import してその変数を評価すれば、新たな機能が初めて追加されたのがいつで、 いつデフォルトの機能になる予定かわかります。 ::"

#: ../../glossary.rst:284
msgid "garbage collection"
msgstr "garbage collection"

#: ../../glossary.rst:286
msgid ""
"The process of freeing memory when it is not used anymore.  Python performs "
"garbage collection via reference counting and a cyclic garbage collector "
"that is able to detect and break reference cycles."
msgstr "(ガベージコレクション) それ以上使われなくなったメモリを解放する処理です。Pythonは、参照カウントと、循環参照を見つけて破壊する循環ガベージコレクタと、を使ってガベージコレクションを行います。"

#: ../../glossary.rst:291
msgid "generator"
msgstr "generator"

#: ../../glossary.rst:293
msgid ""
"A function which returns an iterator.  It looks like a normal function "
"except that it contains :keyword:`yield` statements for producing a series "
"of values usable in a for-loop or that can be retrieved one at a time with "
"the :func:`next` function. Each :keyword:`yield` temporarily suspends "
"processing, remembering the location execution state (including local "
"variables and pending try-statements).  When the generator resumes, it "
"picks-up where it left-off (in contrast to functions which start fresh on "
"every invocation)."
msgstr "(ジェネレータ) イテレータを返す関数です。通常の関数に似ていますが、代わりに for ループで使ったり :func:`next` 関数で1つずつ取り出せる値の列を生成するために :keyword:`yield` 文を使います。 :keyword:`yield` 文に到達するたびに関数の実行は実行状態 (ローカル変数や実行中の try 文などを含む) を保存して中断されます。ジェネレータが再開されるとき、(通常の関数が実行の度に初期状態から開始するのに対して) 中断した状態から実行を開始します。"

#: ../../glossary.rst:303
msgid "generator expression"
msgstr "generator expression"

#: ../../glossary.rst:305
msgid ""
"An expression that returns an iterator.  It looks like a normal expression "
"followed by a :keyword:`for` expression defining a loop variable, range, and"
" an optional :keyword:`if` expression.  The combined expression generates "
"values for an enclosing function::"
msgstr "(ジェネレータ式) イテレータを返す式です。普通の式に、ループ変数を定義する :keyword:`for` 式、範囲、そして省略可能な :keyword:`if` 式がつづいているように見えます。こうして構成された式は、外側の関数に向けて値を生成します::"

#: ../../glossary.rst:312
msgid "GIL"
msgstr "GIL"

#: ../../glossary.rst:314
msgid "See :term:`global interpreter lock`."
msgstr ":term:`global interpreter lock` を参照してください。"

#: ../../glossary.rst:315
msgid "global interpreter lock"
msgstr "global interpreter lock"

#: ../../glossary.rst:317
msgid ""
"The mechanism used by the :term:`CPython` interpreter to assure that only "
"one thread executes Python :term:`bytecode` at a time. This simplifies the "
"CPython implementation by making the object model (including critical built-"
"in types such as :class:`dict`) implicitly safe against concurrent access.  "
"Locking the entire interpreter makes it easier for the interpreter to be "
"multi-threaded, at the expense of much of the parallelism afforded by multi-"
"processor machines."
msgstr "(グローバルインタプリタロック) :term:`CPython` インタプリタが利用している、一度に Python のバイトコード(:term:`bytecode`) 実行するスレッドは一つだけであることを保証する仕組みです。これにより (:class:`dict` などの重要な組み込み型を含む) などのオブジェクトモデルが同時アクセスに対して暗黙的に安全になるので、 CPython の実装がシンプルになります。インタプリタ全体をロックすることで、マルチプロセッサマシンが生じる並列化のコストに対して、楽にインタプリタをマルチスレッド化できます。"

#: ../../glossary.rst:326
msgid ""
"However, some extension modules, either standard or third-party, are "
"designed so as to release the GIL when doing computationally-intensive tasks"
" such as compression or hashing.  Also, the GIL is always released when "
"doing I/O."
msgstr "ただし、標準あるいは外部のいくつかの拡張モジュールは、圧縮やハッシュ計算などの計算の重い処理をするときに GIL を解放するように設計されています。また、I/O 処理をするときも GIL は常に解放されます。"

#: ../../glossary.rst:331
msgid ""
"Past efforts to create a \"free-threaded\" interpreter (one which locks "
"shared data at a much finer granularity) have not been successful because "
"performance suffered in the common single-processor case. It is believed "
"that overcoming this performance issue would make the implementation much "
"more complicated and therefore costlier to maintain."
msgstr "過去に \"自由なマルチスレッド化\" したインタプリタ (供用されるデータを細かい粒度でロックする) が開発されましたが、一般的なシングルプロセッサの場合のパフォーマンスが悪かったので成功しませんでした。このパフォーマンスの問題を克服しようとすると、実装がより複雑になり保守コストが増加すると考えられています。"

#: ../../glossary.rst:336
msgid "hashable"
msgstr "hashable"

#: ../../glossary.rst:338
msgid ""
"An object is *hashable* if it has a hash value which never changes during "
"its lifetime (it needs a :meth:`__hash__` method), and can be compared to "
"other objects (it needs an :meth:`__eq__` or :meth:`__cmp__` method). "
"Hashable objects which compare equal must have the same hash value."
msgstr "(ハッシュ可能) *ハッシュ可能* なオブジェクトとは、生存期間中変わらないハッシュ値を持ち (:meth:`__hash__` メソッドが必要)、他のオブジェクトと比較ができる (:meth:`__eq__` か :meth:`__cmp__` メソッドが必要) オブジェクトです。 同値なハッシュ可能オブジェクトは必ず同じハッシュ値を持つ必要があります。"

#: ../../glossary.rst:343
msgid ""
"Hashability makes an object usable as a dictionary key and a set member, "
"because these data structures use the hash value internally."
msgstr "ハッシュ可能なオブジェクトは辞書のキーや集合のメンバーとして使えます。辞書や集合のデータ構造は内部でハッシュ値を使っているからです。"

#: ../../glossary.rst:346
msgid ""
"All of Python's immutable built-in objects are hashable, while no mutable "
"containers (such as lists or dictionaries) are.  Objects which are instances"
" of user-defined classes are hashable by default; they all compare unequal "
"(except with themselves), and their hash value is derived from their "
":func:`id`."
msgstr "Python のイミューテーブルな組み込みオブジェクトはハッシュ可能ですが、ミューテーブルなコンテナ (例えばリストや辞書) はハッシュ不可能です。ユーザー定義のクラスのインスタンスであるようなオブジェクトはデフォルトでハッシュ可能です。それらは全て非等価を比較し (自身を除いて)、ハッシュ値は :func:`id` より得られます。"

#: ../../glossary.rst:351
msgid "IDLE"
msgstr "IDLE"

#: ../../glossary.rst:353
msgid ""
"An Integrated Development Environment for Python.  IDLE is a basic editor "
"and interpreter environment which ships with the standard distribution of "
"Python."
msgstr "Python の統合開発環境 (Integrated DeveLopment Environment) です。IDLE は Python の標準的な配布に同梱されている基本的な機能のエディタとインタプリタ環境です。"

#: ../../glossary.rst:356
msgid "immutable"
msgstr "immutable"

#: ../../glossary.rst:358
msgid ""
"An object with a fixed value.  Immutable objects include numbers, strings "
"and tuples.  Such an object cannot be altered.  A new object has to be "
"created if a different value has to be stored.  They play an important role "
"in places where a constant hash value is needed, for example as a key in a "
"dictionary."
msgstr "(イミュータブル) 固定の値を持ったオブジェクトです。イミュータブルなオブジェクトには、数値、文字列、およびタプルなどがあります。これらのオブジェクトは値を変えられません。別の値を記憶させる際には、新たなオブジェクトを作成しなければなりません。イミュータブルなオブジェクトは、固定のハッシュ値が必要となる状況で重要な役割を果たします。辞書のキーがその例です。"

#: ../../glossary.rst:363
msgid "integer division"
msgstr "integer division"

#: ../../glossary.rst:365
msgid ""
"Mathematical division discarding any remainder.  For example, the expression"
" ``11/4`` currently evaluates to ``2`` in contrast to the ``2.75`` returned "
"by float division.  Also called *floor division*. When dividing two integers"
" the outcome will always be another integer (having the floor function "
"applied to it). However, if one of the operands is another numeric type "
"(such as a :class:`float`), the result will be coerced (see "
":term:`coercion`) to a common type.  For example, an integer divided by a "
"float will result in a float value, possibly with a decimal fraction.  "
"Integer division can be forced by using the ``//`` operator instead of the "
"``/`` operator.  See also :term:`__future__`."
msgstr "(整数除算) 剰余を考慮しない数学的除算です。例えば、式 ``11/4`` は現状では ``2.75`` ではなく ``2`` になります。これは *切り捨て除算 (floor division)* とも呼ばれます。 二つの整数間で除算を行うと、結果は (端数切捨て関数が適用されて)  常に整数になります。 しかし、被演算子の一方が (:class:`float` のような) 別の数値型の場合、 演算の結果は共通の型に型強制されます (型強制(:term:`coercion`)参照)。 例えば、浮動小数点数で整数を除算すると結果は浮動小数点になり、 場合によっては端数部分を伴います。 ``//`` 演算子を ``/`` の代わりに使うと、整数除算を強制できます。 :term:`__future__` も参照してください。"

#: ../../glossary.rst:375
msgid "importing"
msgstr "importing"

#: ../../glossary.rst:377
msgid ""
"The process by which Python code in one module is made available to Python "
"code in another module."
msgstr "あるモジュールの Python コードが別のモジュールの Python コードで使えるようにする処理です。"

#: ../../glossary.rst:379
msgid "importer"
msgstr "importer"

#: ../../glossary.rst:381
msgid ""
"An object that both finds and loads a module; both a :term:`finder` and "
":term:`loader` object."
msgstr "モジュールを探してロードするオブジェクト。 :term:`finder` と :term:`loader` のどちらでもあるオブジェクト。"

#: ../../glossary.rst:383
msgid "interactive"
msgstr "interactive"

#: ../../glossary.rst:385
msgid ""
"Python has an interactive interpreter which means you can enter statements "
"and expressions at the interpreter prompt, immediately execute them and see "
"their results.  Just launch ``python`` with no arguments (possibly by "
"selecting it from your computer's main menu). It is a very powerful way to "
"test out new ideas or inspect modules and packages (remember ``help(x)``)."
msgstr "(対話的) Python には対話的インタプリタがあり、文や式をインタプリタのプロンプトに入力すると即座に実行されて結果を見ることができます。 ``python`` と何も引数を与えずに実行してください。(コンピュータのメインメニューから Pythonの対話的インタプリタを起動できるかもしれません。) 対話的インタプリタは、新しいアイデアを試してみたり、モジュールやパッケージの中を覗いてみる(``help(x)`` を覚えておいてください) のに非常に便利なツールです。"

#: ../../glossary.rst:391
msgid "interpreted"
msgstr "interpreted"

#: ../../glossary.rst:393
msgid ""
"Python is an interpreted language, as opposed to a compiled one, though the "
"distinction can be blurry because of the presence of the bytecode compiler."
"  This means that source files can be run directly without explicitly "
"creating an executable which is then run. Interpreted languages typically "
"have a shorter development/debug cycle than compiled ones, though their "
"programs generally also run more slowly.  See also :term:`interactive`."
msgstr "Python はインタプリタ形式の言語であり、コンパイラ言語の対極に位置します。 (バイトコードコンパイラがあるために、この区別は曖昧ですが。) ここでのインタプリタ言語とは、ソースコードのファイルを、まず実行可能形式にしてから実行させるといった操作なしに、直接実行できることを意味します。インタプリタ形式の言語は通常、コンパイラ形式の言語よりも開発／デバッグのサイクルは短いものの、プログラムの実行は一般に遅いです。対話的(:term:`interactive`)も参照してください。"

#: ../../glossary.rst:400
msgid "iterable"
msgstr "iterable"

#: ../../glossary.rst:402
msgid ""
"An object capable of returning its members one at a time. Examples of "
"iterables include all sequence types (such as :class:`list`, :class:`str`, "
"and :class:`tuple`) and some non-sequence types like :class:`dict` and "
":class:`file` and objects of any classes you define with an :meth:`__iter__`"
" or :meth:`__getitem__` method.  Iterables can be used in a :keyword:`for` "
"loop and in many other places where a sequence is needed (:func:`zip`, "
":func:`map`, ...).  When an iterable object is passed as an argument to the "
"built-in function :func:`iter`, it returns an iterator for the object.  This"
" iterator is good for one pass over the set of values.  When using "
"iterables, it is usually not necessary to call :func:`iter` or deal with "
"iterator objects yourself.  The ``for`` statement does that automatically "
"for you, creating a temporary unnamed variable to hold the iterator for the "
"duration of the loop.  See also :term:`iterator`, :term:`sequence`, and "
":term:`generator`."
msgstr "(反復可能オブジェクト) 要素を一つずつ返せるオブジェクトです。反復可能オブジェクトの例には、(:class:`list`, :class:`str`, :class:`tuple` といった) 全てのシーケンス型や、 :class:`dict` や :class:`file` といった幾つかの非シーケンス型、 あるいは :meth:`__iter__` か :meth:`__getitem__` メソッドを実装したクラスのインスタンスが含まれます。反復可能オブジェクトは :keyword:`for` ループ内やその他多くのシーケンス (訳注: ここでのシーケンスとは、シーケンス型ではなくただの列という意味)が必要となる状況 (:func:`zip`, :func:`map`, ...) で利用できます。反復可能オブジェクトを組み込み関数 :func:`iter` の引数として渡すと、 オブジェクトに対するイテレータを返します。 このイテレータは一連の値を引き渡す際に便利です。 反復可能オブジェクトを使う際には、通常 :func:`iter` を呼んだり、 イテレータオブジェクトを自分で扱う必要はありません。 ``for`` 文ではこの操作を自動的に行い、無名の変数を作成してループの間イテレータを記憶します。 イテレータ(:term:`iterator`) シーケンス(:term:`sequence`), およびジェネレータ(:term:`generator`)も参照してください。"

#: ../../glossary.rst:416
msgid "iterator"
msgstr "iterator"

#: ../../glossary.rst:418
msgid ""
"An object representing a stream of data.  Repeated calls to the iterator's "
":meth:`~generator.next` method return successive items in the stream.  When "
"no more data are available a :exc:`StopIteration` exception is raised "
"instead.  At this point, the iterator object is exhausted and any further "
"calls to its :meth:`~generator.next` method just raise :exc:`StopIteration` "
"again.  Iterators are required to have an :meth:`__iter__` method that "
"returns the iterator object itself so every iterator is also iterable and "
"may be used in most places where other iterables are accepted.  One notable "
"exception is code which attempts multiple iteration passes.  A container "
"object (such as a :class:`list`) produces a fresh new iterator each time you"
" pass it to the :func:`iter` function or use it in a :keyword:`for` loop.  "
"Attempting this with an iterator will just return the same exhausted "
"iterator object used in the previous iteration pass, making it appear like "
"an empty container."
msgstr "(イテレータ) データの流れを表現するオブジェクトです。イテレータの :meth:`~generator.next` メソッドを繰り返し呼び出すと、流れの中の要素を一つずつ返します。データがなくなると、代わりに :exc:`StopIteration` 例外を送出します。その時点で、イテレータオブジェクトは尽きており、それ以降は :meth:`~generator.next` を何度呼んでも :exc:`StopIteration` を送出します。イテレータは、そのイテレータオブジェクト自体を返す :meth:`__iter__` メソッドを実装しなければならないので、イテレータは他の iterable を受理するほとんどの場所で利用できます。はっきりとした例外は複数の反復を行うようなコードです。 (:class:`list` のような) コンテナオブジェクトは、自身を :func:`iter` 関数にオブジェクトに渡したり :keyword:`for` ループ内で使うたびに、新たな未使用のイテレータを生成します。これをイテレータで行おうとすると、前回のイテレーションで使用済みの同じイテレータオブジェクトを単純に返すため、空のコンテナのようになってしまします。"

#: ../../glossary.rst:432
msgid "More information can be found in :ref:`typeiter`."
msgstr "詳細な情報は :ref:`typeiter` にあります。"

#: ../../glossary.rst:433
msgid "key function"
msgstr "key function"

#: ../../glossary.rst:435
msgid ""
"A key function or collation function is a callable that returns a value used"
" for sorting or ordering.  For example, :func:`locale.strxfrm` is used to "
"produce a sort key that is aware of locale specific sort conventions."
msgstr "(キー関数) キー関数、あるいは照合関数とは、ソートや順序比較のための値を返す呼び出し可能オブジェクト(callable)です。例えば、 :func:`locale.strxfrm` をキー関数に使えば、ロケール依存のソートの慣習にのっとったソートキーを返します。"

#: ../../glossary.rst:440
msgid ""
"A number of tools in Python accept key functions to control how elements are"
" ordered or grouped.  They include :func:`min`, :func:`max`, :func:`sorted`,"
" :meth:`list.sort`, :func:`heapq.nsmallest`, :func:`heapq.nlargest`, and "
":func:`itertools.groupby`."
msgstr "Python には、キー関数を受け付けて要素がどのように順序付けられたりグループ化されたりするかを制御するような、いくつかのツールがあります。例えば、 :func:`min`, :func:`max`, :func:`sorted`, :meth:`list.sort`, :func:`heapq.nsmallest`, :func:`heapq.nlargest`, :func:`itertools.groupby` です。"

#: ../../glossary.rst:445
msgid ""
"There are several ways to create a key function.  For example. the "
":meth:`str.lower` method can serve as a key function for case insensitive "
"sorts.  Alternatively, an ad-hoc key function can be built from a "
":keyword:`lambda` expression such as ``lambda r: (r[0], r[2])``.  Also, the "
":mod:`operator` module provides three key function constructors: "
":func:`~operator.attrgetter`, :func:`~operator.itemgetter`, and "
":func:`~operator.methodcaller`.  See the :ref:`Sorting HOW TO "
"<sortinghowto>` for examples of how to create and use key functions."
msgstr "キー関数を作る方法はいくつかあります。例えば、 :meth:`str.lower` メソッドをキー関数として使って大文字小文字を区別しないソートができます。 他には、:keyword:`lambda` 式を使って ``lambda r: (r[0], r[2])`` のようなアドホックなキー関数を作ることができます。また、 :mod:`operator` モジュールは :func:`~operator.attrgetter`, :func:`~operator.itemgetter`, :func:`~operator.methodcaller` というキー関数コンストラクタを提供しています。キー関数の作り方、使い方に関する例は、 :ref:`Sorting HOW TO <sortinghowto>` を参照してください。"

#: ../../glossary.rst:453
msgid "keyword argument"
msgstr "keyword argument"

#: ../../glossary.rst:455 ../../glossary.rst:644
msgid "See :term:`argument`."
msgstr ":term:`実引数<argument>` を参照してください。"

#: ../../glossary.rst:456
msgid "lambda"
msgstr "lambda"

#: ../../glossary.rst:458
msgid ""
"An anonymous inline function consisting of a single :term:`expression` which"
" is evaluated when the function is called.  The syntax to create a lambda "
"function is ``lambda [arguments]: expression``"
msgstr "(ラムダ) 無名のインライン関数で、関数が呼び出されたときに評価される 1 つの式 (:term:`expression`) を含みます。ラムダ関数を作る構文は ``lambda [arguments]: expression`` です。"

#: ../../glossary.rst:461
msgid "LBYL"
msgstr "LBYL"

#: ../../glossary.rst:463
msgid ""
"Look before you leap.  This coding style explicitly tests for pre-conditions"
" before making calls or lookups.  This style contrasts with the :term:`EAFP`"
" approach and is characterized by the presence of many :keyword:`if` "
"statements."
msgstr "「ころばぬ先の杖 (look before you leap)」 の略です。このコーディングスタイルでは、呼び出しや検索を行う前に、明示的に前提条件 (pre-condition) 判定を行います。 :term:`EAFP` アプローチと対照的で、 :keyword:`if` 文がたくさん使われるのが特徴的です。"

#: ../../glossary.rst:468
msgid ""
"In a multi-threaded environment, the LBYL approach can risk introducing a "
"race condition between \"the looking\" and \"the leaping\".  For example, "
"the code, ``if key in mapping: return mapping[key]`` can fail if another "
"thread removes *key* from *mapping* after the test, but before the lookup. "
"This issue can be solved with locks or by using the EAFP approach."
msgstr "マルチスレッド化された環境では、LBYL アプローチは \"見る\" 過程と \"飛ぶ\" 過程の競合状態を引き起こすリスクがあります。例えば、``if key in mapping: return mapping[key]`` というコードは、判定の後、別のスレッドが探索の前に *mapping* から *key* を取り除くと失敗します。この問題は、ロックするか EAFP アプローチを使うことで解決できます。"

#: ../../glossary.rst:473
msgid "list"
msgstr "list"

#: ../../glossary.rst:475
msgid ""
"A built-in Python :term:`sequence`.  Despite its name it is more akin to an "
"array in other languages than to a linked list since access to elements are "
"O(1)."
msgstr "(リスト) Python の組み込みのシーケンス (:term:`sequence`) です。リストという名前ですが、リンクリストではなく、他の言語で言う配列 (array) と同種のもので、要素へのアクセスは O(1) です。"

#: ../../glossary.rst:478
msgid "list comprehension"
msgstr "list comprehension"

#: ../../glossary.rst:480
msgid ""
"A compact way to process all or part of the elements in a sequence and "
"return a list with the results.  ``result = [\"0x%02x\" % x for x in "
"range(256) if x % 2 == 0]`` generates a list of strings containing even hex "
"numbers (0x..) in the range from 0 to 255. The :keyword:`if` clause is "
"optional.  If omitted, all elements in ``range(256)`` are processed."
msgstr "(リスト内包表記) シーケンス内の全てあるいは一部の要素を処理して、その結果からなるリストを返す、 コンパクトな書き方です。 ``result = [\"0x%02x\" % x for x in range(256) if x % 2 == 0]`` とすると、 0 から 255 までの偶数を 16進数表記 (0x..) した文字列からなるリストを生成します。 :keyword:`if` 節はオプションです。 :keyword:`if` 節がない場合、 ``range(256)`` の全ての要素が処理されます。"

#: ../../glossary.rst:486
msgid "loader"
msgstr "loader"

#: ../../glossary.rst:488
msgid ""
"An object that loads a module. It must define a method named "
":meth:`load_module`. A loader is typically returned by a :term:`finder`. See"
" :pep:`302` for details."
msgstr "モジュールをロードするオブジェクト。 :meth:`load_module` という名前のメソッドを定義していなければなりません。 詳細は :pep:`302` を参照してください。"

#: ../../glossary.rst:491
msgid "mapping"
msgstr "mapping"

#: ../../glossary.rst:493
msgid ""
"A container object that supports arbitrary key lookups and implements the "
"methods specified in the :class:`~collections.Mapping` or "
":class:`~collections.MutableMapping` :ref:`abstract base classes "
"<collections-abstract-base-classes>`.  Examples include :class:`dict`, "
":class:`collections.defaultdict`, :class:`collections.OrderedDict` and "
":class:`collections.Counter`."
msgstr "(マップ、マッピング) 任意のキーに対する検索をサポートしていて、 :class:`Mapping` か :class:`MutableMapping` の :ref:`抽象基底クラス <abstract-base-classes>` を実装しているコンテナオブジェクト。 例えば、 :class:`dict`, :class:`collections.defaultdict`, :class:`collections.OrderedDict`, :class:`collections.Counter` はマップ型です。"

#: ../../glossary.rst:499
msgid "metaclass"
msgstr "metaclass"

#: ../../glossary.rst:501
msgid ""
"The class of a class.  Class definitions create a class name, a class "
"dictionary, and a list of base classes.  The metaclass is responsible for "
"taking those three arguments and creating the class.  Most object oriented "
"programming languages provide a default implementation.  What makes Python "
"special is that it is possible to create custom metaclasses.  Most users "
"never need this tool, but when the need arises, metaclasses can provide "
"powerful, elegant solutions.  They have been used for logging attribute "
"access, adding thread-safety, tracking object creation, implementing "
"singletons, and many other tasks."
msgstr "(メタクラス) クラスのクラスです。クラス定義は、クラス名、クラスの辞書と、基底クラスのリストを作ります。メタクラスは、それら 3 つを引数として受け取り、クラスを作る責任を負います。ほとんどのオブジェクト指向言語は(訳注:メタクラスの)デフォルトの実装を提供しています。Python が特別なのはカスタムのメタクラスを作成できる点です。ほとんどのユーザーに取って、メタクラスは全く必要のないものです。しかし、一部の場面では、メタクラスは強力でエレガントな方法を提供します。たとえば属性アクセスのログを取ったり、スレッドセーフ性を追加したり、オブジェクトの生成を追跡したり、シングルトンを実装するなど、多くの場面で利用されます。"

#: ../../glossary.rst:511
msgid "More information can be found in :ref:`metaclasses`."
msgstr "詳細は :ref:`metaclasses` を参照してください。"

#: ../../glossary.rst:512
msgid "method"
msgstr "method"

#: ../../glossary.rst:514
msgid ""
"A function which is defined inside a class body.  If called as an attribute "
"of an instance of that class, the method will get the instance object as its"
" first :term:`argument` (which is usually called ``self``). See "
":term:`function` and :term:`nested scope`."
msgstr "(メソッド) クラス本体の中で定義された関数。そのクラスのインスタンスの属性として呼び出された場合、メソッドはインスタンスオブジェクトを第一引数 (:term:`argument`) として受け取ります (この第一引数は通常 ``self`` と呼ばれます)。 :term:`関数<function>` と :term:`ネストされたスコープ<nested scope>` も参照してください。"

#: ../../glossary.rst:518
msgid "method resolution order"
msgstr "method resolution order"

#: ../../glossary.rst:520
msgid ""
"Method Resolution Order is the order in which base classes are searched for "
"a member during lookup. See `The Python 2.3 Method Resolution Order "
"<https://www.python.org/download/releases/2.3/mro/>`_ for details of the "
"algorithm used by the Python interpreter since the 2.3 release."
msgstr "(メソッド解決順序)\n探索中に基底クラスが構成要素を検索される順番です。\n2.3 以降の Python インタープリタが使用するアルゴリズムの詳細については `The Python 2.3 Method Resolution Order <https://www.python.org/download/releases/2.3/mro/>`_ を参照してください。"

#: ../../glossary.rst:524
msgid "module"
msgstr "モジュール"

#: ../../glossary.rst:526
msgid ""
"An object that serves as an organizational unit of Python code.  Modules "
"have a namespace containing arbitrary Python objects.  Modules are loaded "
"into Python by the process of :term:`importing`."
msgstr "(モジュール) Python コードの組織単位としてはたらくオブジェクトです。モジュールは任意の Python オブジェクトを含む名前空間を持ちます。モジュールは :term:`importing` の処理によって Python に読み込まれます。"

#: ../../glossary.rst:530
msgid "See also :term:`package`."
msgstr ":term:`パッケージ<package>` を参照してください。"

#: ../../glossary.rst:531
msgid "MRO"
msgstr "MRO"

#: ../../glossary.rst:533
msgid "See :term:`method resolution order`."
msgstr ":term:`method resolution order` を参照してください。"

#: ../../glossary.rst:534
msgid "mutable"
msgstr "mutable"

#: ../../glossary.rst:536
msgid ""
"Mutable objects can change their value but keep their :func:`id`.  See also "
":term:`immutable`."
msgstr "(ミュータブル) ミュータブルなオブジェクトは、 :func:`id` を変えることなく値を変更できます。イミュータブル (:term:`immutable`) も参照してください。"

#: ../../glossary.rst:538
msgid "named tuple"
msgstr "named tuple"

#: ../../glossary.rst:540
msgid ""
"Any tuple-like class whose indexable elements are also accessible using "
"named attributes (for example, :func:`time.localtime` returns a tuple-like "
"object where the *year* is accessible either with an index such as ``t[0]`` "
"or with a named attribute like ``t.tm_year``)."
msgstr "(名前付きタプル) タプルに似ていて、インデクス指定できる要素に名前付き属性でもアクセス出来るクラスです (例えば、 :func:`time.localtime` はタプルに似たオブジェクトを返し、その *year* には ``t[0]`` のようなインデクスによるアクセスと、 ``t.tm_year`` のような名前付き要素としてのアクセスが可能です)。"

#: ../../glossary.rst:545
msgid ""
"A named tuple can be a built-in type such as :class:`time.struct_time`, or "
"it can be created with a regular class definition.  A full featured named "
"tuple can also be created with the factory function "
":func:`collections.namedtuple`.  The latter approach automatically provides "
"extra features such as a self-documenting representation like "
"``Employee(name='jones', title='programmer')``."
msgstr "名前付きタプルには、 :class:`time.struct_time` のような組み込み型もありますし、通常のクラス定義によって作成することもできます。名前付きタプルを :func:`collections.namedtuple` ファクトリ関数で作成することもできます。最後の方法で作った名前付きタプルには自動的に、 ``Employee(name='jones', title='programmer')`` のような自己ドキュメント表現 (self-documenting representation) などの機能が付いてきます。"

#: ../../glossary.rst:551
msgid "namespace"
msgstr "namespace"

#: ../../glossary.rst:553
msgid ""
"The place where a variable is stored.  Namespaces are implemented as "
"dictionaries.  There are the local, global and built-in namespaces as well "
"as nested namespaces in objects (in methods).  Namespaces support modularity"
" by preventing naming conflicts.  For instance, the functions "
":func:`__builtin__.open` and :func:`os.open` are distinguished by their "
"namespaces.  Namespaces also aid readability and maintainability by making "
"it clear which module implements a function.  For instance, writing "
":func:`random.seed` or :func:`itertools.izip` makes it clear that those "
"functions are implemented by the :mod:`random` and :mod:`itertools` modules,"
" respectively."
msgstr "(名前空間) 変数を記憶している場所です。 名前空間は辞書を用いて実装されています。 名前空間には、ローカル、グローバル、組み込み名前空間、そして (メソッド内の) オブジェクトのネストされた名前空間があります。 例えば、関数 :func:`__builtin__.open` と :func:`os.open` は名前空間で区別されます。 名前空間はまた、ある関数をどのモジュールが実装しているかをはっきりさせることで、 可読性やメンテナンス性に寄与します。 例えば、 :func:`random.seed`, :func:`itertools.izip` と書くことで、これらの関数がそれぞれ :mod:`random` モジュールや :mod:`itertools` モジュールで実装されていることがはっきりします。"

#: ../../glossary.rst:563
msgid "nested scope"
msgstr "nested scope"

#: ../../glossary.rst:565
msgid ""
"The ability to refer to a variable in an enclosing definition.  For "
"instance, a function defined inside another function can refer to variables "
"in the outer function.  Note that nested scopes work only for reference and "
"not for assignment which will always write to the innermost scope.  In "
"contrast, local variables both read and write in the innermost scope.  "
"Likewise, global variables read and write to the global namespace."
msgstr "(ネストされたスコープ) 外側で定義されている変数を参照する機能。 具体的に言えば、ある関数が別の関数の中で定義されている場合、内側の関数は外側の関数中の変数を参照できます。ネストされたスコープからは変数の参照だけができ、外側の変数を変更できないことに注意してください。それは常に最も内側のスコープに対する書き込みになります。 対照的に、ローカル変数は最も内側のスコープ内の読み書き両方します。同様に、グローバル変数を使うとグローバル名前空間の値を読み書きします。"

#: ../../glossary.rst:571
msgid "new-style class"
msgstr "new-style class"

#: ../../glossary.rst:573
msgid ""
"Any class which inherits from :class:`object`.  This includes all built-in "
"types like :class:`list` and :class:`dict`.  Only new-style classes can use "
"Python's newer, versatile features like :attr:`~object.__slots__`, "
"descriptors, properties, and :meth:`__getattribute__`."
msgstr "(新スタイルクラス) :class:`object` から継承したクラス全てを指します。これには :class:`list` や :class:`dict` のような全ての組み込み型が含まれます。 :meth:`~object.__slots__`, デスクリプタ、プロパティ、 :meth:`__getattribute__` といった、 Python の新しい機能を使えるのは新スタイルクラスだけです。"

#: ../../glossary.rst:578
msgid "More information can be found in :ref:`newstyle`."
msgstr "より詳しい情報は :ref:`newstyle` を参照してください。"

#: ../../glossary.rst:579
msgid "object"
msgstr "object"

#: ../../glossary.rst:581
msgid ""
"Any data with state (attributes or value) and defined behavior (methods).  "
"Also the ultimate base class of any :term:`new-style class`."
msgstr "(オブジェクト) 状態 (属性や値) と定義された振る舞い (メソッド) をもつ全てのデータ。もしくは、全ての新スタイルクラス (:term:`new-style class`) の究極の基底クラスのこと。"

#: ../../glossary.rst:584
msgid "package"
msgstr "package"

#: ../../glossary.rst:586
msgid ""
"A Python :term:`module` which can contain submodules or recursively, "
"subpackages.  Technically, a package is a Python module with an ``__path__``"
" attribute."
msgstr "(パッケージ) サブモジュールや再帰的にサブパッケージを含むことの出来る :term:`module` のことです。専門的には、パッケージは ``__path__`` 属性を持つ Python オブジェクトです。"

#: ../../glossary.rst:589
msgid "parameter"
msgstr "parameter"

#: ../../glossary.rst:591
msgid ""
"A named entity in a :term:`function` (or method) definition that specifies "
"an :term:`argument` (or in some cases, arguments) that the function can "
"accept.  There are four types of parameters:"
msgstr "(仮引数) 名前付の実体でterm:`関数<function>` (やterm:`メソッド<method>`) の定義において関数が受ける :term:`実引数<argument>` を明示します。仮引数には4種類あります:"

#: ../../glossary.rst:595
msgid ""
":dfn:`positional-or-keyword`: specifies an argument that can be passed "
"either :term:`positionally <argument>` or as a :term:`keyword argument "
"<argument>`.  This is the default kind of parameter, for example *foo* and "
"*bar* in the following::"
msgstr ":dfn:`位置またはキーワード`: :term:`位置 <argument>` でまたは :term:`キーワード引数 <argument>` として渡すことができる引数を指定します。これはたとえば以下の *foo* や *bar* のように、デフォルトの仮引数の種類です::"

#: ../../glossary.rst:602
msgid ""
":dfn:`positional-only`: specifies an argument that can be supplied only by "
"position.  Python has no syntax for defining positional-only parameters.  "
"However, some built-in functions have positional-only parameters (e.g. "
":func:`abs`)."
msgstr ":dfn:`位置専用`: 位置によってのみ与えられる引数を指定します。Python に位置専用仮引数を定義する文法はありません。しかし、組み込み関数には位置専用仮引数を持つもの (例: :func:`abs`) があります。"

#: ../../glossary.rst:607
msgid ""
":dfn:`var-positional`: specifies that an arbitrary sequence of positional "
"arguments can be provided (in addition to any positional arguments already "
"accepted by other parameters).  Such a parameter can be defined by "
"prepending the parameter name with ``*``, for example *args* in the "
"following::"
msgstr ":dfn:`可変長位置`: (他の仮引数で既に受けられた任意の位置引数に加えて) 任意の個数の位置引数が与えられることを指定します。このような仮引数は、以下の *args* のように仮引数名の前に ``*`` をつけることで定義できます::"

#: ../../glossary.rst:615
msgid ""
":dfn:`var-keyword`: specifies that arbitrarily many keyword arguments can be"
" provided (in addition to any keyword arguments already accepted by other "
"parameters).  Such a parameter can be defined by prepending the parameter "
"name with ``**``, for example *kwargs* in the example above."
msgstr ":dfn:`可変長キーワード`: (他の仮引数で既に受けられた任意のキーワード引数に加えて) 任意の個数のキーワード引数が与えられることを指定します。このような仮引数は、上の例の *kwargs* のように仮引数名の前に ``**`` をつけることで定義できます。"

#: ../../glossary.rst:621
msgid ""
"Parameters can specify both optional and required arguments, as well as "
"default values for some optional arguments."
msgstr "仮引数はオプションと必須の引数のどちらも指定でき、オプションの引数にはデフォルト値も指定できます。"

#: ../../glossary.rst:624
msgid ""
"See also the :term:`argument` glossary entry, the FAQ question on :ref:`the "
"difference between arguments and parameters <faq-argument-vs-parameter>`, "
"and the :ref:`function` section."
msgstr ":term:`argument` 、FAQ の :ref:`実引数と仮引数の違いは何ですか? <faq-argument-vs-parameter>` 、:ref:`function` を参照してください。"

#: ../../glossary.rst:627
msgid "PEP"
msgstr ""

#: ../../glossary.rst:629
msgid ""
"Python Enhancement Proposal. A PEP is a design document providing "
"information to the Python community, or describing a new feature for Python "
"or its processes or environment. PEPs should provide a concise technical "
"specification and a rationale for proposed features."
msgstr ""

#: ../../glossary.rst:635
msgid ""
"PEPs are intended to be the primary mechanisms for proposing major new "
"features, for collecting community input on an issue, and for documenting "
"the design decisions that have gone into Python. The PEP author is "
"responsible for building consensus within the community and documenting "
"dissenting opinions."
msgstr ""

#: ../../glossary.rst:641
msgid "See :pep:`1`."
msgstr ""

#: ../../glossary.rst:642
msgid "positional argument"
msgstr "位置引数"

#: ../../glossary.rst:645
msgid "Python 3000"
msgstr "Python 3000"

#: ../../glossary.rst:647
msgid ""
"Nickname for the Python 3.x release line (coined long ago when the release "
"of version 3 was something in the distant future.)  This is also abbreviated"
" \"Py3k\"."
msgstr "Python 3.x リリースラインのニックネームです。(Python 3 が遠い将来の話だった頃に作られた言葉です。) \"Py3k\" と略されることもあります。"

#: ../../glossary.rst:650
msgid "Pythonic"
msgstr "Pythonic"

#: ../../glossary.rst:652
msgid ""
"An idea or piece of code which closely follows the most common idioms of the"
" Python language, rather than implementing code using concepts common to "
"other languages.  For example, a common idiom in Python is to loop over all "
"elements of an iterable using a :keyword:`for` statement.  Many other "
"languages don't have this type of construct, so people unfamiliar with "
"Python sometimes use a numerical counter instead::"
msgstr "他の言語で一般的な考え方で書かれたコードではなく、Python の特に一般的なイディオムに従った考え方やコード片。例えば、Python の一般的なイディオムでは :keyword:`for` 文を使ってイテラブルのすべての要素に渡ってループします。他の多くの言語にはこの仕組みはないので、Python に慣れていない人は代わりに数値のカウンターを使うかもしれません::"

#: ../../glossary.rst:662
msgid "As opposed to the cleaner, Pythonic method::"
msgstr "これに対し、きれいな Pythonic な方法は::"

#: ../../glossary.rst:666
msgid "reference count"
msgstr "reference count"

#: ../../glossary.rst:668
msgid ""
"The number of references to an object.  When the reference count of an "
"object drops to zero, it is deallocated.  Reference counting is generally "
"not visible to Python code, but it is a key element of the :term:`CPython` "
"implementation.  The :mod:`sys` module defines a :func:`~sys.getrefcount` "
"function that programmers can call to return the reference count for a "
"particular object."
msgstr "(参照カウント) あるオブジェクトに対する参照の数。参照カウントが0になったとき、そのオブジェクトは破棄されます。参照カウントは通常は Python のコード上には現れませんが、 :term:`CPython` 実装の重要な要素です。 :mod:`sys` モジュールは、プログラマーが任意のオブジェクトの参照カウントを知るための :func:`~sys.getrefcount` 関数を提供しています。"

#: ../../glossary.rst:674
msgid "__slots__"
msgstr "__slots__"

#: ../../glossary.rst:676
msgid ""
"A declaration inside a :term:`new-style class` that saves memory by pre-"
"declaring space for instance attributes and eliminating instance "
"dictionaries.  Though popular, the technique is somewhat tricky to get right"
" and is best reserved for rare cases where there are large numbers of "
"instances in a memory-critical application."
msgstr "新スタイルクラス(:term:`new-style class`)内で、インスタンス属性の記憶に 必要な領域をあらかじめ定義しておき、それとひきかえにインスタンス辞書を排除して メモリの節約を行うための宣言です。 これはよく使われるテクニックですが、正しく動作させるのには少々手際を要するので、 例えばメモリが死活問題となるようなアプリケーション内にインスタンスが大量に 存在するといった稀なケースを除き、使わないのがベストです。"

#: ../../glossary.rst:681
msgid "sequence"
msgstr "sequence"

#: ../../glossary.rst:683
msgid ""
"An :term:`iterable` which supports efficient element access using integer "
"indices via the :meth:`__getitem__` special method and defines a :meth:`len`"
" method that returns the length of the sequence. Some built-in sequence "
"types are :class:`list`, :class:`str`, :class:`tuple`, and :class:`unicode`."
" Note that :class:`dict` also supports :meth:`__getitem__` and "
":meth:`__len__`, but is considered a mapping rather than a sequence because "
"the lookups use arbitrary :term:`immutable` keys rather than integers."
msgstr "(シーケンス) 特殊メソッド :meth:`__getitem__` で整数インデックスによる効率的な要素へのアクセスを サポートし、 :meth:`len` で長さを返すような反復可能オブジェクト(:term:`iterable`)です。 組み込みシーケンス型には、 :class:`list`, :class:`str`, :class:`tuple`, :class:`unicode` などがあります。 :class:`dict` は :meth:`__getitem__` と :meth:`__len__` もサポートしますが、 検索の際に任意の変更不能(:term:`immutable`)なキーを使うため、シーケンスではなく マップ (mapping) とみなされているので注意してください。"

#: ../../glossary.rst:691
msgid "slice"
msgstr "slice"

#: ../../glossary.rst:693
msgid ""
"An object usually containing a portion of a :term:`sequence`.  A slice is "
"created using the subscript notation, ``[]`` with colons between numbers "
"when several are given, such as in ``variable_name[1:3:5]``.  The bracket "
"(subscript) notation uses :class:`slice` objects internally (or in older "
"versions, :meth:`__getslice__` and :meth:`__setslice__`)."
msgstr "(スライス) 多くの場合、シーケンス(:term:`sequence`)の一部を含むオブジェクト。 スライスは、添字記号 ``[]`` で数字の間にコロンを書いたときに作られます。 例えば、 ``variable_name[1:3:5]`` です。 添字記号は :class:`slice` オブジェクトを内部で利用しています。 (もしくは、古いバージョンの、 :meth:`__getslice__` と :meth:`__setslice__` を利用します。)"

#: ../../glossary.rst:698
msgid "special method"
msgstr "special method"

#: ../../glossary.rst:700
msgid ""
"A method that is called implicitly by Python to execute a certain operation "
"on a type, such as addition.  Such methods have names starting and ending "
"with double underscores.  Special methods are documented in "
":ref:`specialnames`."
msgstr "(特殊メソッド) ある型に特定の操作、例えば加算をするために Python から暗黙に呼び出されるメソッド。この種類のメソッドは、メソッド名の最初と最後にアンダースコア 2 つがついています。特殊メソッドについては :ref:`specialnames` で解説されています。"

#: ../../glossary.rst:704
msgid "statement"
msgstr "statement"

#: ../../glossary.rst:706
msgid ""
"A statement is part of a suite (a \"block\" of code).  A statement is either"
" an :term:`expression` or one of several constructs with a keyword, such as "
":keyword:`if`, :keyword:`while` or :keyword:`for`."
msgstr "(文) 文はスイート (コードの\"ブロック\") に不可欠な要素です。文は :term:`式<expression>` かキーワードから構成されるもののどちらかです。後者には :keyword:`if`、:keyword:`while`、:keyword:`for` があります。"

#: ../../glossary.rst:709
msgid "struct sequence"
msgstr "struct sequence"

#: ../../glossary.rst:711
msgid ""
"A tuple with named elements. Struct sequences expose an interface similiar "
"to :term:`named tuple` in that elements can either be accessed either by "
"index or as an attribute. However, they do not have any of the named tuple "
"methods like :meth:`~collections.somenamedtuple._make` or "
":meth:`~collections.somenamedtuple._asdict`. Examples of struct sequences "
"include :data:`sys.float_info` and the return value of :func:`os.stat`."
msgstr "(構造体シーケンス) 名付けられた要素を持つタプルです。構造体シーケンスは :term:`named tuple` と同じく、要素にインデクスでも属性でもアクセスできるインタフェースを公開します。しかし、名前付きタプルの :meth:`~collections.somenamedtuple._make` や :meth:`~collections.somenamedtuple._asdict` のようなメソッドを持ちません。構造体シーケンスの例には、:data:`sys.float_info` や、 :func:`os.stat` の返り値や、その他があります。"

#: ../../glossary.rst:717
msgid "triple-quoted string"
msgstr "triple-quoted string"

#: ../../glossary.rst:719
msgid ""
"A string which is bound by three instances of either a quotation mark (\") "
"or an apostrophe (').  While they don't provide any functionality not "
"available with single-quoted strings, they are useful for a number of "
"reasons.  They allow you to include unescaped single and double quotes "
"within a string and they can span multiple lines without the use of the "
"continuation character, making them especially useful when writing "
"docstrings."
msgstr "(三重クォート文字列) 3つの連続したクォート記号(\")かアポストロフィー(')で囲まれた文字列。通常の(一重)クォート文字列に比べて表現できる文字列に違いはありませんが、幾つかの理由で有用です。1つか2つの連続したクォート記号をエスケープ無しに書くことができますし、行継続文字(\\\\)を使わなくても複数行にまたがることができるので、ドキュメンテーション文字列を書く時に特に便利です。"

#: ../../glossary.rst:726
msgid "type"
msgstr "型"

#: ../../glossary.rst:728
msgid ""
"The type of a Python object determines what kind of object it is; every "
"object has a type.  An object's type is accessible as its "
":attr:`~instance.__class__` attribute or can be retrieved with "
"``type(obj)``."
msgstr "(型) Python オブジェクトの型はオブジェクトがどのようなものかを決めます。あらゆるオブジェクトは型を持っています。オブジェクトの型は :attr:`~instance.__class__` 属性でアクセスしたり、``type(obj)`` で取得したり出来ます。"

#: ../../glossary.rst:732
msgid "universal newlines"
msgstr "universal newlines"

#: ../../glossary.rst:734
msgid ""
"A manner of interpreting text streams in which all of the following are "
"recognized as ending a line: the Unix end-of-line convention ``'\\n'``, the "
"Windows convention ``'\\r\\n'``, and the old Macintosh convention ``'\\r'``."
"  See :pep:`278` and :pep:`3116`, as well as :func:`str.splitlines` for an "
"additional use."
msgstr "テキストストリームの解釈法の一つで、以下のすべてを行末と認識します: Unix の行末規定 ``'\\n'``、Windows の規定 ``'\\r\\n'``、古い Macintosh の規定 ``'\\r'``。利用法について詳しくは、 :pep:`278` と :pep:`3116` 、さらに :func:`str.splitlines` も参照してください。"

#: ../../glossary.rst:739
msgid "virtual environment"
msgstr "virtual environment"

#: ../../glossary.rst:741
msgid ""
"A cooperatively isolated runtime environment that allows Python users and "
"applications to install and upgrade Python distribution packages without "
"interfering with the behaviour of other Python applications running on the "
"same system."
msgstr "（仮想環境）協調的に切り離された実行環境です。これにより Python ユーザとアプリケーションは同じシステム上で動いている他の Python アプリケーションの挙動に干渉することなく Python パッケージのインストールと更新を行うことができます。"

#: ../../glossary.rst:745
msgid "virtual machine"
msgstr "virtual machine"

#: ../../glossary.rst:747
msgid ""
"A computer defined entirely in software.  Python's virtual machine executes "
"the :term:`bytecode` emitted by the bytecode compiler."
msgstr "(仮想マシン) 完全にソフトウェアにより定義されたコンピュータ。 Python の仮想マシンは、バイトコードコンパイラが出力したバイトコード (:term:`bytecode`) を実行します。"

#: ../../glossary.rst:749
msgid "Zen of Python"
msgstr "Zen of Python"

#: ../../glossary.rst:751
msgid ""
"Listing of Python design principles and philosophies that are helpful in "
"understanding and using the language.  The listing can be found by typing "
"\"``import this``\" at the interactive prompt."
msgstr "(Pythonの悟り) Python を理解し利用する上での導きとなる、Python の設計原則と哲学をリストにしたものです。対話プロンプトで \"``import this``\" とするとこのリストを読めます。"
